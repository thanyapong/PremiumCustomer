//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { customFormatter } from "../modules/_common/commonFunctions";
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import * as dayjs from 'dayjs';

export class ChangeBillClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getRemark( cancelToken?: CancelToken | undefined): Promise<RemarkResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/changebill/remark";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRemark(_response);
        });
    }

    protected processGetRemark(response: AxiosResponse): Promise<RemarkResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<RemarkResponseDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RemarkResponseDtoListServiceResponse>(null as any);
    }

    /**
     * @param billNo (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderChangeBills(branchId: number, userId: number, billNo?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<OrderChangeBillSelectsResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/changebill/orderchangebillselects?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined and cannot be null.");
        else
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (billNo === null)
            throw new Error("The parameter 'billNo' cannot be null.");
        else if (billNo !== undefined)
            url_ += "BillNo=" + encodeURIComponent("" + billNo) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderChangeBills(_response);
        });
    }

    protected processGetOrderChangeBills(response: AxiosResponse): Promise<OrderChangeBillSelectsResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<OrderChangeBillSelectsResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderChangeBillSelectsResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrderChangeBill(body?: OrderChangeBillUpdateRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_OrderChangeBill_UpdateResultServiceResponse> {
        let url_ = this.baseUrl + "/changebill/orderchangebillupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateOrderChangeBill(_response);
        });
    }

    protected processUpdateOrderChangeBill(response: AxiosResponse): Promise<Usp_OrderChangeBill_UpdateResultServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_OrderChangeBill_UpdateResultServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_OrderChangeBill_UpdateResultServiceResponse>(null as any);
    }

    /**
     * @return Success
     */
    generateCodeEditSell( cancelToken?: CancelToken | undefined): Promise<StringServiceResponse> {
        let url_ = this.baseUrl + "/changebill/generatecodeeditsell";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenerateCodeEditSell(_response);
        });
    }

    protected processGenerateCodeEditSell(response: AxiosResponse): Promise<StringServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<StringServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringServiceResponse>(null as any);
    }
}

export class DashboardClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * GET OrderCount
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param branchId (optional) 
     * @param userId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderCount(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, branchId?: number | undefined, userId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Dashboard/ordercount?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderCount(_response);
        });
    }

    protected processGetOrderCount(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET OrderMoUsers
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param branchId (optional) 
     * @param userId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderMoUsers(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, branchId?: number | undefined, userId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Dashboard/ordermousers?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderMoUsers(_response);
        });
    }

    protected processGetOrderMoUsers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET OrderMoViews
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderMoViews(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, branchId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Dashboard/ordermoviews?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderMoViews(_response);
        });
    }

    protected processGetOrderMoViews(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET OrderFullViews
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param branchId (optional) 
     * @param userId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderFullViews(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, branchId?: number | undefined, userId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Dashboard/orderfullviews?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderFullViews(_response);
        });
    }

    protected processGetOrderFullViews(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET OrderSubDetails
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param userId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderSubDetails(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, userId?: number | undefined, branchId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Dashboard/ordersubdetails?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderSubDetails(_response);
        });
    }

    protected processGetOrderSubDetails(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DashboardV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * GET OrderCount
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param branchId (optional) 
     * @param userId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderCountV2(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, branchId?: number | undefined, userId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<OrderCountResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/dashboard/ordercount?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderCountV2(_response);
        });
    }

    protected processGetOrderCountV2(response: AxiosResponse): Promise<OrderCountResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<OrderCountResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderCountResponseDtoServiceResponse>(null as any);
    }

    /**
     * GET OrderMoUsers
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param branchId (optional) 
     * @param userId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderMoUsersV2(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, branchId?: number | undefined, userId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<OrderMoUsersResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/dashboard/ordermousers?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderMoUsersV2(_response);
        });
    }

    protected processGetOrderMoUsersV2(response: AxiosResponse): Promise<OrderMoUsersResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<OrderMoUsersResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderMoUsersResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET OrderMoViews
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderMoViewsV2(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, branchId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<OrderMoViewsResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/dashboard/ordermoviews?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderMoViewsV2(_response);
        });
    }

    protected processGetOrderMoViewsV2(response: AxiosResponse): Promise<OrderMoViewsResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<OrderMoViewsResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderMoViewsResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET OrderFullViews
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param branchId (optional) 
     * @param userId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderFullViewsV2(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, branchId?: number | undefined, userId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_OrderDashboardAdmin_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/dashboard/orderfullviews?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderFullViewsV2(_response);
        });
    }

    protected processGetOrderFullViewsV2(response: AxiosResponse): Promise<Usp_OrderDashboardAdmin_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_OrderDashboardAdmin_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_OrderDashboardAdmin_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET OrderSubDetails
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param userId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderSubDetailsV2(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, userId?: number | undefined, branchId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<OrderSubDetailsResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/dashboard/ordersubdetails?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderSubDetailsV2(_response);
        });
    }

    protected processGetOrderSubDetailsV2(response: AxiosResponse): Promise<OrderSubDetailsResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<OrderSubDetailsResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderSubDetailsResponseDtoListServiceResponseWithPagination>(null as any);
    }
}

export class DirectDebitScheduleClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param period (optional) 
     * @return Success
     */
    getPeriodNow(period?: dayjs.Dayjs | undefined, cancelToken?: CancelToken | undefined): Promise<GetPeriodNowResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/directdebitschedule/period?";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPeriodNow(_response);
        });
    }

    protected processGetPeriodNow(response: AxiosResponse): Promise<GetPeriodNowResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetPeriodNowResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPeriodNowResponseDtoServiceResponse>(null as any);
    }
}

export class DocumentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    referenceid(docreferenceid: string, cancelToken?: CancelToken | undefined): Promise<DocumentDtoListServiceResponse> {
        let url_ = this.baseUrl + "/document/referenceid/{docreferenceid}";
        if (docreferenceid === undefined || docreferenceid === null)
            throw new Error("The parameter 'docreferenceid' must be defined.");
        url_ = url_.replace("{docreferenceid}", encodeURIComponent("" + docreferenceid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReferenceid(_response);
        });
    }

    protected processReferenceid(response: AxiosResponse): Promise<DocumentDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentDtoListServiceResponse>(null as any);
    }
}

export class KafKaClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Restart Kafka PremiumOrder TempDetailSource ก่อนกดอันนี้ ต้องกด triggerbankpaymentduedatehostedservice ใน Quartz ก่อนแล้วกดเรียงตามนี้ detail > Header > Group
     * @return Success
     */
    restartPremiumOrderTempDetailSource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/kafkacontroller/restartpremiumordertempdetailsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestartPremiumOrderTempDetailSource(_response);
        });
    }

    protected processRestartPremiumOrderTempDetailSource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Restart Kafka PremiumOrder TempHeaderSource
     * @return Success
     */
    restartPremiumOrderTempHeaderSource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/kafkacontroller/restartpremiumordertempheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestartPremiumOrderTempHeaderSource(_response);
        });
    }

    protected processRestartPremiumOrderTempHeaderSource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Restart Kafka PremiumOrder TempGroupSource
     * @return Success
     */
    restartPremiumOrderTempGroupSource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/kafkacontroller/restartpremiumordertempgroupsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestartPremiumOrderTempGroupSource(_response);
        });
    }

    protected processRestartPremiumOrderTempGroupSource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Restart Kafka PremiumOrder Temp Source รวมใน api เส้นเดียว ก่อนกดอันนี้ ต้องกด triggerbankpaymentduedatehostedservice ใน Quartz ก่อน
     * @return Success
     */
    restartPremiumOrderTempSource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/kafkacontroller/restartpremiumordertempsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestartPremiumOrderTempSource(_response);
        });
    }

    protected processRestartPremiumOrderTempSource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MasterClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getCheckoutProcess( cancelToken?: CancelToken | undefined): Promise<CheckoutProcessDtoListServiceResponse> {
        let url_ = this.baseUrl + "/order/master/checkoutprocess";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCheckoutProcess(_response);
        });
    }

    protected processGetCheckoutProcess(response: AxiosResponse): Promise<CheckoutProcessDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<CheckoutProcessDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckoutProcessDtoListServiceResponse>(null as any);
    }
}

export class OrderClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * สำหรับ บันทึก ผู้ชำระเบี้ยและแผนประกัน [UI1-1]
     * @param body (optional) 
     * @return Success
     */
    createOrder(body?: AddOrderDto | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/PostOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrder(_response);
        });
    }

    protected processCreateOrder(response: AxiosResponse): Promise<GetOrderDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ บันทึก ผู้ชำระเบี้ยและแผนประกัน [UI1-1]
     * @param body (optional) 
     * @return Success
     */
    reInvoiceOrder(tempOrderId: string, body?: AddOrderDto | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/PostReInvoiceOrder/{tempOrderId}";
        if (tempOrderId === undefined || tempOrderId === null)
            throw new Error("The parameter 'tempOrderId' must be defined.");
        url_ = url_.replace("{tempOrderId}", encodeURIComponent("" + tempOrderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReInvoiceOrder(_response);
        });
    }

    protected processReInvoiceOrder(response: AxiosResponse): Promise<GetOrderDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ บันทึก การยกเลิก bill
     * @param body (optional) 
     * @return Success
     */
    cancelOrderByBill(body?: AddCancelOrderDto | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/CancelOrderByBill";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancelOrderByBill(_response);
        });
    }

    protected processCancelOrderByBill(response: AxiosResponse): Promise<GetOrderDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ บันทึก การยกเลิก bill ด้วย Id
     * @param body (optional) 
     * @return Success
     */
    cancelOrderById(body?: AddCancelOrderByIdDto | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/CancelOrderById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancelOrderById(_response);
        });
    }

    protected processCancelOrderById(response: AxiosResponse): Promise<GetOrderDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ บันทึก การยกเลิก bill ด้วย Id แบบไม่ส่งไป premium
     * @param body (optional) 
     * @return Success
     */
    cancelOrderNoSendToPremiumById(body?: AddCancelOrderByIdDto | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/CancelOrderNoSendToPremiumById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancelOrderNoSendToPremiumById(_response);
        });
    }

    protected processCancelOrderNoSendToPremiumById(response: AxiosResponse): Promise<GetOrderDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ บันทึก BankDueDate by User
     * @param body (optional) 
     * @return Success
     */
    createBankDueDate(body?: CreateBankDueDateDto | undefined, cancelToken?: CancelToken | undefined): Promise<GetBankDueDateDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/CreateBankDueDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateBankDueDate(_response);
        });
    }

    protected processCreateBankDueDate(response: AxiosResponse): Promise<GetBankDueDateDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetBankDueDateDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBankDueDateDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ 1.2 DataTable
     * @param fullTextId (optional) 
     * @param fullText (optional) 
     * @param createdDateBegin (optional) 
     * @param createdDateEnd (optional) 
     * @param transactionDatetimeBegin (optional) 
     * @param transactionDatetimeEnd (optional) 
     * @param payablePeriodToBegin (optional) 
     * @param payablePeriodToEnd (optional) 
     * @param productTypeId (optional) 
     * @param productId (optional) 
     * @param checkoutProcessId (optional) 
     * @param paymentChannelId (optional) 
     * @param statusId (optional) 
     * @param cancelCauseId (optional) 
     * @param defaultLoader (optional) 
     * @param onlyNoApp (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderListTableincludeDetail(fullTextId?: number | undefined, fullText?: string | undefined, createdDateBegin?: dayjs.Dayjs | undefined, createdDateEnd?: dayjs.Dayjs | undefined, transactionDatetimeBegin?: dayjs.Dayjs | undefined, transactionDatetimeEnd?: dayjs.Dayjs | undefined, payablePeriodToBegin?: dayjs.Dayjs | undefined, payablePeriodToEnd?: dayjs.Dayjs | undefined, productTypeId?: string | undefined, productId?: string | undefined, checkoutProcessId?: string | undefined, paymentChannelId?: string | undefined, statusId?: string | undefined, cancelCauseId?: string | undefined, defaultLoader?: boolean | undefined, onlyNoApp?: boolean | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderListTableIncludeDetailDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderListTableincludeDetail/filter?";
        if (fullTextId === null)
            throw new Error("The parameter 'fullTextId' cannot be null.");
        else if (fullTextId !== undefined)
            url_ += "FullTextId=" + encodeURIComponent("" + fullTextId) + "&";
        if (fullText === null)
            throw new Error("The parameter 'fullText' cannot be null.");
        else if (fullText !== undefined)
            url_ += "FullText=" + encodeURIComponent("" + fullText) + "&";
        if (createdDateBegin === null)
            throw new Error("The parameter 'createdDateBegin' cannot be null.");
        else if (createdDateBegin !== undefined)
            url_ += "CreatedDateBegin=" + encodeURIComponent(createdDateBegin ? "" + createdDateBegin.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateEnd === null)
            throw new Error("The parameter 'createdDateEnd' cannot be null.");
        else if (createdDateEnd !== undefined)
            url_ += "CreatedDateEnd=" + encodeURIComponent(createdDateEnd ? "" + createdDateEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeBegin === null)
            throw new Error("The parameter 'transactionDatetimeBegin' cannot be null.");
        else if (transactionDatetimeBegin !== undefined)
            url_ += "TransactionDatetimeBegin=" + encodeURIComponent(transactionDatetimeBegin ? "" + transactionDatetimeBegin.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeEnd === null)
            throw new Error("The parameter 'transactionDatetimeEnd' cannot be null.");
        else if (transactionDatetimeEnd !== undefined)
            url_ += "TransactionDatetimeEnd=" + encodeURIComponent(transactionDatetimeEnd ? "" + transactionDatetimeEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToBegin === null)
            throw new Error("The parameter 'payablePeriodToBegin' cannot be null.");
        else if (payablePeriodToBegin !== undefined)
            url_ += "PayablePeriodToBegin=" + encodeURIComponent(payablePeriodToBegin ? "" + payablePeriodToBegin.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToEnd === null)
            throw new Error("The parameter 'payablePeriodToEnd' cannot be null.");
        else if (payablePeriodToEnd !== undefined)
            url_ += "PayablePeriodToEnd=" + encodeURIComponent(payablePeriodToEnd ? "" + payablePeriodToEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (checkoutProcessId === null)
            throw new Error("The parameter 'checkoutProcessId' cannot be null.");
        else if (checkoutProcessId !== undefined)
            url_ += "CheckoutProcessId=" + encodeURIComponent("" + checkoutProcessId) + "&";
        if (paymentChannelId === null)
            throw new Error("The parameter 'paymentChannelId' cannot be null.");
        else if (paymentChannelId !== undefined)
            url_ += "PaymentChannelId=" + encodeURIComponent("" + paymentChannelId) + "&";
        if (statusId === null)
            throw new Error("The parameter 'statusId' cannot be null.");
        else if (statusId !== undefined)
            url_ += "StatusId=" + encodeURIComponent("" + statusId) + "&";
        if (cancelCauseId === null)
            throw new Error("The parameter 'cancelCauseId' cannot be null.");
        else if (cancelCauseId !== undefined)
            url_ += "CancelCauseId=" + encodeURIComponent("" + cancelCauseId) + "&";
        if (defaultLoader === null)
            throw new Error("The parameter 'defaultLoader' cannot be null.");
        else if (defaultLoader !== undefined)
            url_ += "DefaultLoader=" + encodeURIComponent("" + defaultLoader) + "&";
        if (onlyNoApp === null)
            throw new Error("The parameter 'onlyNoApp' cannot be null.");
        else if (onlyNoApp !== undefined)
            url_ += "OnlyNoApp=" + encodeURIComponent("" + onlyNoApp) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderListTableincludeDetail(_response);
        });
    }

    protected processGetOrderListTableincludeDetail(response: AxiosResponse): Promise<GetOrderListTableIncludeDetailDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderListTableIncludeDetailDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderListTableIncludeDetailDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order โดย บัตร
     * @param cardDetail (optional) 
     * @param cardTypeId (optional) 
     * @return Success
     */
    getOrderbyCard(cardDetail?: string | undefined, cardTypeId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderbyCard?";
        if (cardDetail === null)
            throw new Error("The parameter 'cardDetail' cannot be null.");
        else if (cardDetail !== undefined)
            url_ += "cardDetail=" + encodeURIComponent("" + cardDetail) + "&";
        if (cardTypeId === null)
            throw new Error("The parameter 'cardTypeId' cannot be null.");
        else if (cardTypeId !== undefined)
            url_ += "cardTypeId=" + encodeURIComponent("" + cardTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderbyCard(_response);
        });
    }

    protected processGetOrderbyCard(response: AxiosResponse): Promise<GetOrderDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order Detail โดย id
     * @return Success
     */
    getOrderDetailById(orderId: string, cancelToken?: CancelToken | undefined): Promise<GetOrderDetailDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderDetailById/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderDetailById(_response);
        });
    }

    protected processGetOrderDetailById(response: AxiosResponse): Promise<GetOrderDetailDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderDetailDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderDetailDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order Sub Detail โดย id
     * @return Success
     */
    getOrderSubDetailById(orderDetailId: string, cancelToken?: CancelToken | undefined): Promise<GetOrderSubDetailDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderSubDetailById/{orderDetailId}";
        if (orderDetailId === undefined || orderDetailId === null)
            throw new Error("The parameter 'orderDetailId' must be defined.");
        url_ = url_.replace("{orderDetailId}", encodeURIComponent("" + orderDetailId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderSubDetailById(_response);
        });
    }

    protected processGetOrderSubDetailById(response: AxiosResponse): Promise<GetOrderSubDetailDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderSubDetailDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderSubDetailDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order Transaction header โดย บิล
     * @return Success
     */
    getOrderTransactionHeaderbyBill(bill: string, cancelToken?: CancelToken | undefined): Promise<GetTransactionHeaderDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderTransactionHeaderbyBill/{bill}";
        if (bill === undefined || bill === null)
            throw new Error("The parameter 'bill' must be defined.");
        url_ = url_.replace("{bill}", encodeURIComponent("" + bill));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderTransactionHeaderbyBill(_response);
        });
    }

    protected processGetOrderTransactionHeaderbyBill(response: AxiosResponse): Promise<GetTransactionHeaderDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetTransactionHeaderDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetTransactionHeaderDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order Transaction header โดย invoice
     * @return Success
     */
    getOrderTransactionHeaderbyInvoiceOld(invoice: string, cancelToken?: CancelToken | undefined): Promise<GetTransactionHeaderDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderTransactionHeaderbyInvoice_Old/{invoice}";
        if (invoice === undefined || invoice === null)
            throw new Error("The parameter 'invoice' must be defined.");
        url_ = url_.replace("{invoice}", encodeURIComponent("" + invoice));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderTransactionHeaderbyInvoiceOld(_response);
        });
    }

    protected processGetOrderTransactionHeaderbyInvoiceOld(response: AxiosResponse): Promise<GetTransactionHeaderDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetTransactionHeaderDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetTransactionHeaderDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order Transaction header โดย invoice
     * @return Success
     */
    getOrderTransactionHeaderbyInvoice(invoice: string, cancelToken?: CancelToken | undefined): Promise<GetTransactionHeaderWithInvoiceDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderTransactionHeaderbyInvoice/{invoice}";
        if (invoice === undefined || invoice === null)
            throw new Error("The parameter 'invoice' must be defined.");
        url_ = url_.replace("{invoice}", encodeURIComponent("" + invoice));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderTransactionHeaderbyInvoice(_response);
        });
    }

    protected processGetOrderTransactionHeaderbyInvoice(response: AxiosResponse): Promise<GetTransactionHeaderWithInvoiceDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetTransactionHeaderWithInvoiceDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetTransactionHeaderWithInvoiceDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order Transaction header โดย invoice
     * @return Success
     */
    getOrderTransactionHeaderbyInvoice2(invoice: string, cancelToken?: CancelToken | undefined): Promise<GetTransactionHeaderDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderTransactionHeaderbyInvoice2/{invoice}";
        if (invoice === undefined || invoice === null)
            throw new Error("The parameter 'invoice' must be defined.");
        url_ = url_.replace("{invoice}", encodeURIComponent("" + invoice));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderTransactionHeaderbyInvoice2(_response);
        });
    }

    protected processGetOrderTransactionHeaderbyInvoice2(response: AxiosResponse): Promise<GetTransactionHeaderDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetTransactionHeaderDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetTransactionHeaderDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order Transaction Detail โดย บิล และ Invoice : DataTable
     * @param bill (optional) 
     * @param invoice (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderTransaction(bill?: string | undefined, invoice?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetTransactionOrderDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderTransaction/payload?";
        if (bill === null)
            throw new Error("The parameter 'bill' cannot be null.");
        else if (bill !== undefined)
            url_ += "Bill=" + encodeURIComponent("" + bill) + "&";
        if (invoice === null)
            throw new Error("The parameter 'invoice' cannot be null.");
        else if (invoice !== undefined)
            url_ += "Invoice=" + encodeURIComponent("" + invoice) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderTransaction(_response);
        });
    }

    protected processGetOrderTransaction(response: AxiosResponse): Promise<GetTransactionOrderDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetTransactionOrderDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetTransactionOrderDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order โดย บิล
     * @return Success
     */
    getOrderbyBill(bill: string, cancelToken?: CancelToken | undefined): Promise<GetOrderListDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderbyBill/{bill}";
        if (bill === undefined || bill === null)
            throw new Error("The parameter 'bill' must be defined.");
        url_ = url_.replace("{bill}", encodeURIComponent("" + bill));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderbyBill(_response);
        });
    }

    protected processGetOrderbyBill(response: AxiosResponse): Promise<GetOrderListDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderListDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderListDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order โดย OrderId
     * @return Success
     */
    getOrderOnlybyId(orderId: string, cancelToken?: CancelToken | undefined): Promise<GetOrderListDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderOnlybyId/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderOnlybyId(_response);
        });
    }

    protected processGetOrderOnlybyId(response: AxiosResponse): Promise<GetOrderListDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderListDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderListDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order โดย OrderId
     * @return Success
     */
    getOrderbyId(orderId: string, cancelToken?: CancelToken | undefined): Promise<GetOrderListDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderbyId/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderbyId(_response);
        });
    }

    protected processGetOrderbyId(response: AxiosResponse): Promise<GetOrderListDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderListDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderListDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order
     * @return Success
     */
    getOrderData( cancelToken?: CancelToken | undefined): Promise<GetOrderListDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderData";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderData(_response);
        });
    }

    protected processGetOrderData(response: AxiosResponse): Promise<GetOrderListDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderListDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderListDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ Get เหตุผลของการยกเลิก Bill
     * @return Success
     */
    getOrderReason( cancelToken?: CancelToken | undefined): Promise<GetOrderReasonDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderReason";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderReason(_response);
        });
    }

    protected processGetOrderReason(response: AxiosResponse): Promise<GetOrderReasonDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderReasonDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderReasonDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ Get สถานะของ Order
     * @return Success
     */
    getOrderStatus( cancelToken?: CancelToken | undefined): Promise<GetOrderStatusDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderStatus(_response);
        });
    }

    protected processGetOrderStatus(response: AxiosResponse): Promise<GetOrderStatusDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderStatusDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderStatusDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Order โดย IGCode For SSS and Motor
     * @param igCode (optional) 
     * @return Success
     */
    getNewOrderByIGCode(igCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderByIGCodeDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetNewOrderByIGCode?";
        if (igCode === null)
            throw new Error("The parameter 'igCode' cannot be null.");
        else if (igCode !== undefined)
            url_ += "igCode=" + encodeURIComponent("" + igCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetNewOrderByIGCode(_response);
        });
    }

    protected processGetNewOrderByIGCode(response: AxiosResponse): Promise<GetOrderByIGCodeDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderByIGCodeDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderByIGCodeDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล Payer โดย INCode For SSS
     * @param inCode (optional) 
     * @return Success
     */
    getPayerByINCode(inCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetPayerByINCodeDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetPayerByINCode?";
        if (inCode === null)
            throw new Error("The parameter 'inCode' cannot be null.");
        else if (inCode !== undefined)
            url_ += "inCode=" + encodeURIComponent("" + inCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPayerByINCode(_response);
        });
    }

    protected processGetPayerByINCode(response: AxiosResponse): Promise<GetPayerByINCodeDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetPayerByINCodeDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPayerByINCodeDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล status โดย INCode For SSS
     * @param inCode (optional) 
     * @return Success
     */
    getStatusPremiumOrderByINCode(inCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetStatusPremiumOrderByINCodeDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetStatusPremiumOrderByINCode?";
        if (inCode === null)
            throw new Error("The parameter 'inCode' cannot be null.");
        else if (inCode !== undefined)
            url_ += "inCode=" + encodeURIComponent("" + inCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStatusPremiumOrderByINCode(_response);
        });
    }

    protected processGetStatusPremiumOrderByINCode(response: AxiosResponse): Promise<GetStatusPremiumOrderByINCodeDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetStatusPremiumOrderByINCodeDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetStatusPremiumOrderByINCodeDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ Test NewOrder
     * @param debtGroupId (optional) 
     * @return Success
     */
    createNewOrder(debtGroupId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/CreateNewOrder?";
        if (debtGroupId === null)
            throw new Error("The parameter 'debtGroupId' cannot be null.");
        else if (debtGroupId !== undefined)
            url_ += "debtGroupId=" + encodeURIComponent("" + debtGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateNewOrder(_response);
        });
    }

    protected processCreateNewOrder(response: AxiosResponse): Promise<GetOrderDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ Get Transaction
     * @param code (optional) 
     * @param codeType (optional) 
     * @return Success
     */
    getTransaction(code?: string | undefined, codeType?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetTransactionDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetTransaction?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (codeType === null)
            throw new Error("The parameter 'codeType' cannot be null.");
        else if (codeType !== undefined)
            url_ += "CodeType=" + encodeURIComponent("" + codeType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTransaction(_response);
        });
    }

    protected processGetTransaction(response: AxiosResponse): Promise<GetTransactionDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetTransactionDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetTransactionDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ Get GUid ของ Subdetail
     * @return Success
     */
    getOrderSubDetailIdByInCode(iNCode: string, cancelToken?: CancelToken | undefined): Promise<GetGuidInCodeDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderSubDetailIdByInCode/{INCode}";
        if (iNCode === undefined || iNCode === null)
            throw new Error("The parameter 'iNCode' must be defined.");
        url_ = url_.replace("{INCode}", encodeURIComponent("" + iNCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderSubDetailIdByInCode(_response);
        });
    }

    protected processGetOrderSubDetailIdByInCode(response: AxiosResponse): Promise<GetGuidInCodeDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetGuidInCodeDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetGuidInCodeDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ Get PackageDisplay ของ Subdetail
     * @return Success
     */
    getProductPackageDisplayNameByINCode(iNCode: string, cancelToken?: CancelToken | undefined): Promise<GetProductPackageDisplayDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetProductPackageDisplayNameByINCode/{INCode}";
        if (iNCode === undefined || iNCode === null)
            throw new Error("The parameter 'iNCode' must be defined.");
        url_ = url_.replace("{INCode}", encodeURIComponent("" + iNCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProductPackageDisplayNameByINCode(_response);
        });
    }

    protected processGetProductPackageDisplayNameByINCode(response: AxiosResponse): Promise<GetProductPackageDisplayDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetProductPackageDisplayDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetProductPackageDisplayDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูลของ OrderGroup
     * @param bill (optional) 
     * @return Success
     */
    getOrderGroupByBill(bill?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderGroupDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderGroupByBill?";
        if (bill === null)
            throw new Error("The parameter 'bill' cannot be null.");
        else if (bill !== undefined)
            url_ += "bill=" + encodeURIComponent("" + bill) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderGroupByBill(_response);
        });
    }

    protected processGetOrderGroupByBill(response: AxiosResponse): Promise<GetOrderGroupDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderGroupDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderGroupDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ Get UnBillApp by DebtHeaderId
     * @return Success
     */
    getUnBillAppById(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<GetUnBillAppDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetUnBillAppById?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUnBillAppById(_response);
        });
    }

    protected processGetUnBillAppById(response: AxiosResponse): Promise<GetUnBillAppDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetUnBillAppDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetUnBillAppDtoListServiceResponse>(null as any);
    }

    /**
     * สำหรับ Get un bill app with data table
     * @param billNo (optional) 
     * @param payerName (optional) 
     * @param payerIdentityCard (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param searchDetail (optional) 
     * @param orderingField (optional) 
     * @param viewPoint (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getUnBillAppFilter(billNo?: string | undefined, payerName?: string | undefined, payerIdentityCard?: string | undefined, debtGroupReferTypeId?: number | undefined, searchDetail?: string | undefined, orderingField?: string | undefined, viewPoint?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_UnBillApp_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/Order/getUnBillAppFilter?";
        if (billNo === null)
            throw new Error("The parameter 'billNo' cannot be null.");
        else if (billNo !== undefined)
            url_ += "BillNo=" + encodeURIComponent("" + billNo) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (payerIdentityCard === null)
            throw new Error("The parameter 'payerIdentityCard' cannot be null.");
        else if (payerIdentityCard !== undefined)
            url_ += "PayerIdentityCard=" + encodeURIComponent("" + payerIdentityCard) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUnBillAppFilter(_response);
        });
    }

    protected processGetUnBillAppFilter(response: AxiosResponse): Promise<Usp_UnBillApp_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_UnBillApp_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_UnBillApp_SelectResultListServiceResponse>(null as any);
    }

    /**
     * สำหรับ Get GetOrderbyBillForSplitBill
     * @return Success
     */
    getOrderbyBillForSplitBill(bill: string, cancelToken?: CancelToken | undefined): Promise<GetOrderListForSplitBillDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderbyBillForSplitBill/{bill}";
        if (bill === undefined || bill === null)
            throw new Error("The parameter 'bill' must be defined.");
        url_ = url_.replace("{bill}", encodeURIComponent("" + bill));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderbyBillForSplitBill(_response);
        });
    }

    protected processGetOrderbyBillForSplitBill(response: AxiosResponse): Promise<GetOrderListForSplitBillDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderListForSplitBillDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderListForSplitBillDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ Get SplitBill
     * @param body (optional) 
     * @return Success
     */
    splitBill(body?: GetSplitBilPayloadlDto | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/SplitBill";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSplitBill(_response);
        });
    }

    protected processSplitBill(response: AxiosResponse): Promise<GetOrderDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderDtoServiceResponse>(null as any);
    }

    /**
     * สำหรับ Split Bill New-App DataTable
     * @param fullTextId (optional) 
     * @param fullText (optional) 
     * @param transactionDatetimeBegin (optional) 
     * @param transactionDatetimeEnd (optional) 
     * @param payablePeriodToBegin (optional) 
     * @param payablePeriodToEnd (optional) 
     * @param productTypeId (optional) 
     * @param productId (optional) 
     * @param statusId (optional) 
     * @param cancelCauseId (optional) 
     * @param defaultLoader (optional) 
     * @param onlyNoApp (optional) 
     * @param viewPoint (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderListTableincludeDetailForSplitBill(fullTextId?: number | undefined, fullText?: string | undefined, transactionDatetimeBegin?: dayjs.Dayjs | undefined, transactionDatetimeEnd?: dayjs.Dayjs | undefined, payablePeriodToBegin?: dayjs.Dayjs | undefined, payablePeriodToEnd?: dayjs.Dayjs | undefined, productTypeId?: string | undefined, productId?: string | undefined, statusId?: string | undefined, cancelCauseId?: string | undefined, defaultLoader?: boolean | undefined, onlyNoApp?: boolean | undefined, viewPoint?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderListTableIncludeDetailDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetOrderListTableincludeDetailForSplitBill/filter?";
        if (fullTextId === null)
            throw new Error("The parameter 'fullTextId' cannot be null.");
        else if (fullTextId !== undefined)
            url_ += "FullTextId=" + encodeURIComponent("" + fullTextId) + "&";
        if (fullText === null)
            throw new Error("The parameter 'fullText' cannot be null.");
        else if (fullText !== undefined)
            url_ += "FullText=" + encodeURIComponent("" + fullText) + "&";
        if (transactionDatetimeBegin === null)
            throw new Error("The parameter 'transactionDatetimeBegin' cannot be null.");
        else if (transactionDatetimeBegin !== undefined)
            url_ += "TransactionDatetimeBegin=" + encodeURIComponent(transactionDatetimeBegin ? "" + transactionDatetimeBegin.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeEnd === null)
            throw new Error("The parameter 'transactionDatetimeEnd' cannot be null.");
        else if (transactionDatetimeEnd !== undefined)
            url_ += "TransactionDatetimeEnd=" + encodeURIComponent(transactionDatetimeEnd ? "" + transactionDatetimeEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToBegin === null)
            throw new Error("The parameter 'payablePeriodToBegin' cannot be null.");
        else if (payablePeriodToBegin !== undefined)
            url_ += "PayablePeriodToBegin=" + encodeURIComponent(payablePeriodToBegin ? "" + payablePeriodToBegin.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToEnd === null)
            throw new Error("The parameter 'payablePeriodToEnd' cannot be null.");
        else if (payablePeriodToEnd !== undefined)
            url_ += "PayablePeriodToEnd=" + encodeURIComponent(payablePeriodToEnd ? "" + payablePeriodToEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (statusId === null)
            throw new Error("The parameter 'statusId' cannot be null.");
        else if (statusId !== undefined)
            url_ += "StatusId=" + encodeURIComponent("" + statusId) + "&";
        if (cancelCauseId === null)
            throw new Error("The parameter 'cancelCauseId' cannot be null.");
        else if (cancelCauseId !== undefined)
            url_ += "CancelCauseId=" + encodeURIComponent("" + cancelCauseId) + "&";
        if (defaultLoader === null)
            throw new Error("The parameter 'defaultLoader' cannot be null.");
        else if (defaultLoader !== undefined)
            url_ += "DefaultLoader=" + encodeURIComponent("" + defaultLoader) + "&";
        if (onlyNoApp === null)
            throw new Error("The parameter 'onlyNoApp' cannot be null.");
        else if (onlyNoApp !== undefined)
            url_ += "OnlyNoApp=" + encodeURIComponent("" + onlyNoApp) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderListTableincludeDetailForSplitBill(_response);
        });
    }

    protected processGetOrderListTableincludeDetailForSplitBill(response: AxiosResponse): Promise<GetOrderListTableIncludeDetailDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderListTableIncludeDetailDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderListTableIncludeDetailDtoListServiceResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderSubDetailsFilter(id?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderListTableIncludeSubDetailDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/Order/GetOrderSubDetailsFilter?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderSubDetailsFilter(_response);
        });
    }

    protected processGetOrderSubDetailsFilter(response: AxiosResponse): Promise<GetOrderListTableIncludeSubDetailDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderListTableIncludeSubDetailDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderListTableIncludeSubDetailDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ 1.2 DataTable
     * @param fullTextId (optional) 
     * @param fullText (optional) 
     * @param createdDateBegin (optional) 
     * @param createdDateEnd (optional) 
     * @param transactionDatetimeBegin (optional) 
     * @param transactionDatetimeEnd (optional) 
     * @param payablePeriodToBegin (optional) 
     * @param payablePeriodToEnd (optional) 
     * @param productTypeId (optional) 
     * @param productId (optional) 
     * @param checkoutProcessId (optional) 
     * @param paymentChannelId (optional) 
     * @param statusId (optional) 
     * @param cancelCauseId (optional) 
     * @param defaultLoader (optional) 
     * @param onlyNoApp (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getOrderListTableincludeDetail2(fullTextId?: number | undefined, fullText?: string | undefined, createdDateBegin?: dayjs.Dayjs | undefined, createdDateEnd?: dayjs.Dayjs | undefined, transactionDatetimeBegin?: dayjs.Dayjs | undefined, transactionDatetimeEnd?: dayjs.Dayjs | undefined, payablePeriodToBegin?: dayjs.Dayjs | undefined, payablePeriodToEnd?: dayjs.Dayjs | undefined, productTypeId?: string | undefined, productId?: string | undefined, checkoutProcessId?: string | undefined, paymentChannelId?: string | undefined, statusId?: string | undefined, cancelCauseId?: string | undefined, defaultLoader?: boolean | undefined, onlyNoApp?: boolean | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderListTableIncludeDetailDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/Order/GetOrderListTableincludeDetail2/filter?";
        if (fullTextId === null)
            throw new Error("The parameter 'fullTextId' cannot be null.");
        else if (fullTextId !== undefined)
            url_ += "FullTextId=" + encodeURIComponent("" + fullTextId) + "&";
        if (fullText === null)
            throw new Error("The parameter 'fullText' cannot be null.");
        else if (fullText !== undefined)
            url_ += "FullText=" + encodeURIComponent("" + fullText) + "&";
        if (createdDateBegin === null)
            throw new Error("The parameter 'createdDateBegin' cannot be null.");
        else if (createdDateBegin !== undefined)
            url_ += "CreatedDateBegin=" + encodeURIComponent(createdDateBegin ? "" + createdDateBegin.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateEnd === null)
            throw new Error("The parameter 'createdDateEnd' cannot be null.");
        else if (createdDateEnd !== undefined)
            url_ += "CreatedDateEnd=" + encodeURIComponent(createdDateEnd ? "" + createdDateEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeBegin === null)
            throw new Error("The parameter 'transactionDatetimeBegin' cannot be null.");
        else if (transactionDatetimeBegin !== undefined)
            url_ += "TransactionDatetimeBegin=" + encodeURIComponent(transactionDatetimeBegin ? "" + transactionDatetimeBegin.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeEnd === null)
            throw new Error("The parameter 'transactionDatetimeEnd' cannot be null.");
        else if (transactionDatetimeEnd !== undefined)
            url_ += "TransactionDatetimeEnd=" + encodeURIComponent(transactionDatetimeEnd ? "" + transactionDatetimeEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToBegin === null)
            throw new Error("The parameter 'payablePeriodToBegin' cannot be null.");
        else if (payablePeriodToBegin !== undefined)
            url_ += "PayablePeriodToBegin=" + encodeURIComponent(payablePeriodToBegin ? "" + payablePeriodToBegin.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToEnd === null)
            throw new Error("The parameter 'payablePeriodToEnd' cannot be null.");
        else if (payablePeriodToEnd !== undefined)
            url_ += "PayablePeriodToEnd=" + encodeURIComponent(payablePeriodToEnd ? "" + payablePeriodToEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (checkoutProcessId === null)
            throw new Error("The parameter 'checkoutProcessId' cannot be null.");
        else if (checkoutProcessId !== undefined)
            url_ += "CheckoutProcessId=" + encodeURIComponent("" + checkoutProcessId) + "&";
        if (paymentChannelId === null)
            throw new Error("The parameter 'paymentChannelId' cannot be null.");
        else if (paymentChannelId !== undefined)
            url_ += "PaymentChannelId=" + encodeURIComponent("" + paymentChannelId) + "&";
        if (statusId === null)
            throw new Error("The parameter 'statusId' cannot be null.");
        else if (statusId !== undefined)
            url_ += "StatusId=" + encodeURIComponent("" + statusId) + "&";
        if (cancelCauseId === null)
            throw new Error("The parameter 'cancelCauseId' cannot be null.");
        else if (cancelCauseId !== undefined)
            url_ += "CancelCauseId=" + encodeURIComponent("" + cancelCauseId) + "&";
        if (defaultLoader === null)
            throw new Error("The parameter 'defaultLoader' cannot be null.");
        else if (defaultLoader !== undefined)
            url_ += "DefaultLoader=" + encodeURIComponent("" + defaultLoader) + "&";
        if (onlyNoApp === null)
            throw new Error("The parameter 'onlyNoApp' cannot be null.");
        else if (onlyNoApp !== undefined)
            url_ += "OnlyNoApp=" + encodeURIComponent("" + onlyNoApp) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderListTableincludeDetail2(_response);
        });
    }

    protected processGetOrderListTableincludeDetail2(response: AxiosResponse): Promise<GetOrderListTableIncludeDetailDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderListTableIncludeDetailDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderListTableIncludeDetailDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ Get Bill by GUID
     * @return Success
     */
    getBillByGUID(personGuid: string, cancelToken?: CancelToken | undefined): Promise<GetBillByGUIDDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Order/getbillbyguid?";
        if (personGuid === undefined || personGuid === null)
            throw new Error("The parameter 'personGuid' must be defined and cannot be null.");
        else
            url_ += "PersonGuid=" + encodeURIComponent("" + personGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBillByGUID(_response);
        });
    }

    protected processGetBillByGUID(response: AxiosResponse): Promise<GetBillByGUIDDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetBillByGUIDDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBillByGUIDDtoListServiceResponse>(null as any);
    }

    /**
     * GET SetUpDebtNewApp
     * @param id (optional) 
     * @param period (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    setUpDebtNewApp(id?: string | undefined, period?: dayjs.Dayjs | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<SetUpDebtNewAppDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/Order/setupdebtnewapp?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetUpDebtNewApp(_response);
        });
    }

    protected processSetUpDebtNewApp(response: AxiosResponse): Promise<SetUpDebtNewAppDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SetUpDebtNewAppDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SetUpDebtNewAppDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * POST UpsertSetUpDebtNewApp
     * @param id (optional) 
     * @param period (optional) 
     * @param payablePeriodFrom (optional) 
     * @param payablePeriodTo (optional) 
     * @return Success
     */
    upsertSetUpDebtNewApp(id?: string | undefined, period?: dayjs.Dayjs | undefined, payablePeriodFrom?: dayjs.Dayjs | undefined, payablePeriodTo?: dayjs.Dayjs | undefined, cancelToken?: CancelToken | undefined): Promise<UpsertSetUpDebtNewAppDto_ResponseServiceResponse> {
        let url_ = this.baseUrl + "/Order/upsertsetupdebtnewapp?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodFrom === null)
            throw new Error("The parameter 'payablePeriodFrom' cannot be null.");
        else if (payablePeriodFrom !== undefined)
            url_ += "PayablePeriodFrom=" + encodeURIComponent(payablePeriodFrom ? "" + payablePeriodFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodTo === null)
            throw new Error("The parameter 'payablePeriodTo' cannot be null.");
        else if (payablePeriodTo !== undefined)
            url_ += "PayablePeriodTo=" + encodeURIComponent(payablePeriodTo ? "" + payablePeriodTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpsertSetUpDebtNewApp(_response);
        });
    }

    protected processUpsertSetUpDebtNewApp(response: AxiosResponse): Promise<UpsertSetUpDebtNewAppDto_ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<UpsertSetUpDebtNewAppDto_ResponseServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpsertSetUpDebtNewAppDto_ResponseServiceResponse>(null as any);
    }

    /**
     * สำหรับ Get Guid OrderSubdetail By InCode
     * @return Success
     */
    getGUIDOrderSubDetailByInCode(inCode: string, cancelToken?: CancelToken | undefined): Promise<GetGUIDOrderSubDetailByInCodeResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/Order/GetGUIDOrderSubDetailByInCode?";
        if (inCode === undefined || inCode === null)
            throw new Error("The parameter 'inCode' must be defined and cannot be null.");
        else
            url_ += "inCode=" + encodeURIComponent("" + inCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGUIDOrderSubDetailByInCode(_response);
        });
    }

    protected processGetGUIDOrderSubDetailByInCode(response: AxiosResponse): Promise<GetGUIDOrderSubDetailByInCodeResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetGUIDOrderSubDetailByInCodeResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetGUIDOrderSubDetailByInCodeResponseDtoServiceResponse>(null as any);
    }
}

export class OrderV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrderV2(body?: CreateOrderDto | undefined, cancelToken?: CancelToken | undefined): Promise<OrderResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/orderv2/order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrderV2(_response);
        });
    }

    protected processCreateOrderV2(response: AxiosResponse): Promise<OrderResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<OrderResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reInvoiceOrderV2(orderId: string, body?: CreateOrderDto | undefined, cancelToken?: CancelToken | undefined): Promise<OrderResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/orderv2/order/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReInvoiceOrderV2(_response);
        });
    }

    protected processReInvoiceOrderV2(response: AxiosResponse): Promise<OrderResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<OrderResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param orderSubDetailId (optional) 
     * @param inCode (optional) 
     * @return Success
     */
    getMotorDetail(orderSubDetailId?: string | undefined, inCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<MotorDetailResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/orderv2/motordetail?";
        if (orderSubDetailId === null)
            throw new Error("The parameter 'orderSubDetailId' cannot be null.");
        else if (orderSubDetailId !== undefined)
            url_ += "OrderSubDetailId=" + encodeURIComponent("" + orderSubDetailId) + "&";
        if (inCode === null)
            throw new Error("The parameter 'inCode' cannot be null.");
        else if (inCode !== undefined)
            url_ += "InCode=" + encodeURIComponent("" + inCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMotorDetail(_response);
        });
    }

    protected processGetMotorDetail(response: AxiosResponse): Promise<MotorDetailResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<MotorDetailResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MotorDetailResponseDtoServiceResponse>(null as any);
    }

    /**
     * @return Success
     */
    getDcrDateByOrderId(orderid: string, cancelToken?: CancelToken | undefined): Promise<GetDcrDateByOrderIdDtoListServiceResponse> {
        let url_ = this.baseUrl + "/orderv2/dct/date/{orderid}";
        if (orderid === undefined || orderid === null)
            throw new Error("The parameter 'orderid' must be defined.");
        url_ = url_.replace("{orderid}", encodeURIComponent("" + orderid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDcrDateByOrderId(_response);
        });
    }

    protected processGetDcrDateByOrderId(response: AxiosResponse): Promise<GetDcrDateByOrderIdDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDcrDateByOrderIdDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDcrDateByOrderIdDtoListServiceResponse>(null as any);
    }

    /**
     * @return Success
     */
    getBillingStatusInquiry(applicationcode: string, cancelToken?: CancelToken | undefined): Promise<GetBillingStatusInquiryDtoServiceResponse> {
        let url_ = this.baseUrl + "/orderv2/billing/status/inquiry/{applicationcode}";
        if (applicationcode === undefined || applicationcode === null)
            throw new Error("The parameter 'applicationcode' must be defined.");
        url_ = url_.replace("{applicationcode}", encodeURIComponent("" + applicationcode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBillingStatusInquiry(_response);
        });
    }

    protected processGetBillingStatusInquiry(response: AxiosResponse): Promise<GetBillingStatusInquiryDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetBillingStatusInquiryDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBillingStatusInquiryDtoServiceResponse>(null as any);
    }
}

export class PremiumOrderPAClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrderPA(body?: CreateOrderPARequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<CreateOrderPAResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/premiumorderpa/createorderpa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrderPA(_response);
        });
    }

    protected processCreateOrderPA(response: AxiosResponse): Promise<CreateOrderPAResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<CreateOrderPAResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateOrderPAResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param orderStatusId (optional) 
     * @param checkoutProcessIdList (optional) 
     * @param bill (optional) 
     * @param applicationCode (optional) 
     * @param schoolName (optional) 
     * @param branchId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param sourceTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getMonitorBill(schoolYear: string, orderStatusId?: number | undefined, checkoutProcessIdList?: string | undefined, bill?: string | undefined, applicationCode?: string | undefined, schoolName?: string | undefined, branchId?: number | undefined, debtGroupReferTypeId?: number | undefined, sourceTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<MonitorBillsResponeDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/premiumorderpa/monitorbill?";
        if (schoolYear === undefined || schoolYear === null)
            throw new Error("The parameter 'schoolYear' must be defined and cannot be null.");
        else
            url_ += "SchoolYear=" + encodeURIComponent("" + schoolYear) + "&";
        if (orderStatusId === null)
            throw new Error("The parameter 'orderStatusId' cannot be null.");
        else if (orderStatusId !== undefined)
            url_ += "OrderStatusId=" + encodeURIComponent("" + orderStatusId) + "&";
        if (checkoutProcessIdList === null)
            throw new Error("The parameter 'checkoutProcessIdList' cannot be null.");
        else if (checkoutProcessIdList !== undefined)
            url_ += "CheckoutProcessIdList=" + encodeURIComponent("" + checkoutProcessIdList) + "&";
        if (bill === null)
            throw new Error("The parameter 'bill' cannot be null.");
        else if (bill !== undefined)
            url_ += "Bill=" + encodeURIComponent("" + bill) + "&";
        if (applicationCode === null)
            throw new Error("The parameter 'applicationCode' cannot be null.");
        else if (applicationCode !== undefined)
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (schoolName === null)
            throw new Error("The parameter 'schoolName' cannot be null.");
        else if (schoolName !== undefined)
            url_ += "SchoolName=" + encodeURIComponent("" + schoolName) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (sourceTypeId === null)
            throw new Error("The parameter 'sourceTypeId' cannot be null.");
        else if (sourceTypeId !== undefined)
            url_ += "SourceTypeId=" + encodeURIComponent("" + sourceTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMonitorBill(_response);
        });
    }

    protected processGetMonitorBill(response: AxiosResponse): Promise<MonitorBillsResponeDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<MonitorBillsResponeDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MonitorBillsResponeDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param orderHeaderId (optional) 
     * @param bill (optional) 
     * @param schoolYear (optional) 
     * @return Success
     */
    getBillPayment(orderHeaderId?: string | undefined, bill?: string | undefined, schoolYear?: string | undefined, cancelToken?: CancelToken | undefined): Promise<BillPaymentResponeDtoServiceResponse> {
        let url_ = this.baseUrl + "/premiumorderpa/billpayment?";
        if (orderHeaderId === null)
            throw new Error("The parameter 'orderHeaderId' cannot be null.");
        else if (orderHeaderId !== undefined)
            url_ += "OrderHeaderId=" + encodeURIComponent("" + orderHeaderId) + "&";
        if (bill === null)
            throw new Error("The parameter 'bill' cannot be null.");
        else if (bill !== undefined)
            url_ += "Bill=" + encodeURIComponent("" + bill) + "&";
        if (schoolYear === null)
            throw new Error("The parameter 'schoolYear' cannot be null.");
        else if (schoolYear !== undefined)
            url_ += "SchoolYear=" + encodeURIComponent("" + schoolYear) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBillPayment(_response);
        });
    }

    protected processGetBillPayment(response: AxiosResponse): Promise<BillPaymentResponeDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<BillPaymentResponeDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillPaymentResponeDtoServiceResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateApplicationCode(body?: UpdateApplicationCodeRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<UpdateApplicationCodeResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/premiumorderpa/updateapplicationcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateApplicationCode(_response);
        });
    }

    protected processUpdateApplicationCode(response: AxiosResponse): Promise<UpdateApplicationCodeResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<UpdateApplicationCodeResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateApplicationCodeResponseDtoServiceResponse>(null as any);
    }
}

export class PremiumOrderPAReportClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param branchId (optional) 
     * @param searchDetail (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getAppEditInBillReports(createDateFrom: dayjs.Dayjs, createDateTo: dayjs.Dayjs, searchTypeId: number, branchId?: number | undefined, searchDetail?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_ReportChangeApplicationLog_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/premiumorderpareport/appeditinbillreports?";
        if (createDateFrom === undefined || createDateFrom === null)
            throw new Error("The parameter 'createDateFrom' must be defined and cannot be null.");
        else
            url_ += "CreateDateFrom=" + encodeURIComponent(createDateFrom ? "" + createDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createDateTo === undefined || createDateTo === null)
            throw new Error("The parameter 'createDateTo' must be defined and cannot be null.");
        else
            url_ += "CreateDateTo=" + encodeURIComponent(createDateTo ? "" + createDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchTypeId === undefined || searchTypeId === null)
            throw new Error("The parameter 'searchTypeId' must be defined and cannot be null.");
        else
            url_ += "SearchTypeId=" + encodeURIComponent("" + searchTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAppEditInBillReports(_response);
        });
    }

    protected processGetAppEditInBillReports(response: AxiosResponse): Promise<Usp_ReportChangeApplicationLog_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_ReportChangeApplicationLog_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_ReportChangeApplicationLog_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param branchId (optional) 
     * @param searchDetail (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    downloadAppEditInBillReports(createDateFrom: dayjs.Dayjs, createDateTo: dayjs.Dayjs, searchTypeId: number, branchId?: number | undefined, searchDetail?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/premiumorderpareport/downloadappeditinbillreports?";
        if (createDateFrom === undefined || createDateFrom === null)
            throw new Error("The parameter 'createDateFrom' must be defined and cannot be null.");
        else
            url_ += "CreateDateFrom=" + encodeURIComponent(createDateFrom ? "" + createDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createDateTo === undefined || createDateTo === null)
            throw new Error("The parameter 'createDateTo' must be defined and cannot be null.");
        else
            url_ += "CreateDateTo=" + encodeURIComponent(createDateTo ? "" + createDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchTypeId === undefined || searchTypeId === null)
            throw new Error("The parameter 'searchTypeId' must be defined and cannot be null.");
        else
            url_ += "SearchTypeId=" + encodeURIComponent("" + searchTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadAppEditInBillReports(_response);
        });
    }

    protected processDownloadAppEditInBillReports(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchId (optional) 
     * @param searchDetail (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getPhoneNoEditReports(createDateFrom: dayjs.Dayjs, createDateTo: dayjs.Dayjs, searchTypeId: number, branchId?: number | undefined, searchDetail?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_ReportChangePhoneNumber_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/premiumorderpareport/phonenoeditreports?";
        if (createDateFrom === undefined || createDateFrom === null)
            throw new Error("The parameter 'createDateFrom' must be defined and cannot be null.");
        else
            url_ += "CreateDateFrom=" + encodeURIComponent(createDateFrom ? "" + createDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createDateTo === undefined || createDateTo === null)
            throw new Error("The parameter 'createDateTo' must be defined and cannot be null.");
        else
            url_ += "CreateDateTo=" + encodeURIComponent(createDateTo ? "" + createDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchTypeId === undefined || searchTypeId === null)
            throw new Error("The parameter 'searchTypeId' must be defined and cannot be null.");
        else
            url_ += "SearchTypeId=" + encodeURIComponent("" + searchTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPhoneNoEditReports(_response);
        });
    }

    protected processGetPhoneNoEditReports(response: AxiosResponse): Promise<Usp_ReportChangePhoneNumber_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_ReportChangePhoneNumber_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_ReportChangePhoneNumber_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param branchId (optional) 
     * @param searchDetail (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    downloadPhoneNoEditReports(createDateFrom: dayjs.Dayjs, createDateTo: dayjs.Dayjs, searchTypeId: number, branchId?: number | undefined, searchDetail?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/premiumorderpareport/downloadphonenoeditreports?";
        if (createDateFrom === undefined || createDateFrom === null)
            throw new Error("The parameter 'createDateFrom' must be defined and cannot be null.");
        else
            url_ += "CreateDateFrom=" + encodeURIComponent(createDateFrom ? "" + createDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createDateTo === undefined || createDateTo === null)
            throw new Error("The parameter 'createDateTo' must be defined and cannot be null.");
        else
            url_ += "CreateDateTo=" + encodeURIComponent(createDateTo ? "" + createDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchTypeId === undefined || searchTypeId === null)
            throw new Error("The parameter 'searchTypeId' must be defined and cannot be null.");
        else
            url_ += "SearchTypeId=" + encodeURIComponent("" + searchTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadPhoneNoEditReports(_response);
        });
    }

    protected processDownloadPhoneNoEditReports(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PremiumOrderReportClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-4 รายงาน New App แยกบิล
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param period (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportUnBillApp(searchIndex?: string | undefined, searchText?: string | undefined, period?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, saleEmployeeCode?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/premiumordereport/reportunbillapp/filter?";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportUnBillApp(_response);
        });
    }

    protected processGetReportUnBillApp(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-4 รายงาน New App แยกบิล
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param period (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param saleEmployeeCode (optional) 
     * @return Success
     */
    downloadReportUnBillApp(searchIndex?: string | undefined, searchText?: string | undefined, period?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, saleEmployeeCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/premiumordereport/download/reportunbillapp?";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportUnBillApp(_response);
        });
    }

    protected processDownloadReportUnBillApp(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param checkoutProcessId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param branchId (optional) 
     * @param ascendingOrder (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param orderingField (optional) 
     * @param oderType (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportDebtWithoutNewApp(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, checkoutProcessId?: string | undefined, saleEmployeeCode?: string | undefined, branchId?: string | undefined, ascendingOrder?: boolean | undefined, searchIndex?: string | undefined, searchText?: string | undefined, orderingField?: string | undefined, oderType?: string | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/premiumordereport/reportdebtwithoutnewapp/filter?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (checkoutProcessId === null)
            throw new Error("The parameter 'checkoutProcessId' cannot be null.");
        else if (checkoutProcessId !== undefined)
            url_ += "CheckoutProcessId=" + encodeURIComponent("" + checkoutProcessId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (oderType === null)
            throw new Error("The parameter 'oderType' cannot be null.");
        else if (oderType !== undefined)
            url_ += "OderType=" + encodeURIComponent("" + oderType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtWithoutNewApp(_response);
        });
    }

    protected processGetReportDebtWithoutNewApp(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param checkoutProcessId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param branchId (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @return Success
     */
    downloadReportDebtWithoutNewApp(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, checkoutProcessId?: string | undefined, saleEmployeeCode?: string | undefined, branchId?: string | undefined, searchIndex?: string | undefined, searchText?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/premiumordereport/download/reportdebtwithoutnewapp?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (checkoutProcessId === null)
            throw new Error("The parameter 'checkoutProcessId' cannot be null.");
        else if (checkoutProcessId !== undefined)
            url_ += "CheckoutProcessId=" + encodeURIComponent("" + checkoutProcessId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportDebtWithoutNewApp(_response);
        });
    }

    protected processDownloadReportDebtWithoutNewApp(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PremiumOrderReportV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-4 รายงาน New App แยกบิล
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param period (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportUnBillAppV2(searchIndex?: string | undefined, searchText?: string | undefined, period?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, saleEmployeeCode?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportUnbillDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/premiumordereport/reportunbillapp/filter?";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportUnBillAppV2(_response);
        });
    }

    protected processGetReportUnBillAppV2(response: AxiosResponse): Promise<GetReportUnbillDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportUnbillDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportUnbillDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-4 รายงาน New App แยกบิล
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param period (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param saleEmployeeCode (optional) 
     * @return Success
     */
    downloadReportUnBillAppV2(searchIndex?: string | undefined, searchText?: string | undefined, period?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, saleEmployeeCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/premiumordereport/download/reportunbillapp?";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportUnBillAppV2(_response);
        });
    }

    protected processDownloadReportUnBillAppV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param checkoutProcessId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param branchId (optional) 
     * @param ascendingOrder (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param orderingField (optional) 
     * @param oderType (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportDebtWithoutNewAppV2(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, checkoutProcessId?: string | undefined, saleEmployeeCode?: string | undefined, branchId?: string | undefined, ascendingOrder?: boolean | undefined, searchIndex?: string | undefined, searchText?: string | undefined, orderingField?: string | undefined, oderType?: string | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportDebtWithoutNewAppDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/premiumordereport/reportdebtwithoutnewapp/filter?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (checkoutProcessId === null)
            throw new Error("The parameter 'checkoutProcessId' cannot be null.");
        else if (checkoutProcessId !== undefined)
            url_ += "CheckoutProcessId=" + encodeURIComponent("" + checkoutProcessId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (oderType === null)
            throw new Error("The parameter 'oderType' cannot be null.");
        else if (oderType !== undefined)
            url_ += "OderType=" + encodeURIComponent("" + oderType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtWithoutNewAppV2(_response);
        });
    }

    protected processGetReportDebtWithoutNewAppV2(response: AxiosResponse): Promise<GetReportDebtWithoutNewAppDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportDebtWithoutNewAppDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportDebtWithoutNewAppDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param checkoutProcessId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param branchId (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @return Success
     */
    downloadReportDebtWithoutNewAppV2(createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, checkoutProcessId?: string | undefined, saleEmployeeCode?: string | undefined, branchId?: string | undefined, searchIndex?: string | undefined, searchText?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/premiumordereport/download/reportdebtwithoutnewapp?";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (checkoutProcessId === null)
            throw new Error("The parameter 'checkoutProcessId' cannot be null.");
        else if (checkoutProcessId !== undefined)
            url_ += "CheckoutProcessId=" + encodeURIComponent("" + checkoutProcessId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportDebtWithoutNewAppV2(_response);
        });
    }

    protected processDownloadReportDebtWithoutNewAppV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    downloadReportBankPaymentWait(body?: ReportBankPaymentWaitRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/premiumordereport/download/reportbankpaymentwait";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportBankPaymentWait(_response);
        });
    }

    protected processDownloadReportBankPaymentWait(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    reportBankPayment(period: dayjs.Dayjs, orderStatusId?: number | undefined, branchId?: number | undefined, userId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/premiumordereport/download/bank/payment?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (orderStatusId === null)
            throw new Error("The parameter 'orderStatusId' cannot be null.");
        else if (orderStatusId !== undefined)
            url_ += "OrderStatusId=" + encodeURIComponent("" + orderStatusId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportBankPayment(_response);
        });
    }

    protected processReportBankPayment(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Not Found - \u0e44\u0e21\u0e48\u0e1e\u0e1a\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PremiumOrderSMIClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrderSMI(body?: CreateOrderSMIRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<CreateOrderSMIResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/premiumordersmi/createordersmi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrderSMI(_response);
        });
    }

    protected processCreateOrderSMI(response: AxiosResponse): Promise<CreateOrderSMIResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<CreateOrderSMIResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateOrderSMIResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param statusId (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return Success
     */
    getOrderSMI(schoolYear: number, createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, statusId?: number | undefined, page?: number | undefined, recordsPerPage?: number | undefined, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetOrderSMIResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/premiumordersmi/ordersmi?";
        if (schoolYear === undefined || schoolYear === null)
            throw new Error("The parameter 'schoolYear' must be defined and cannot be null.");
        else
            url_ += "SchoolYear=" + encodeURIComponent("" + schoolYear) + "&";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (statusId === null)
            throw new Error("The parameter 'statusId' cannot be null.");
        else if (statusId !== undefined)
            url_ += "StatusId=" + encodeURIComponent("" + statusId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderSMI(_response);
        });
    }

    protected processGetOrderSMI(response: AxiosResponse): Promise<GetOrderSMIResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetOrderSMIResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrderSMIResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param createdDateFrom (optional) 
     * @param createdDateTo (optional) 
     * @param statusId (optional) 
     * @return Success
     */
    reportOrderSMI(schoolYear: number, createdDateFrom?: dayjs.Dayjs | undefined, createdDateTo?: dayjs.Dayjs | undefined, statusId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/premiumordersmi/report/ordersmi?";
        if (schoolYear === undefined || schoolYear === null)
            throw new Error("The parameter 'schoolYear' must be defined and cannot be null.");
        else
            url_ += "SchoolYear=" + encodeURIComponent("" + schoolYear) + "&";
        if (createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' cannot be null.");
        else if (createdDateFrom !== undefined)
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' cannot be null.");
        else if (createdDateTo !== undefined)
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (statusId === null)
            throw new Error("The parameter 'statusId' cannot be null.");
        else if (statusId !== undefined)
            url_ += "StatusId=" + encodeURIComponent("" + statusId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportOrderSMI(_response);
        });
    }

    protected processReportOrderSMI(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getOrderHistoryHeader(billNo: string, cancelToken?: CancelToken | undefined): Promise<Usp_OrderHistoryHeader_SelectResultServiceResponse> {
        let url_ = this.baseUrl + "/premiumordersmi/orderhistoryheader/{billNo}";
        if (billNo === undefined || billNo === null)
            throw new Error("The parameter 'billNo' must be defined.");
        url_ = url_.replace("{billNo}", encodeURIComponent("" + billNo));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderHistoryHeader(_response);
        });
    }

    protected processGetOrderHistoryHeader(response: AxiosResponse): Promise<Usp_OrderHistoryHeader_SelectResultServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_OrderHistoryHeader_SelectResultServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_OrderHistoryHeader_SelectResultServiceResponse>(null as any);
    }
}

export class QuartzClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * POST TriggerBankPaymentDuedateHostedService
     * @return Success
     */
    triggerBankPaymentDuedateHostedService( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/quartzcontroller/triggerbankpaymentduedatehostedservice";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTriggerBankPaymentDuedateHostedService(_response);
        });
    }

    protected processTriggerBankPaymentDuedateHostedService(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface AddCancelOrderByIdDto {
    id?: string;
    cancelId?: number | undefined;
    cancelDetail?: string | undefined;
    userId?: number | undefined;
    tempOrderId?: string | undefined;
}

export interface AddCancelOrderDto {
    billNumber?: string | undefined;
    cancelId?: number | undefined;
    cancelDetail?: string | undefined;
}

export interface AddOrderDetailDto {
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName?: string | undefined;
    productPackageId?: number | undefined;
    productPackageName?: string | undefined;
    premium?: number | undefined;
    premiumSum?: number | undefined;
    premiumPoint?: number | undefined;
    premiumDiscount?: number | undefined;
    premiumNet?: number | undefined;
    periodTypeId?: number | undefined;
    customerName?: string | undefined;
    dcrDate?: dayjs.Dayjs | undefined;
    birthDate?: dayjs.Dayjs | undefined;
    genderId?: number | undefined;
    ageStartInsurance?: string | undefined;
    igCode?: string | undefined;
    orderSubDetails?: OrderSubDetail[] | undefined;
}

export interface AddOrderDto {
    personTypeId?: number;
    personGuid?: string | undefined;
    personId?: number | undefined;
    cardDetail: string;
    cardTypeId: number;
    titleId: number;
    titleName: string;
    firstName: string;
    lastName: string;
    phoneNumber: string;
    addressDetail1?: string | undefined;
    addressDetail2?: string | undefined;
    postCode?: string | undefined;
    checkoutProcessId?: number | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    slaCount?: number | undefined;
    cancelCauseId?: number | undefined;
    statusId?: number | undefined;
    quantity?: number | undefined;
    amount?: number | undefined;
    bankId?: number | undefined;
    bankAccountName?: string | undefined;
    bankAccountNo?: string | undefined;
    isSendToPremium?: number | undefined;
    refPremium?: string | undefined;
    crmLeadId?: string | undefined;
    ocrId?: string | undefined;
    orderPlan?: AddOrderDetailDto[] | undefined;
}

export interface BillPaymentResponeDto {
    debtHeaderId?: string | undefined;
    bill?: string | undefined;
    applicationCode?: string | undefined;
    fullAddress?: string | undefined;
    schoolName?: string | undefined;
    schoolYear?: string | undefined;
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName?: string | undefined;
    productPackageID?: number | undefined;
    productPackageName?: string | undefined;
    contactName?: string | undefined;
    contactPhoneNo?: string | undefined;
    statusId?: number | undefined;
    statusName?: string | undefined;
    amount?: number | undefined;
    checkoutProcessId?: number | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
}

export interface BillPaymentResponeDtoServiceResponse {
    data?: BillPaymentResponeDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface CheckoutProcessDto {
    checkoutProcessId?: number | undefined;
    checkoutProcessName?: string | undefined;
}

export interface CheckoutProcessDtoListServiceResponse {
    data?: CheckoutProcessDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface CreateBankDueDateDto {
    period?: dayjs.Dayjs;
    periodFrom?: dayjs.Dayjs;
    periodTo?: dayjs.Dayjs;
}

export interface CreateOrderDto {
    personTypeId: number;
    personGuid?: string | undefined;
    personId?: number | undefined;
    cardTypeId: number;
    cardDetail: string;
    titleId: number;
    titleName: string;
    firstName: string;
    lastName: string;
    phoneNumber: string;
    addressDetail1?: string | undefined;
    addressDetail2?: string | undefined;
    postCode?: string | undefined;
    checkoutProcessId: number;
    bankId?: number | undefined;
    bankAccountName?: string | undefined;
    bankAccountNo?: string | undefined;
    crmLeadId?: string | undefined;
    ocrId?: string | undefined;
    contactName?: string | undefined;
    createOrderPackages?: CreateOrderPackage[] | undefined;
}

export interface CreateOrderPackage {
    productPackageDisplayId: number;
    productPackageDisplayName: string;
    productPackageId: number;
    productPackageName: string;
    premium: number;
    periodTypeId: number;
    customerName: string;
    dcrDate?: dayjs.Dayjs | undefined;
    startCoverDate?: dayjs.Dayjs | undefined;
    birthDate?: dayjs.Dayjs | undefined;
    genderId?: number | undefined;
    ageStartInsurance?: string | undefined;
    chassisNo?: string | undefined;
    registeredYear?: string | undefined;
    makeId?: string | undefined;
    makeName?: string | undefined;
    modelId?: string | undefined;
    modelName?: string | undefined;
    specificationId?: string | undefined;
    specificationName?: string | undefined;
    vehicleGroupId?: string | undefined;
    vehicleGroupName?: string | undefined;
    vmiTypeCode?: string | undefined;
    vmiTypeId?: string | undefined;
    vmiTypeName?: string | undefined;
    engineDesc?: string | undefined;
    sumInsure?: string | undefined;
    registerCode?: string | undefined;
    register?: string | undefined;
    insuranceId?: number | undefined;
    insuranceName?: string | undefined;
    referenceCode?: string | undefined;
    createOrderProducts?: CreateOrderProduct[] | undefined;
}

export interface CreateOrderPARequestDto {
    applicationCode: string;
    schoolYear: string;
    period: dayjs.Dayjs;
    customerName: string;
    payerName: string;
    fullAddress: string;
    statusName: string;
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName: string;
    productPackageId?: number | undefined;
    productPackageName: string;
    productId?: number | undefined;
    productName: string;
    premium: number;
    contactName: string;
    contactPhoneNo: string;
    isSendSMSBilling: boolean;
    checkoutProcessId: number;
    checkoutProcessName: string;
    salesUserId?: number | undefined;
    salesEmployeeCode?: string | undefined;
    purchaserCount: number;
    startCoverDate?: dayjs.Dayjs | undefined;
    endCoverDate?: dayjs.Dayjs | undefined;
    branchId: number;
    documentId?: string | undefined;
    documentCode?: string | undefined;
    documentSubTypeId?: number | undefined;
}

export interface CreateOrderPAResponseDto {
    orderHeaderId?: string | undefined;
}

export interface CreateOrderPAResponseDtoServiceResponse {
    data?: CreateOrderPAResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface CreateOrderProduct {
    productGroupId: number;
    productGroupName: string;
    productTypeId: number;
    productTypeName: string;
    productId: number;
    productName: string;
    premium: number;
    premiumSum: number;
    premiumPoint?: number | undefined;
    premiumDiscount?: number | undefined;
    premiumNet: number;
    periodTypeId: number;
    refApplicationCode?: string | undefined;
}

export interface CreateOrderSMIRequestDto {
    applicationCode: string;
    schoolYear: string;
    period: dayjs.Dayjs;
    customerName: string;
    payerName: string;
    fullAddress: string;
    statusName: string;
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName: string;
    productPackageId?: number | undefined;
    productPackageName: string;
    productId?: number | undefined;
    productName: string;
    premium: number;
    contactName: string;
    contactPhoneNo: string;
    isSendSMSBilling: boolean;
    checkoutProcessId: number;
    checkoutProcessName: string;
    salesUserId?: number | undefined;
    salesEmployeeCode?: string | undefined;
    policyNo: string;
    startCoverDate?: dayjs.Dayjs | undefined;
    endCoverDate?: dayjs.Dayjs | undefined;
    branchId: number;
    sourceTypeId: number;
    orderPolicySMIs?: OrderPolicySMIDto[] | undefined;
}

export interface CreateOrderSMIResponseDto {
    orderHeaderId?: string | undefined;
}

export interface CreateOrderSMIResponseDtoServiceResponse {
    data?: CreateOrderSMIResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentDto {
    documentId?: string;
    documentCode?: string | undefined;
    documentSubTypeId?: number | undefined;
    docReferenceId?: string | undefined;
    docReferenceTypeId?: number | undefined;
}

export interface DocumentDtoListServiceResponse {
    data?: DocumentDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetApplicationListDto {
    igCode?: string | undefined;
    isSelected?: boolean;
}

export interface GetBankDueDateDto {
    id?: string;
    period?: dayjs.Dayjs | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    isPublished?: boolean | undefined;
}

export interface GetBankDueDateDtoServiceResponse {
    data?: GetBankDueDateDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetBillByGUIDDto {
    code?: string | undefined;
    checkoutProcessId?: number | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    statusId?: number | undefined;
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName?: string | undefined;
    productPackageId?: number | undefined;
    productPackageName?: string | undefined;
    periodTypeId?: number | undefined;
}

export interface GetBillByGUIDDtoListServiceResponse {
    data?: GetBillByGUIDDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetBillingStatusInquiryDto {
    applicationCode?: string | undefined;
    billingStatusId?: number | undefined;
    billingStatus?: string | undefined;
    billNo?: string | undefined;
    debtHeaderId?: string | undefined;
}

export interface GetBillingStatusInquiryDtoServiceResponse {
    data?: GetBillingStatusInquiryDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetDcrDateByOrderIdDto {
    orderSubDetailId?: string | undefined;
    inCode?: string | undefined;
    dcrDate?: dayjs.Dayjs | undefined;
}

export interface GetDcrDateByOrderIdDtoListServiceResponse {
    data?: GetDcrDateByOrderIdDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetGuidInCodeDto {
    id?: string;
    inCode?: string | undefined;
}

export interface GetGuidInCodeDtoServiceResponse {
    data?: GetGuidInCodeDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetGUIDOrderSubDetailByInCodeResponseDto {
    id?: string;
}

export interface GetGUIDOrderSubDetailByInCodeResponseDtoServiceResponse {
    data?: GetGUIDOrderSubDetailByInCodeResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderByIGCodeDto {
    igCode?: string | undefined;
    personGuid?: string | undefined;
    personId?: number | undefined;
    cardDetail?: string | undefined;
    cardTypeId?: number;
    titleId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    paymentMethodTypeId?: number | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    statusId?: number | undefined;
    bankId?: string | undefined;
    bankAccountName?: string | undefined;
    bankAccountNo?: string | undefined;
    refPremium?: string | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    contactName?: string | undefined;
    billNoId?: string | undefined;
    orderSubDetails?: GetOrderSubDetailDto[] | undefined;
}

export interface GetOrderByIGCodeDtoServiceResponse {
    data?: GetOrderByIGCodeDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderDetailDto {
    orderId?: string;
    igCode?: string | undefined;
    productId?: number | undefined;
    planId?: number | undefined;
    premium?: number | undefined;
    premiumSum?: number | undefined;
    premiumPoint?: number | undefined;
    premiumDiscount?: number | undefined;
    premiumNet?: number | undefined;
    periodTypeId?: number | undefined;
    customerName?: string | undefined;
}

export interface GetOrderDetailDtoListServiceResponse {
    data?: GetOrderDetailDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderDetailListDto {
    chassisNo?: string | undefined;
    makeId?: string | undefined;
    makeName?: string | undefined;
    modelId?: string | undefined;
    modelName?: string | undefined;
    specificationId?: string | undefined;
    specificationName?: string | undefined;
    vehicleGroupId?: string | undefined;
    vehicleGroupName?: string | undefined;
    vmiTypeId?: string | undefined;
    vmiTypeName?: string | undefined;
    vmiTypeCode?: string | undefined;
    engineDesc?: string | undefined;
    registeredYear?: string | undefined;
    sumInsure?: string | undefined;
    registerCode?: string | undefined;
    register?: string | undefined;
    orderId?: string;
    igCode?: string | undefined;
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName?: string | undefined;
    productPackageId?: number | undefined;
    productPackageName?: string | undefined;
    premium?: number | undefined;
    premiumSum?: number | undefined;
    premiumPoint?: number | undefined;
    premiumDiscount?: number | undefined;
    premiumNet?: number | undefined;
    periodTypeId?: number | undefined;
    customerName?: string | undefined;
    dcrDate?: dayjs.Dayjs | undefined;
    startCoverDate?: dayjs.Dayjs | undefined;
    birthDate?: dayjs.Dayjs | undefined;
    genderId?: number | undefined;
    ageStartInsurance?: string | undefined;
    insuranceId?: number | undefined;
    insuranceName?: string | undefined;
    referenceCode?: string | undefined;
    orderSubDetails?: GetOrderSubDetailListDto[] | undefined;
}

export interface GetOrderDto {
    id?: string;
    code: string;
    personTypeId?: number;
    personId?: number | undefined;
    cardDetail?: string | undefined;
    cardTypeId?: number;
    titleId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    addressDetail1?: string | undefined;
    addressDetail2?: string | undefined;
    postCode?: string | undefined;
    checkoutProcessId?: number | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    paymentMethodTypeId?: number | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    slaCount?: number | undefined;
    cancelCauseId?: number | undefined;
    statusId?: number | undefined;
    quantity?: number | undefined;
    amount?: number | undefined;
    bankId?: number | undefined;
    bankAccountName?: string | undefined;
    bankAccountNo?: string | undefined;
    isSendToPremium?: number | undefined;
    refPremium?: string | undefined;
}

export interface GetOrderDtoListServiceResponse {
    data?: GetOrderDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderDtoServiceResponse {
    data?: GetOrderDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderGroupDto {
    orderGroupId?: string;
    orderGroupCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    sourceTypeId?: number | undefined;
    paymentMethodTypeId?: number | undefined;
    itemCount?: number | undefined;
    totalAmount?: number | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    isSendSMSPaySlip?: boolean | undefined;
    isSendSMSBilling?: boolean | undefined;
    orderGroupStatusId?: number | undefined;
    debtGroupReferTypeId?: number | undefined;
}

export interface GetOrderGroupDtoServiceResponse {
    data?: GetOrderGroupDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderListDto {
    id?: string;
    code: string;
    personTypeId?: number;
    personGuid?: string | undefined;
    personId?: number | undefined;
    cardDetail?: string | undefined;
    cardTypeId?: number;
    titleId?: number;
    titleName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    addressDetail1?: string | undefined;
    addressDetail2?: string | undefined;
    postCode?: string | undefined;
    checkoutProcessId?: number | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    paymentMethodTypeId?: number | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    slaCount?: number | undefined;
    cancelCauseId?: number | undefined;
    statusId?: number | undefined;
    statusDetail?: string | undefined;
    quantity?: number | undefined;
    amount?: number | undefined;
    bankId?: number | undefined;
    bankAccountName?: string | undefined;
    bankAccountNo?: string | undefined;
    isSendToPremium?: number | undefined;
    refPremium?: string | undefined;
    orderDetails?: GetOrderDetailListDto[] | undefined;
}

export interface GetOrderListDtoListServiceResponse {
    data?: GetOrderListDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderListDtoServiceResponse {
    data?: GetOrderListDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderListForSplitBillDto {
    id?: string;
    code: string;
    personTypeId?: number;
    personGuid?: string | undefined;
    personId?: number | undefined;
    cardDetail?: string | undefined;
    cardTypeId?: number;
    titleId?: number;
    titleName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    addressDetail1?: string | undefined;
    addressDetail2?: string | undefined;
    postCode?: string | undefined;
    checkoutProcessId?: number | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    paymentMethodTypeId?: number | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    slaCount?: number | undefined;
    cancelCauseId?: number | undefined;
    statusId?: number | undefined;
    quantity?: number | undefined;
    amount?: number | undefined;
    bankId?: number | undefined;
    bankAccountName?: string | undefined;
    bankAccountNo?: string | undefined;
    isSendToPremium?: number | undefined;
    refPremium?: string | undefined;
    salesUserId?: number | undefined;
    salesEmployeeCode?: string | undefined;
    salesEmployee?: string | undefined;
    branchId?: number | undefined;
    orderDetails?: GetOrderDetailListDto[] | undefined;
}

export interface GetOrderListForSplitBillDtoServiceResponse {
    data?: GetOrderListForSplitBillDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderListTableIncludeDetailDto {
    id?: string;
    code?: string | undefined;
    payerFullName?: string | undefined;
    quantity?: number | undefined;
    amount?: number | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelName?: string | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    slaCount?: string | undefined;
    statusId?: number | undefined;
    cancelCauseDetail?: string | undefined;
    phoneNumber?: string | undefined;
    refPremium?: string | undefined;
    bankId?: number | undefined;
    bankAccountName?: string | undefined;
    bankAccountNo?: string | undefined;
    isSendToPremium?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    salesUserId?: number | undefined;
    salesEmployeeCode?: string | undefined;
    salesEmployee?: string | undefined;
    orderSubDetails?: GetOrderListTableIncludeSubDetailDto[] | undefined;
}

export interface GetOrderListTableIncludeDetailDtoListServiceResponse {
    data?: GetOrderListTableIncludeDetailDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderListTableIncludeDetailDtoListServiceResponseWithPagination {
    data?: GetOrderListTableIncludeDetailDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetOrderListTableIncludeSubDetailDto {
    igCode?: string | undefined;
    inCode?: string | undefined;
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName?: string | undefined;
    productId?: number | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    premiumSum?: number | undefined;
    premiumPoint?: number | undefined;
    premiumDiscount?: number | undefined;
    premiumNet?: number | undefined;
    periodTypeName?: string | undefined;
    customerName?: string | undefined;
    dcrDate?: dayjs.Dayjs | undefined;
    birthDate?: dayjs.Dayjs | undefined;
    genderId?: number | undefined;
    refReceiveNumber?: string | undefined;
    refApplicationCode?: string | undefined;
    flagDisabledPA30?: boolean;
    statusId?: number | undefined;
    crmLeadId?: string | undefined;
}

export interface GetOrderListTableIncludeSubDetailDtoListServiceResponseWithPagination {
    data?: GetOrderListTableIncludeSubDetailDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetOrderReasonDto {
    id?: number;
    reasonDetail?: string | undefined;
    isActive?: boolean | undefined;
}

export interface GetOrderReasonDtoListServiceResponse {
    data?: GetOrderReasonDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderSMIResponseDto {
    orderId?: string;
    billNo?: string | undefined;
    policyNo?: string | undefined;
    applicationCode?: string | undefined;
    payerName?: string | undefined;
    amount?: number | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    checkoutProcessId?: number | undefined;
    checkoutProcessName?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    statusId?: number | undefined;
    statusDetail?: string | undefined;
}

export interface GetOrderSMIResponseDtoListServiceResponseWithPagination {
    data?: GetOrderSMIResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetOrderStatusDto {
    statusId?: number | undefined;
    statusDetail?: string | undefined;
    isActive?: boolean | undefined;
}

export interface GetOrderStatusDtoListServiceResponse {
    data?: GetOrderStatusDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderSubDetailDto {
    chassisNo?: string | undefined;
    makeId?: string | undefined;
    makeName?: string | undefined;
    modelId?: string | undefined;
    modelName?: string | undefined;
    specificationId?: string | undefined;
    specificationName?: string | undefined;
    vehicleGroupId?: string | undefined;
    vehicleGroupName?: string | undefined;
    vmiTypeId?: string | undefined;
    vmiTypeName?: string | undefined;
    vmiTypeCode?: string | undefined;
    engineDesc?: string | undefined;
    registeredYear?: string | undefined;
    sumInsure?: string | undefined;
    registerCode?: string | undefined;
    register?: string | undefined;
    id?: string;
    orderDetailId?: string;
    inCode?: string | undefined;
    productGroupId?: number | undefined;
    productGroupName?: string | undefined;
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName?: string | undefined;
    productTypeId?: number | undefined;
    productTypeName?: string | undefined;
    productId?: number | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    premiumSum?: number | undefined;
    premiumPoint?: number | undefined;
    premiumDiscount?: number | undefined;
    premiumNet?: number | undefined;
    periodTypeId?: number | undefined;
    periodTypeName?: string | undefined;
    customerName?: string | undefined;
    dcrDate?: dayjs.Dayjs | undefined;
    birthDate?: dayjs.Dayjs | undefined;
    genderId?: number | undefined;
    refReceiveNumber?: string | undefined;
    refAplicationCode?: string | undefined;
    detail3?: string | undefined;
    insuranceId?: number | undefined;
    insuranceName?: string | undefined;
}

export interface GetOrderSubDetailDtoListServiceResponse {
    data?: GetOrderSubDetailDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetOrderSubDetailListDto {
    orderSubDetailId?: string | undefined;
    igCode?: string | undefined;
    inCode?: string | undefined;
    productGroupId?: number | undefined;
    productGroupName?: string | undefined;
    productPackageId?: number | undefined;
    productPackageName?: string | undefined;
    productTypeId?: number | undefined;
    productTypeName?: string | undefined;
    productId?: number | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    premiumSum?: number | undefined;
    premiumPoint?: number | undefined;
    premiumDiscount?: number | undefined;
    premiumNet?: number | undefined;
    periodTypeId?: number | undefined;
    customerName?: string | undefined;
    refReceiveNumber?: string | undefined;
    refApplicationCode?: string | undefined;
}

export interface GetPayerByINCodeDto {
    personTypeId?: number;
    personGuid?: string | undefined;
    personId?: number | undefined;
    cardDetail?: string | undefined;
    cardTypeId?: number;
    titleId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
}

export interface GetPayerByINCodeDtoServiceResponse {
    data?: GetPayerByINCodeDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetPeriodNowResponseDto {
    period?: dayjs.Dayjs | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    isPublished?: boolean | undefined;
}

export interface GetPeriodNowResponseDtoServiceResponse {
    data?: GetPeriodNowResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetProductPackageDisplayDto {
    productPackageDisplayId?: number;
    productPackageDisplayName?: string | undefined;
    inCode?: string | undefined;
}

export interface GetProductPackageDisplayDtoServiceResponse {
    data?: GetProductPackageDisplayDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetReportDebtWithoutNewAppDto_Response {
    billingCode?: string | undefined;
    igCode?: string | undefined;
    inCode?: string | undefined;
    paymentStatusName?: string | undefined;
    customerName?: string | undefined;
    payerName?: string | undefined;
    productGroupName?: string | undefined;
    dcrDate?: string | undefined;
    productName?: string | undefined;
    carRegister?: string | undefined;
    totalAmount?: number | undefined;
    periodTypeName?: string | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelName?: string | undefined;
    createdDate?: string | undefined;
    createdTime?: string | undefined;
    payablePeriodToDate?: string | undefined;
    payablePeriodToTime?: string | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    transactionDate?: string | undefined;
    transactiontime?: string | undefined;
    saleEmployee?: string | undefined;
    saleEmployeePhoneNo?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
    saleEmployeeTeamName?: string | undefined;
    refApplicationCode?: string | undefined;
    totalCount?: number | undefined;
}

export interface GetReportDebtWithoutNewAppDto_ResponseListServiceResponseWithPagination {
    data?: GetReportDebtWithoutNewAppDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportUnbillDto_Response {
    applicationCode?: string | undefined;
    payerName?: string | undefined;
    payerIdentityCard?: string | undefined;
    payerPassport?: string | undefined;
    payerPrimaryPhone?: string | undefined;
    customerName?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    saleEmployee?: string | undefined;
    totalCount?: number | undefined;
}

export interface GetReportUnbillDto_ResponseListServiceResponseWithPagination {
    data?: GetReportUnbillDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetSplitBilPayloadlDto {
    orderId?: string;
    applicationList?: GetApplicationListDto[] | undefined;
}

export interface GetStatusPremiumOrderByINCodeDto {
    statusId?: number | undefined;
    refPremium?: string | undefined;
    transactionDatetime?: string | undefined;
    refReceiveNumber?: string | undefined;
    refApplicationCode?: string | undefined;
}

export interface GetStatusPremiumOrderByINCodeDtoServiceResponse {
    data?: GetStatusPremiumOrderByINCodeDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetTransactionDto {
    orderEventLogId?: string;
    orderId?: string;
    orderDetailId?: string | undefined;
    orderSubdetailId?: string | undefined;
    eventTypeId?: number | undefined;
    detail?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    salesEmployeeId?: string | undefined;
    salesEmployeeName?: string | undefined;
    documentCode?: string | undefined;
}

export interface GetTransactionDtoListServiceResponse {
    data?: GetTransactionDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetTransactionHeaderDto {
    code?: string | undefined;
    payerName?: string | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelName?: string | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    statusId?: number | undefined;
    statusName?: string | undefined;
    quantity?: number | undefined;
    amount?: number | undefined;
    createdByUserId?: number | undefined;
}

export interface GetTransactionHeaderDtoServiceResponse {
    data?: GetTransactionHeaderDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetTransactionHeaderWithInvoiceDto {
    idCode?: string;
    code?: string | undefined;
    inCode?: string | undefined;
    payerName?: string | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelName?: string | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    statusId?: number | undefined;
    statusName?: string | undefined;
    quantity?: number | undefined;
    amount?: number | undefined;
    createdByUserId?: number | undefined;
}

export interface GetTransactionHeaderWithInvoiceDtoServiceResponse {
    data?: GetTransactionHeaderWithInvoiceDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetTransactionOrderDto {
    inCode?: string | undefined;
    customerName?: string | undefined;
    periodTypeName?: string | undefined;
    productPackageDisplayName?: string | undefined;
    productPackageId?: number | undefined;
    periodTypeId?: number | undefined;
    premiumNet?: number | undefined;
    refApplicationCode?: string | undefined;
}

export interface GetTransactionOrderDtoListServiceResponse {
    data?: GetTransactionOrderDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetUnBillAppDto {
    unBillAppId?: string;
    /** OrderSubDetailId/DebtDetailId */
    debtDetailId?: string | undefined;
    in?: string | undefined;
    productGroupName?: string | undefined;
    applicationCode?: string | undefined;
    custName?: string | undefined;
    saleEmployee?: string | undefined;
    premium?: number | undefined;
    discount?: number | undefined;
    totalAmount?: number | undefined;
    period?: dayjs.Dayjs | undefined;
    debtGroupReferTypeId?: number | undefined;
    /** OrderId/DebtHeaderId */
    debtHeaderId: string;
    /** OrdeCode */
    b?: string | undefined;
    /** ถูกสร้างไปใหม่ยัง */
    isGenerate?: boolean | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updateByUserId?: number | undefined;
}

export interface GetUnBillAppDtoListServiceResponse {
    data?: GetUnBillAppDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface MonitorBillsResponeDto {
    orderHeaderId?: string | undefined;
    code?: string | undefined;
    applicationCode?: string | undefined;
    schoolYear?: string | undefined;
    schoolName?: string | undefined;
    amount?: number | undefined;
    checkoutProcessId?: number | undefined;
    checkoutProcessName?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    orderStatusId?: number | undefined;
    orderStatusName?: string | undefined;
    refPremium?: string | undefined;
    debtGroupReferTypeId?: number | undefined;
}

export interface MonitorBillsResponeDtoListServiceResponseWithPagination {
    data?: MonitorBillsResponeDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface MotorDetailResponseDto {
    chassisNo?: string | undefined;
    makeId?: string | undefined;
    makeName?: string | undefined;
    modelId?: string | undefined;
    modelName?: string | undefined;
    specificationId?: string | undefined;
    specificationName?: string | undefined;
    vehicleGroupId?: string | undefined;
    vehicleGroupName?: string | undefined;
    vmiTypeId?: string | undefined;
    vmiTypeName?: string | undefined;
    vmiTypeCode?: string | undefined;
    engineDesc?: string | undefined;
    registeredYear?: string | undefined;
    sumInsure?: string | undefined;
    registerCode?: string | undefined;
    register?: string | undefined;
    dcrDate?: dayjs.Dayjs | undefined;
}

export interface MotorDetailResponseDtoServiceResponse {
    data?: MotorDetailResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Order {
    id?: string;
    code: string;
    orderGroupId?: string | undefined;
    personTypeId?: number;
    personGuid?: string | undefined;
    personId?: number | undefined;
    cardDetail?: string | undefined;
    cardTypeId?: number;
    titleId?: number;
    titleName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    addressDetail1?: string | undefined;
    addressDetail2?: string | undefined;
    postCode?: string | undefined;
    checkoutProcessId?: number | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    slaCount?: number | undefined;
    cancelCauseId?: number | undefined;
    cancelCauseDetail?: string | undefined;
    statusId?: number | undefined;
    quantity?: number | undefined;
    amount?: number | undefined;
    bankId?: number | undefined;
    bankAccountName?: string | undefined;
    bankAccountNo?: string | undefined;
    isSendToPremium?: number | undefined;
    refPremium?: string | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    salesUserId?: number | undefined;
    salesEmployeeCode?: string | undefined;
    branchId?: number | undefined;
    crmLeadId?: string | undefined;
    ocrId?: string | undefined;
    orderDetails?: OrderDetail[] | undefined;
    orderGroup?: OrderGroup;
    orderStatus?: OrderStatus;
}

export interface OrderChangeBillSelectsResponseDto {
    orderId?: string | undefined;
    billNo?: string | undefined;
    payerName?: string | undefined;
    countItem?: number;
    premium?: number | undefined;
    statusId?: number | undefined;
    statusName?: string | undefined;
    salesEmployeeName?: string | undefined;
    branchName?: string | undefined;
}

export interface OrderChangeBillSelectsResponseDtoListServiceResponseWithPagination {
    data?: OrderChangeBillSelectsResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface OrderChangeBillUpdateRequestDto {
    orderIdLst: string;
    changeBillHeaderCode: string;
    orderRemarkId: number;
    description?: string | undefined;
    documentCode: string;
    fromBranchId?: number | undefined;
    toBranchId?: number | undefined;
    fromSalesUserId?: number | undefined;
    requestUserId: number;
    toSalesUserId: number;
}

export interface OrderCountResponseDto {
    orderCount?: number | undefined;
    orderAmount?: number | undefined;
    orderSavedCount?: number | undefined;
    orderSavedAmount?: number | undefined;
    orderNoAppCount?: number | undefined;
    orderNoAppAmount?: number | undefined;
}

export interface OrderCountResponseDtoServiceResponse {
    data?: OrderCountResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface OrderDetail {
    id?: string;
    orderId?: string;
    igCode?: string | undefined;
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName?: string | undefined;
    productPackageId?: number | undefined;
    productPackageName?: string | undefined;
    premium?: number | undefined;
    premiumSum?: number | undefined;
    premiumPoint?: number | undefined;
    premiumDiscount?: number | undefined;
    premiumNet?: number | undefined;
    periodTypeId?: number | undefined;
    customerName?: string | undefined;
    dcrDate?: dayjs.Dayjs | undefined;
    birthDate?: dayjs.Dayjs | undefined;
    genderId?: number | undefined;
    ageStartInsurance?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updateByUserId?: number | undefined;
    orderSubDetails?: OrderSubDetail[] | undefined;
    order?: Order;
}

export interface OrderGroup {
    orderGroupId?: string;
    orderGroupCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    sourceTypeId?: number | undefined;
    paymentMethodTypeId?: number | undefined;
    itemCount?: number | undefined;
    totalAmount?: number | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    isSendSMSPaySlip?: boolean | undefined;
    isSendSMSBilling?: boolean | undefined;
    orderGroupStatusId?: number | undefined;
    debtGroupReferTypeId?: number | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    orders?: Order[] | undefined;
}

export interface OrderMoUsersResponseDto {
    billNo?: string | undefined;
    payerFirstName?: string | undefined;
    premiumPayer?: string | undefined;
    productName?: string | undefined;
    premiumNet?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    igCode?: string | undefined;
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName?: string | undefined;
    productPackageId?: number | undefined;
    productPackageName?: string | undefined;
    crmLeadId?: string | undefined;
}

export interface OrderMoUsersResponseDtoListServiceResponseWithPagination {
    data?: OrderMoUsersResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface OrderMoViewsResponseDto {
    salesUserId?: number | undefined;
    salesCode?: string | undefined;
    salesName?: string | undefined;
    salesPhoneNo?: string | undefined;
    salesTeam?: string | undefined;
    salesInCount?: number | undefined;
}

export interface OrderMoViewsResponseDtoListServiceResponseWithPagination {
    data?: OrderMoViewsResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface OrderPolicySMIDto {
    paPolicyTransactionId?: number | undefined;
    policyNumber?: string | undefined;
    endorseNo?: string | undefined;
    amount?: number | undefined;
}

export interface OrderResponseDto {
    orderId?: string;
    orderGroupId?: string | undefined;
    code?: string | undefined;
    amount?: number | undefined;
    phoneNumber?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
}

export interface OrderResponseDtoServiceResponse {
    data?: OrderResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface OrderStatus {
    id?: number;
    statusId?: number | undefined;
    statusDetail?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUser?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUser?: number | undefined;
}

export interface OrderSubDetail {
    id?: string;
    orderDetailId?: string;
    inCode?: string | undefined;
    productGroupId?: number | undefined;
    productGroupName?: string | undefined;
    productPackageDisplayId?: number | undefined;
    productPackageDisplayName?: string | undefined;
    productTypeId?: number | undefined;
    productTypeName?: string | undefined;
    productId?: number | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    premiumSum?: number | undefined;
    premiumPoint?: number | undefined;
    premiumDiscount?: number | undefined;
    premiumNet?: number | undefined;
    periodTypeId?: number | undefined;
    customerName?: string | undefined;
    /** วันที่เริ่มคุ้มครอง */
    dcrDate?: dayjs.Dayjs | undefined;
    birthDate?: dayjs.Dayjs | undefined;
    genderId?: number | undefined;
    ageStartInsurance?: string | undefined;
    refReceiveNumber?: string | undefined;
    refApplicationCode?: string | undefined;
    detail1?: string | undefined;
    detail2?: string | undefined;
    detail3?: string | undefined;
    insuranceId?: number | undefined;
    insuranceName?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updateByUserId?: number | undefined;
    orderDetails?: OrderDetail;
}

export interface OrderSubDetailsResponseDto {
    billNo?: string | undefined;
    inCode?: string | undefined;
    salesName?: string | undefined;
    salesPersonName?: string | undefined;
    productName?: string | undefined;
    premiumNet?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    crmLeadId?: string | undefined;
}

export interface OrderSubDetailsResponseDtoListServiceResponseWithPagination {
    data?: OrderSubDetailsResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface RemarkResponseDto {
    orderRemarkId?: number | undefined;
    orderRemarkDetail?: string | undefined;
}

export interface RemarkResponseDtoListServiceResponse {
    data?: RemarkResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface ReportBankPaymentWaitRequestDto {
    period: dayjs.Dayjs;
    branchId?: number | undefined;
    userId?: number | undefined;
}

export interface ReportResponseDto {
    isResult?: boolean | undefined;
    data?: string | undefined;
    message?: string | undefined;
    fileName?: string | undefined;
}

export interface ReportResponseDtoServiceResponse {
    data?: ReportResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface SetUpDebtNewAppDto_Response {
    id?: string;
    period?: dayjs.Dayjs | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    isPublished?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    createdByEmployee?: string | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    updatedByEmployee?: string | undefined;
}

export interface SetUpDebtNewAppDto_ResponseListServiceResponseWithPagination {
    data?: SetUpDebtNewAppDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface StringServiceResponse {
    data?: string | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface UpdateApplicationCodeRequestDto {
    debtHeaderId: string;
    fromApplicationCode: string;
    fromSendPhone: string;
    toApplicationCode: string;
    toSendPhone: string;
    toSchoolName: string;
    toContactName: string;
    toFullAddress: string;
    toProductName: string;
    toStartCoverDate: dayjs.Dayjs;
    toEndCoverDate: dayjs.Dayjs;
    documentId: string;
}

export interface UpdateApplicationCodeResponseDto {
    debtHeaderId?: string | undefined;
}

export interface UpdateApplicationCodeResponseDtoServiceResponse {
    data?: UpdateApplicationCodeResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface UpsertSetUpDebtNewAppDto_Response {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface UpsertSetUpDebtNewAppDto_ResponseServiceResponse {
    data?: UpsertSetUpDebtNewAppDto_Response;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_OrderChangeBill_UpdateResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_OrderChangeBill_UpdateResultServiceResponse {
    data?: Usp_OrderChangeBill_UpdateResult;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_OrderDashboardAdmin_SelectResult {
    branchId?: number;
    branchDetail?: string | undefined;
    bcount?: number | undefined;
    iNcount?: number | undefined;
    totalCount?: number | undefined;
}

export interface Usp_OrderDashboardAdmin_SelectResultListServiceResponseWithPagination {
    data?: Usp_OrderDashboardAdmin_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_OrderHistoryHeader_SelectResult {
    orderId?: string;
    code?: string | undefined;
    checkoutProcessId?: number | undefined;
    checkoutProcessName?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
    productPackageDisplayName?: string | undefined;
    productName?: string | undefined;
    policyNo?: string | undefined;
    applicationCode?: string | undefined;
    firstName?: string | undefined;
    contactNamePA?: string | undefined;
    phoneNumber?: string | undefined;
}

export interface Usp_OrderHistoryHeader_SelectResultServiceResponse {
    data?: Usp_OrderHistoryHeader_SelectResult;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_ReportChangeApplicationLog_SelectResult {
    code?: string | undefined;
    createdBillByName?: string | undefined;
    createdBillByBranchId?: number | undefined;
    createdBillByBranch?: string | undefined;
    fromApplication?: string | undefined;
    fromShcoolName?: string | undefined;
    fromShcoolPlaceName?: string | undefined;
    toApplication?: string | undefined;
    toShcoolName?: string | undefined;
    toShcoolPlaceName?: string | undefined;
    createdByCode?: string | undefined;
    createdByName?: string | undefined;
    createdByBranchId?: number | undefined;
    createdByBranch?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    totalCount?: number | undefined;
}

export interface Usp_ReportChangeApplicationLog_SelectResultListServiceResponseWithPagination {
    data?: Usp_ReportChangeApplicationLog_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_ReportChangePhoneNumber_SelectResult {
    createdDate?: dayjs.Dayjs | undefined;
    billNo?: string | undefined;
    applicationCode?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrict?: string | undefined;
    payerWorkPlaceDistrict?: string | undefined;
    payerWorkPlaceProvince?: string | undefined;
    contactPhoneNo?: string | undefined;
    phoneNumber?: string | undefined;
    createdByUserName?: string | undefined;
    createdByBranch?: string | undefined;
    remark?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_ReportChangePhoneNumber_SelectResultListServiceResponseWithPagination {
    data?: Usp_ReportChangePhoneNumber_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_UnBillApp_SelectResult {
    b?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number | undefined;
    premium?: number | undefined;
    paymentMethodTypeId?: number | undefined;
    paymentMethodTypeName?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    splitBillHour_Expire?: number | undefined;
    debtHeaderId?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_UnBillApp_SelectResultListServiceResponse {
    data?: Usp_UnBillApp_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}