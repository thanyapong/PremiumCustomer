//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { customFormatter } from "../modules/_common/commonFunctions";
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import * as dayjs from 'dayjs';

export class AccountClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getAccountBill(period: dayjs.Dayjs, bankAccountNo: string, bankId: number, debtGroupReferTypeId: number, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetAccountBillResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/account/bills?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankAccountNo === undefined || bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' must be defined and cannot be null.");
        else
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (debtGroupReferTypeId === undefined || debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccountBill(_response);
        });
    }

    protected processGetAccountBill(response: AxiosResponse): Promise<GetAccountBillResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetAccountBillResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAccountBillResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @return OK
     */
    getAccountBillDetail(period: dayjs.Dayjs, bankAccountNo: string, bankId: number, debtGroupReferTypeId: number, cancelToken?: CancelToken | undefined): Promise<GetAccountBillDetailResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/account/bill/detail?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankAccountNo === undefined || bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' must be defined and cannot be null.");
        else
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (debtGroupReferTypeId === undefined || debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccountBillDetail(_response);
        });
    }

    protected processGetAccountBillDetail(response: AxiosResponse): Promise<GetAccountBillDetailResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetAccountBillDetailResponseDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAccountBillDetailResponseDtoListServiceResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAccountDisableHistory(bankAccountNo: string, cancelToken?: CancelToken | undefined): Promise<GetAccountDisableHistoryResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/account/disable/history/{bankAccountNo}";
        if (bankAccountNo === undefined || bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' must be defined.");
        url_ = url_.replace("{bankAccountNo}", encodeURIComponent("" + bankAccountNo));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccountDisableHistory(_response);
        });
    }

    protected processGetAccountDisableHistory(response: AxiosResponse): Promise<GetAccountDisableHistoryResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetAccountDisableHistoryResponseDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAccountDisableHistoryResponseDtoListServiceResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disableAccount(body?: DisableAccountRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<DisableAccountResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/account/disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDisableAccount(_response);
        });
    }

    protected processDisableAccount(response: AxiosResponse): Promise<DisableAccountResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DisableAccountResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DisableAccountResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param bankId (optional) 
     * @return OK
     */
    downloadReportDisableAccount(period: dayjs.Dayjs, bankId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/account/report/disable/download?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportDisableAccount(_response);
        });
    }

    protected processDownloadReportDisableAccount(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DirectDebitScheduleClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Create TempDirectDebitSchedule
     * @param file (optional) 
     * @param period (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @return OK
     */
    tempdirectdebitschedulePOST(file?: FileParameter | undefined, period?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<CreateTempDirectDebitScheduleResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/directdebitschedule/tempdirectdebitschedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (period === null || period === undefined)
            throw new Error("The parameter 'period' cannot be null.");
        else
            content_.append("Period", period.toJSON());
        if (debtGroupReferTypeId === null || debtGroupReferTypeId === undefined)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else
            content_.append("DebtGroupReferTypeId", debtGroupReferTypeId.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempdirectdebitschedulePOST(_response);
        });
    }

    protected processTempdirectdebitschedulePOST(response: AxiosResponse): Promise<CreateTempDirectDebitScheduleResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<CreateTempDirectDebitScheduleResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateTempDirectDebitScheduleResponseDtoServiceResponse>(null as any);
    }

    /**
     * Get TempDirectDebitSchedule
     * @param isValid (optional) 
     * @param directDebitScheduleGroupId (optional) 
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    tempdirectdebitscheduleGET(period: dayjs.Dayjs, debtGroupReferTypeId: number, isValid?: boolean | undefined, directDebitScheduleGroupId?: string | undefined, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_TempDirectDebitSchedule_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/directdebitschedule/tempdirectdebitschedule?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === undefined || debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (isValid === null)
            throw new Error("The parameter 'isValid' cannot be null.");
        else if (isValid !== undefined)
            url_ += "IsValid=" + encodeURIComponent("" + isValid) + "&";
        if (directDebitScheduleGroupId === null)
            throw new Error("The parameter 'directDebitScheduleGroupId' cannot be null.");
        else if (directDebitScheduleGroupId !== undefined)
            url_ += "DirectDebitScheduleGroupId=" + encodeURIComponent("" + directDebitScheduleGroupId) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempdirectdebitscheduleGET(_response);
        });
    }

    protected processTempdirectdebitscheduleGET(response: AxiosResponse): Promise<Usp_TempDirectDebitSchedule_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_TempDirectDebitSchedule_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_TempDirectDebitSchedule_SelectResultListServiceResponse>(null as any);
    }

    /**
     * Download TemplateExcel
     * @param body (optional) 
     * @return OK
     */
    download(body?: DownloadTemplateExcelRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/directdebitschedule/exceltemplate/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create DirectDebitSchedule
     * @param body (optional) 
     * @return OK
     */
    directdebitschedulePOST(body?: CreateDirectDebitScheduleRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DirectDebitSchedule_InsertResultServiceResponse> {
        let url_ = this.baseUrl + "/directdebitschedule/directdebitschedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDirectdebitschedulePOST(_response);
        });
    }

    protected processDirectdebitschedulePOST(response: AxiosResponse): Promise<Usp_DirectDebitSchedule_InsertResultServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DirectDebitSchedule_InsertResultServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DirectDebitSchedule_InsertResultServiceResponse>(null as any);
    }

    /**
     * Get DirectDebitSchedule
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    directdebitscheduleGET(period: dayjs.Dayjs, debtGroupReferTypeId: number, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DirectDebitSchedule_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/directdebitschedule/directdebitschedule?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === undefined || debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDirectdebitscheduleGET(_response);
        });
    }

    protected processDirectdebitscheduleGET(response: AxiosResponse): Promise<Usp_DirectDebitSchedule_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DirectDebitSchedule_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DirectDebitSchedule_SelectResultListServiceResponse>(null as any);
    }

    /**
     * Download Report Error TempDirectDebitSchedule
     * @param body (optional) 
     * @return OK
     */
    download2(body?: ReportTempDirectDebitScheduleRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/directdebitschedule/report/tempdirectdebitschedule/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload2(_response);
        });
    }

    protected processDownload2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Remark By DirectdebitscheduleId
     * @return OK
     */
    remark(id: string, cancelToken?: CancelToken | undefined): Promise<StringServiceResponse> {
        let url_ = this.baseUrl + "/directdebitschedule/{id}/remark";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemark(_response);
        });
    }

    protected processRemark(response: AxiosResponse): Promise<StringServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<StringServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringServiceResponse>(null as any);
    }
}

export class DirectDebitScheduleV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Create TempDirectDebitSchedule
     * @param file (optional) 
     * @param period (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @return OK
     */
    createTempDirectDebitScheduleV2(file?: FileParameter | undefined, period?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<CreateTempDirectDebitScheduleResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/directdebitschedule/tempdirectdebitschedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (period === null || period === undefined)
            throw new Error("The parameter 'period' cannot be null.");
        else
            content_.append("Period", period.toJSON());
        if (debtGroupReferTypeId === null || debtGroupReferTypeId === undefined)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else
            content_.append("DebtGroupReferTypeId", debtGroupReferTypeId.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateTempDirectDebitScheduleV2(_response);
        });
    }

    protected processCreateTempDirectDebitScheduleV2(response: AxiosResponse): Promise<CreateTempDirectDebitScheduleResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<CreateTempDirectDebitScheduleResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateTempDirectDebitScheduleResponseDtoServiceResponse>(null as any);
    }

    /**
     * Get TempDirectDebitSchedule
     * @param isValid (optional) 
     * @param directDebitScheduleGroupId (optional) 
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    getTempDirectDebitSchedulesV2(period: dayjs.Dayjs, debtGroupReferTypeId: number, isValid?: boolean | undefined, directDebitScheduleGroupId?: string | undefined, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_TempDirectDebitSchedule_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/directdebitschedule/tempdirectdebitschedule?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === undefined || debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (isValid === null)
            throw new Error("The parameter 'isValid' cannot be null.");
        else if (isValid !== undefined)
            url_ += "IsValid=" + encodeURIComponent("" + isValid) + "&";
        if (directDebitScheduleGroupId === null)
            throw new Error("The parameter 'directDebitScheduleGroupId' cannot be null.");
        else if (directDebitScheduleGroupId !== undefined)
            url_ += "DirectDebitScheduleGroupId=" + encodeURIComponent("" + directDebitScheduleGroupId) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTempDirectDebitSchedulesV2(_response);
        });
    }

    protected processGetTempDirectDebitSchedulesV2(response: AxiosResponse): Promise<Usp_TempDirectDebitSchedule_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_TempDirectDebitSchedule_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_TempDirectDebitSchedule_SelectResultListServiceResponse>(null as any);
    }

    /**
     * Download TemplateExcel
     * @param body (optional) 
     * @return OK
     */
    downloadTemplateExcelV2(body?: DownloadTemplateExcelRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/directdebitschedule/exceltemplate/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadTemplateExcelV2(_response);
        });
    }

    protected processDownloadTemplateExcelV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create DirectDebitSchedule
     * @param body (optional) 
     * @return OK
     */
    createDirectDebitScheduleV2(body?: CreateDirectDebitScheduleRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DirectDebitSchedule_InsertResultServiceResponse> {
        let url_ = this.baseUrl + "/v2/directdebitschedule/directdebitschedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDirectDebitScheduleV2(_response);
        });
    }

    protected processCreateDirectDebitScheduleV2(response: AxiosResponse): Promise<Usp_DirectDebitSchedule_InsertResultServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DirectDebitSchedule_InsertResultServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DirectDebitSchedule_InsertResultServiceResponse>(null as any);
    }

    /**
     * Get DirectDebitSchedule
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    getDirectDebitScheduleV2(period: dayjs.Dayjs, debtGroupReferTypeId: number, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DirectDebitSchedule_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/directdebitschedule/directdebitschedule?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === undefined || debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDirectDebitScheduleV2(_response);
        });
    }

    protected processGetDirectDebitScheduleV2(response: AxiosResponse): Promise<Usp_DirectDebitSchedule_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DirectDebitSchedule_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DirectDebitSchedule_SelectResultListServiceResponse>(null as any);
    }

    /**
     * Download Report Error TempDirectDebitSchedule
     * @param body (optional) 
     * @return OK
     */
    downloadReportTempDirectDebitScheduleV2(body?: ReportTempDirectDebitScheduleRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/directdebitschedule/report/tempdirectdebitschedule/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportTempDirectDebitScheduleV2(_response);
        });
    }

    protected processDownloadReportTempDirectDebitScheduleV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Remark By DirectdebitscheduleId
     * @return OK
     */
    getRemarkByIdV2(id: string, cancelToken?: CancelToken | undefined): Promise<StringServiceResponse> {
        let url_ = this.baseUrl + "/v2/directdebitschedule/{id}/remark";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRemarkByIdV2(_response);
        });
    }

    protected processGetRemarkByIdV2(response: AxiosResponse): Promise<StringServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<StringServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringServiceResponse>(null as any);
    }
}

export class FeeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param paymentStatusId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debtheaders(period: dayjs.Dayjs, paymentStatusId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<DebtHeaderFeesResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/fee/debtheaders?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtheaders(_response);
        });
    }

    protected processDebtheaders(response: AxiosResponse): Promise<DebtHeaderFeesResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebtHeaderFeesResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebtHeaderFeesResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @return OK
     */
    debtdetail(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<DebtDetailFeeResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/fee/debtdetail?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtdetail(_response);
        });
    }

    protected processDebtdetail(response: AxiosResponse): Promise<DebtDetailFeeResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebtDetailFeeResponseDtoListServiceResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebtDetailFeeResponseDtoListServiceResponse>(null as any);
    }
}

export class FeeChillPayClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    gatSettlementChillPayHeaders(settleFromDate: dayjs.Dayjs, settleToDate: dayjs.Dayjs, page?: number | undefined, recordsPerPage?: number | undefined, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetSettlementChillPayHeaderResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/settlementchillpayheaders?";
        if (settleFromDate === undefined || settleFromDate === null)
            throw new Error("The parameter 'settleFromDate' must be defined and cannot be null.");
        else
            url_ += "SettleFromDate=" + encodeURIComponent(settleFromDate ? "" + settleFromDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (settleToDate === undefined || settleToDate === null)
            throw new Error("The parameter 'settleToDate' must be defined and cannot be null.");
        else
            url_ += "SettleToDate=" + encodeURIComponent(settleToDate ? "" + settleToDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGatSettlementChillPayHeaders(_response);
        });
    }

    protected processGatSettlementChillPayHeaders(response: AxiosResponse): Promise<GetSettlementChillPayHeaderResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetSettlementChillPayHeaderResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetSettlementChillPayHeaderResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @return OK
     */
    gatSettlementChillPayHeaderBySettleDate(settledate: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<GetSettlementChillPayHeaderResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/settlementchillpayheader/{settledate}";
        if (settledate === undefined || settledate === null)
            throw new Error("The parameter 'settledate' must be defined.");
        url_ = url_.replace("{settledate}", encodeURIComponent(settledate ? "" + settledate.format('YYYY-MM-DDTHH:mm:ss') : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGatSettlementChillPayHeaderBySettleDate(_response);
        });
    }

    protected processGatSettlementChillPayHeaderBySettleDate(response: AxiosResponse): Promise<GetSettlementChillPayHeaderResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetSettlementChillPayHeaderResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetSettlementChillPayHeaderResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    getSettlementChillPayDetails(settledate: dayjs.Dayjs, page?: number | undefined, recordsPerPage?: number | undefined, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetSettlementChillPayDetailResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/settlementchillpayheader/{settledate}/settlementchillpaydetails?";
        if (settledate === undefined || settledate === null)
            throw new Error("The parameter 'settledate' must be defined.");
        url_ = url_.replace("{settledate}", encodeURIComponent(settledate ? "" + settledate.format('YYYY-MM-DDTHH:mm:ss') : "null"));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSettlementChillPayDetails(_response);
        });
    }

    protected processGetSettlementChillPayDetails(response: AxiosResponse): Promise<GetSettlementChillPayDetailResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetSettlementChillPayDetailResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetSettlementChillPayDetailResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @return OK
     */
    getSettlementChillPayTotal(settleFromDate: dayjs.Dayjs, settleToDate: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<GetSettlementChillPayHeaderTotalResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/settlementchillpaytotal?";
        if (settleFromDate === undefined || settleFromDate === null)
            throw new Error("The parameter 'settleFromDate' must be defined and cannot be null.");
        else
            url_ += "SettleFromDate=" + encodeURIComponent(settleFromDate ? "" + settleFromDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (settleToDate === undefined || settleToDate === null)
            throw new Error("The parameter 'settleToDate' must be defined and cannot be null.");
        else
            url_ += "SettleToDate=" + encodeURIComponent(settleToDate ? "" + settleToDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSettlementChillPayTotal(_response);
        });
    }

    protected processGetSettlementChillPayTotal(response: AxiosResponse): Promise<GetSettlementChillPayHeaderTotalResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetSettlementChillPayHeaderTotalResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetSettlementChillPayHeaderTotalResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reportSettlementChillPay(body?: GetSettlementChillPayHeaderRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/settlement/settlementchillpay/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportSettlementChillPay(_response);
        });
    }

    protected processReportSettlementChillPay(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class FeePayGateClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    gatPaygateFeeHeaders(reportFromDate: dayjs.Dayjs, reportToDate: dayjs.Dayjs, page?: number | undefined, recordsPerPage?: number | undefined, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetPaygateFeeHeadersResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/paygatefeeheaders?";
        if (reportFromDate === undefined || reportFromDate === null)
            throw new Error("The parameter 'reportFromDate' must be defined and cannot be null.");
        else
            url_ += "ReportFromDate=" + encodeURIComponent(reportFromDate ? "" + reportFromDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (reportToDate === undefined || reportToDate === null)
            throw new Error("The parameter 'reportToDate' must be defined and cannot be null.");
        else
            url_ += "ReportToDate=" + encodeURIComponent(reportToDate ? "" + reportToDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGatPaygateFeeHeaders(_response);
        });
    }

    protected processGatPaygateFeeHeaders(response: AxiosResponse): Promise<GetPaygateFeeHeadersResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetPaygateFeeHeadersResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPaygateFeeHeadersResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @return OK
     */
    getPaygateFeeHeaderTotal(reportFromDate: dayjs.Dayjs, reportToDate: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<GetPaygateFeeHeaderTotalResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/paygatefeeheadertotal?";
        if (reportFromDate === undefined || reportFromDate === null)
            throw new Error("The parameter 'reportFromDate' must be defined and cannot be null.");
        else
            url_ += "ReportFromDate=" + encodeURIComponent(reportFromDate ? "" + reportFromDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (reportToDate === undefined || reportToDate === null)
            throw new Error("The parameter 'reportToDate' must be defined and cannot be null.");
        else
            url_ += "ReportToDate=" + encodeURIComponent(reportToDate ? "" + reportToDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaygateFeeHeaderTotal(_response);
        });
    }

    protected processGetPaygateFeeHeaderTotal(response: AxiosResponse): Promise<GetPaygateFeeHeaderTotalResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetPaygateFeeHeaderTotalResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPaygateFeeHeaderTotalResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    downloadReportPaygateFeeHeader(body?: GetPaygateFeeHeaderRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/paygatefeeheader/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportPaygateFeeHeader(_response);
        });
    }

    protected processDownloadReportPaygateFeeHeader(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class FeeV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param paymentStatusId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtHeadersV2(period: dayjs.Dayjs, paymentStatusId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<DebtHeaderFeesResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/fee/debtheaders?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtHeadersV2(_response);
        });
    }

    protected processGetDebtHeadersV2(response: AxiosResponse): Promise<DebtHeaderFeesResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebtHeaderFeesResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebtHeaderFeesResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @return OK
     */
    getDebtDetailV2(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<DebtDetailFeeResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/v2/fee/debtdetail?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtDetailV2(_response);
        });
    }

    protected processGetDebtDetailV2(response: AxiosResponse): Promise<DebtDetailFeeResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebtDetailFeeResponseDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebtDetailFeeResponseDtoListServiceResponse>(null as any);
    }
}

export class KafkaClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Post Premium_DebtGroup_Source
     * @return OK
     */
    premiumdebtgroupsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumdebtgroupsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumdebtgroupsource(_response);
        });
    }

    protected processPremiumdebtgroupsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_DebtHeader_Source
     * @return OK
     */
    premiumdebtheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumdebtheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumdebtheadersource(_response);
        });
    }

    protected processPremiumdebtheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_DebtDetail_Source
     * @return OK
     */
    premiumdebtdetailsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumdebtdetailsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumdebtdetailsource(_response);
        });
    }

    protected processPremiumdebtdetailsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_MatchHeader_Source
     * @return OK
     */
    premiummatchheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiummatchheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiummatchheadersource(_response);
        });
    }

    protected processPremiummatchheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_PaymentApproved_Source
     * @return OK
     */
    premiumpaymentapprovedsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumpaymentapprovedsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumpaymentapprovedsource(_response);
        });
    }

    protected processPremiumpaymentapprovedsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_ReceiveHeader_Source
     * @return OK
     */
    premiumreceiveheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumreceiveheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumreceiveheadersource(_response);
        });
    }

    protected processPremiumreceiveheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_ReceiveDetail_Source
     * @return OK
     */
    premiumreceivedetailsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumreceivedetailsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumreceivedetailsource(_response);
        });
    }

    protected processPremiumreceivedetailsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_RefundApproved_Source
     * @return OK
     */
    premiumrefundapprovedsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumrefundapprovedsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumrefundapprovedsource(_response);
        });
    }

    protected processPremiumrefundapprovedsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_Statement_Premium_Matched_Source
     * @return OK
     */
    premiumstatementpremiummatchedsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumstatementpremiummatchedsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumstatementpremiummatchedsource(_response);
        });
    }

    protected processPremiumstatementpremiummatchedsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_SummaryHeader_Source
     * @return OK
     */
    premiumsummaryheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumsummaryheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumsummaryheadersource(_response);
        });
    }

    protected processPremiumsummaryheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_SummaryFileNo_Source
     * @return OK
     */
    premiumsummaryfilenosource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumsummaryfilenosource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumsummaryfilenosource(_response);
        });
    }

    protected processPremiumsummaryfilenosource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_SummaryDetail_Source
     * @return OK
     */
    premiumsummarydetailsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumsummarydetailsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumsummarydetailsource(_response);
        });
    }

    protected processPremiumsummarydetailsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_TransferHeader_Source
     * @return OK
     */
    premiumtransferheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumtransferheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumtransferheadersource(_response);
        });
    }

    protected processPremiumtransferheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_DirectDebit_TempSummaryDetail_Source
     * @return OK
     */
    premiumdirectdebittempsummarydetailsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumdirectdebittempsummarydetailsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumdirectdebittempsummarydetailsource(_response);
        });
    }

    protected processPremiumdirectdebittempsummarydetailsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_DirectDebit_TempSummaryHeader_Source
     * @return OK
     */
    premiumdirectdebittempsummaryheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumdirectdebittempsummaryheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumdirectdebittempsummaryheadersource(_response);
        });
    }

    protected processPremiumdirectdebittempsummaryheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_DirectLink_SettlementDetail_Source
     * @return OK
     */
    premiumdirectlinksettlementdetailsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumdirectlinksettlementdetailsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumdirectlinksettlementdetailsource(_response);
        });
    }

    protected processPremiumdirectlinksettlementdetailsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_DirectLink_SettlementHeader_Source
     * @return OK
     */
    premiumdirectlinksettlementheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumdirectlinksettlementheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumdirectlinksettlementheadersource(_response);
        });
    }

    protected processPremiumdirectlinksettlementheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_Paygate_SettlementDetail_Source
     * @return OK
     */
    premiumpaygatesettlementdetailsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumpaygatesettlementdetailsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumpaygatesettlementdetailsource(_response);
        });
    }

    protected processPremiumpaygatesettlementdetailsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post Premium_Paygate_SettlementHeader_Source
     * @return OK
     */
    premiumpaygatesettlementheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumpaygatesettlementheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumpaygatesettlementheadersource(_response);
        });
    }

    protected processPremiumpaygatesettlementheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post PremiumStatement_StatementHeader_Source
     * @return OK
     */
    premiumstatementstatementheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumstatementstatementheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumstatementstatementheadersource(_response);
        });
    }

    protected processPremiumstatementstatementheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post PremiumStatement_Statement_Source
     * @return OK
     */
    premiumstatementstatementsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/premiumstatementstatementsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumstatementstatementsource(_response);
        });
    }

    protected processPremiumstatementstatementsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post SSS_TempGroup_Source
     * @return OK
     */
    ssstempgroupsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/ssstempgroupsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSsstempgroupsource(_response);
        });
    }

    protected processSsstempgroupsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post SSS_TempHeader_Source
     * @return OK
     */
    ssstempheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/ssstempheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSsstempheadersource(_response);
        });
    }

    protected processSsstempheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post SSS_TempDetail_Source
     * @return OK
     */
    ssstempdetailsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/ssstempdetailsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSsstempdetailsource(_response);
        });
    }

    protected processSsstempdetailsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post SSS_TempRefundGroup_Source
     * @return OK
     */
    ssstemprefundgroupsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/ssstemprefundgroupsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSsstemprefundgroupsource(_response);
        });
    }

    protected processSsstemprefundgroupsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post SSS_TempRefundHeader_Source
     * @return OK
     */
    ssstemprefundheadersource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/ssstemprefundheadersource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSsstemprefundheadersource(_response);
        });
    }

    protected processSsstemprefundheadersource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post SSS_TempRefundDetail_Source
     * @return OK
     */
    ssstemprefunddetailsource( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Kafka/ssstemprefunddetailsource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSsstemprefunddetailsource(_response);
        });
    }

    protected processSsstemprefunddetailsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ManageBillsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param billNo (optional) 
     * @param ref1 (optional) 
     * @param ref2 (optional) 
     * @return OK
     */
    getBillDetail(billNo?: string | undefined, ref1?: string | undefined, ref2?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetBillDetailDtoListServiceResponse> {
        let url_ = this.baseUrl + "/bill/detail?";
        if (billNo === null)
            throw new Error("The parameter 'billNo' cannot be null.");
        else if (billNo !== undefined)
            url_ += "BillNo=" + encodeURIComponent("" + billNo) + "&";
        if (ref1 === null)
            throw new Error("The parameter 'ref1' cannot be null.");
        else if (ref1 !== undefined)
            url_ += "Ref1=" + encodeURIComponent("" + ref1) + "&";
        if (ref2 === null)
            throw new Error("The parameter 'ref2' cannot be null.");
        else if (ref2 !== undefined)
            url_ += "Ref2=" + encodeURIComponent("" + ref2) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBillDetail(_response);
        });
    }

    protected processGetBillDetail(response: AxiosResponse): Promise<GetBillDetailDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetBillDetailDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBillDetailDtoListServiceResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateStatusBillAndRepair(body?: UpdateStatusBillAndRepairRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<GetBillDetailDtoServiceResponse> {
        let url_ = this.baseUrl + "/bill/update-repair";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateStatusBillAndRepair(_response);
        });
    }

    protected processUpdateStatusBillAndRepair(response: AxiosResponse): Promise<GetBillDetailDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetBillDetailDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBillDetailDtoServiceResponse>(null as any);
    }
}

export class MasterDataClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Get Payment Channel
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    paymentchannel(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/paymentchannel?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPaymentchannel(_response);
        });
    }

    protected processPaymentchannel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Payment Method Type
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    paymentmethodtype(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/paymentmethodtype?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPaymentmethodtype(_response);
        });
    }

    protected processPaymentmethodtype(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Payment Status
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    paymentstatus(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/paymentstatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPaymentstatus(_response);
        });
    }

    protected processPaymentstatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Period Type
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    periodtype(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/periodtype?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPeriodtype(_response);
        });
    }

    protected processPeriodtype(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Receive Type
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    receivetype(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/receivetype?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceivetype(_response);
        });
    }

    protected processReceivetype(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Source Type
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    sourcetype(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/sourcetype?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSourcetype(_response);
        });
    }

    protected processSourcetype(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Summary Header Status
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    summaryheaderstatusGET(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/summaryheaderstatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummaryheaderstatusGET(_response);
        });
    }

    protected processSummaryheaderstatusGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Debt Group Status
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    debtgroupstatus(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/debtgroupstatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtgroupstatus(_response);
        });
    }

    protected processDebtgroupstatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Bank
     * @param shortName (optional) 
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    bank(shortName?: string | undefined, id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/bank?";
        if (shortName === null)
            throw new Error("The parameter 'shortName' cannot be null.");
        else if (shortName !== undefined)
            url_ += "ShortName=" + encodeURIComponent("" + shortName) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBank(_response);
        });
    }

    protected processBank(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Insurance
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    insurrance(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/insurrance?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInsurrance(_response);
        });
    }

    protected processInsurrance(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get RefundCause
     * @return OK
     */
    refundcause( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/refundcause";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefundcause(_response);
        });
    }

    protected processRefundcause(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get SMSDetailStatus
     * @return OK
     */
    smsdetailstatus( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/smsdetailstatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSmsdetailstatus(_response);
        });
    }

    protected processSmsdetailstatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get SMSType
     * @return OK
     */
    smstype( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/smstype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSmstype(_response);
        });
    }

    protected processSmstype(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET DebtGroupReferType
     * @return OK
     */
    debtgrouprefertype( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/debtgrouprefertype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtgrouprefertype(_response);
        });
    }

    protected processDebtgrouprefertype(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET Refund Header Status
     * @return OK
     */
    refundheaderstatus( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/refundheaderstatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefundheaderstatus(_response);
        });
    }

    protected processRefundheaderstatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * PremiumPeriodNow
     * @return OK
     */
    premiumperiodnow( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/premiumperiodnow";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumperiodnow(_response);
        });
    }

    protected processPremiumperiodnow(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * PremiumPeriodNow By DebtGroupReferType
     * @return OK
     */
    premiumperiodnow2(refertypeid: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/masterdata/premiumperiodnow/{refertypeid}";
        if (refertypeid === undefined || refertypeid === null)
            throw new Error("The parameter 'refertypeid' must be defined.");
        url_ = url_.replace("{refertypeid}", encodeURIComponent("" + refertypeid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumperiodnow2(_response);
        });
    }

    protected processPremiumperiodnow2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MasterDataV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Get Payment Channel
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    getPaymentChannelV2(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetPaymentChannelDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/paymentchannel?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaymentChannelV2(_response);
        });
    }

    protected processGetPaymentChannelV2(response: AxiosResponse): Promise<GetPaymentChannelDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetPaymentChannelDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPaymentChannelDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Payment Method Type
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    getPaymentMethodTypeV2(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetPaymentMethodTypeDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/paymentmethodtype?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaymentMethodTypeV2(_response);
        });
    }

    protected processGetPaymentMethodTypeV2(response: AxiosResponse): Promise<GetPaymentMethodTypeDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetPaymentMethodTypeDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPaymentMethodTypeDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Payment Status
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    getPaymentStatusV2(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetPaymentStatusDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/paymentstatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaymentStatusV2(_response);
        });
    }

    protected processGetPaymentStatusV2(response: AxiosResponse): Promise<GetPaymentStatusDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetPaymentStatusDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPaymentStatusDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Period Type
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    getPeriodTypeV2(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetPeriodTypeDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/periodtype?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPeriodTypeV2(_response);
        });
    }

    protected processGetPeriodTypeV2(response: AxiosResponse): Promise<GetPeriodTypeDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetPeriodTypeDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPeriodTypeDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Receive Type
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    getReceiveTypeV2(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetReceiveTypeDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/receivetype?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceiveTypeV2(_response);
        });
    }

    protected processGetReceiveTypeV2(response: AxiosResponse): Promise<GetReceiveTypeDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReceiveTypeDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReceiveTypeDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Source Type
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    getSourceTypeV2(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetSourceTypeDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/sourcetype?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSourceTypeV2(_response);
        });
    }

    protected processGetSourceTypeV2(response: AxiosResponse): Promise<GetSourceTypeDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetSourceTypeDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetSourceTypeDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Summary Header Status
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    getSummaryHeaderStatusV2(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetSummaryHeaderStatusDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/summaryheaderstatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummaryHeaderStatusV2(_response);
        });
    }

    protected processGetSummaryHeaderStatusV2(response: AxiosResponse): Promise<GetSummaryHeaderStatusDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetSummaryHeaderStatusDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetSummaryHeaderStatusDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Debt Group Status
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    getDebtGroupStatusV2(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetDebtGroupStatusDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/debtgroupstatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtGroupStatusV2(_response);
        });
    }

    protected processGetDebtGroupStatusV2(response: AxiosResponse): Promise<GetDebtGroupStatusDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDebtGroupStatusDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDebtGroupStatusDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Bank
     * @param shortName (optional) 
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    getBankV2(shortName?: string | undefined, id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetBankDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/bank?";
        if (shortName === null)
            throw new Error("The parameter 'shortName' cannot be null.");
        else if (shortName !== undefined)
            url_ += "ShortName=" + encodeURIComponent("" + shortName) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBankV2(_response);
        });
    }

    protected processGetBankV2(response: AxiosResponse): Promise<GetBankDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetBankDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBankDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Insurance
     * @param id (optional) 
     * @param name (optional) 
     * @return OK
     */
    getInsuranceV2(id?: number | undefined, name?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetInsuranceDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/insurrance?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInsuranceV2(_response);
        });
    }

    protected processGetInsuranceV2(response: AxiosResponse): Promise<GetInsuranceDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetInsuranceDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetInsuranceDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get RefundCause
     * @return OK
     */
    getRefundCauseV2( cancelToken?: CancelToken | undefined): Promise<GetRefundCauseDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/refundcause";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRefundCauseV2(_response);
        });
    }

    protected processGetRefundCauseV2(response: AxiosResponse): Promise<GetRefundCauseDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetRefundCauseDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRefundCauseDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get SMSDetailStatus
     * @return OK
     */
    getSMSDetailStatusV2( cancelToken?: CancelToken | undefined): Promise<SMSDetailStatusDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/smsdetailstatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSMSDetailStatusV2(_response);
        });
    }

    protected processGetSMSDetailStatusV2(response: AxiosResponse): Promise<SMSDetailStatusDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SMSDetailStatusDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SMSDetailStatusDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get SMSType
     * @return OK
     */
    getSMSTypeV2( cancelToken?: CancelToken | undefined): Promise<SMSTypeDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/smstype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSMSTypeV2(_response);
        });
    }

    protected processGetSMSTypeV2(response: AxiosResponse): Promise<SMSTypeDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SMSTypeDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SMSTypeDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * GET DebtGroupReferType
     * @return OK
     */
    getDebtGroupReferTypeV2( cancelToken?: CancelToken | undefined): Promise<DebtGroupReferTypeDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/debtgrouprefertype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtGroupReferTypeV2(_response);
        });
    }

    protected processGetDebtGroupReferTypeV2(response: AxiosResponse): Promise<DebtGroupReferTypeDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebtGroupReferTypeDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebtGroupReferTypeDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * GET Refund Header Status
     * @return OK
     */
    getRefundHeaderStatusV2( cancelToken?: CancelToken | undefined): Promise<RefundHeaderStatusDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/refundheaderstatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRefundHeaderStatusV2(_response);
        });
    }

    protected processGetRefundHeaderStatusV2(response: AxiosResponse): Promise<RefundHeaderStatusDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<RefundHeaderStatusDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundHeaderStatusDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * PremiumPeriodNow
     * @return OK
     */
    premiumPeriodNowV2( cancelToken?: CancelToken | undefined): Promise<Usp_GetDebtPeriodResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/premiumperiodnow";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumPeriodNowV2(_response);
        });
    }

    protected processPremiumPeriodNowV2(response: AxiosResponse): Promise<Usp_GetDebtPeriodResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_GetDebtPeriodResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_GetDebtPeriodResultListServiceResponse>(null as any);
    }

    /**
     * PremiumPeriodNow By DebtGroupReferType
     * @return OK
     */
    premiumPeriodNowByDebtGroupReferTypeV2(refertypeid: number, cancelToken?: CancelToken | undefined): Promise<Usp_GetDebtPeriodResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/masterdata/premiumperiodnow/{refertypeid}";
        if (refertypeid === undefined || refertypeid === null)
            throw new Error("The parameter 'refertypeid' must be defined.");
        url_ = url_.replace("{refertypeid}", encodeURIComponent("" + refertypeid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumPeriodNowByDebtGroupReferTypeV2(_response);
        });
    }

    protected processPremiumPeriodNowByDebtGroupReferTypeV2(response: AxiosResponse): Promise<Usp_GetDebtPeriodResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_GetDebtPeriodResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_GetDebtPeriodResultListServiceResponse>(null as any);
    }
}

export class MotorClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param productNameList (optional) 
     * @param productGroupNameList (optional) 
     * @param paymentStatusIdList (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param b (optional) 
     * @param iN (optional) 
     * @param applicationCode (optional) 
     * @param payerName (optional) 
     * @param custName (optional) 
     * @param viewPoint (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtMotorPeriods(expireFrom: dayjs.Dayjs, expireTo: dayjs.Dayjs, productNameList?: string | undefined, productGroupNameList?: string | undefined, paymentStatusIdList?: string | undefined, debtGroupReferTypeId?: number | undefined, b?: string | undefined, iN?: string | undefined, applicationCode?: string | undefined, payerName?: string | undefined, custName?: string | undefined, viewPoint?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DebtMotorPeriods_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/motor/getdebtmotorperiods?";
        if (expireFrom === undefined || expireFrom === null)
            throw new Error("The parameter 'expireFrom' must be defined and cannot be null.");
        else
            url_ += "ExpireFrom=" + encodeURIComponent(expireFrom ? "" + expireFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (expireTo === undefined || expireTo === null)
            throw new Error("The parameter 'expireTo' must be defined and cannot be null.");
        else
            url_ += "ExpireTo=" + encodeURIComponent(expireTo ? "" + expireTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productNameList === null)
            throw new Error("The parameter 'productNameList' cannot be null.");
        else if (productNameList !== undefined)
            url_ += "ProductNameList=" + encodeURIComponent("" + productNameList) + "&";
        if (productGroupNameList === null)
            throw new Error("The parameter 'productGroupNameList' cannot be null.");
        else if (productGroupNameList !== undefined)
            url_ += "ProductGroupNameList=" + encodeURIComponent("" + productGroupNameList) + "&";
        if (paymentStatusIdList === null)
            throw new Error("The parameter 'paymentStatusIdList' cannot be null.");
        else if (paymentStatusIdList !== undefined)
            url_ += "PaymentStatusIdList=" + encodeURIComponent("" + paymentStatusIdList) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (iN === null)
            throw new Error("The parameter 'iN' cannot be null.");
        else if (iN !== undefined)
            url_ += "IN=" + encodeURIComponent("" + iN) + "&";
        if (applicationCode === null)
            throw new Error("The parameter 'applicationCode' cannot be null.");
        else if (applicationCode !== undefined)
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (custName === null)
            throw new Error("The parameter 'custName' cannot be null.");
        else if (custName !== undefined)
            url_ += "CustName=" + encodeURIComponent("" + custName) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtMotorPeriods(_response);
        });
    }

    protected processGetDebtMotorPeriods(response: AxiosResponse): Promise<Usp_DebtMotorPeriods_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtMotorPeriods_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtMotorPeriods_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param searchIndex (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param paymentChannelId (optional) 
     * @param branchId (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    getReportDebtCollectMotor(expireFrom: dayjs.Dayjs, expireTo: dayjs.Dayjs, searchText?: string | undefined, searchIndex?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, paymentChannelId?: string | undefined, branchId?: string | undefined, page?: number | undefined, recordsPerPage?: number | undefined, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportDebtCollectMotorResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/motor/report/debtcollectmotor?";
        if (expireFrom === undefined || expireFrom === null)
            throw new Error("The parameter 'expireFrom' must be defined and cannot be null.");
        else
            url_ += "ExpireFrom=" + encodeURIComponent(expireFrom ? "" + expireFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (expireTo === undefined || expireTo === null)
            throw new Error("The parameter 'expireTo' must be defined and cannot be null.");
        else
            url_ += "ExpireTo=" + encodeURIComponent(expireTo ? "" + expireTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentChannelId === null)
            throw new Error("The parameter 'paymentChannelId' cannot be null.");
        else if (paymentChannelId !== undefined)
            url_ += "PaymentChannelId=" + encodeURIComponent("" + paymentChannelId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtCollectMotor(_response);
        });
    }

    protected processGetReportDebtCollectMotor(response: AxiosResponse): Promise<GetReportDebtCollectMotorResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportDebtCollectMotorResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportDebtCollectMotorResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    downloadReportDebtCollectMotor(body?: ReportDebtCollectMotorRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/motor/report/debtcollectmotor/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportDebtCollectMotor(_response);
        });
    }

    protected processDownloadReportDebtCollectMotor(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PAClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param debtHeaderId (optional) 
     * @param bill (optional) 
     * @param summaryDetailId (optional) 
     * @param summaryDetailCode (optional) 
     * @return OK
     */
    billpayment(debtHeaderId?: string | undefined, bill?: string | undefined, summaryDetailId?: string | undefined, summaryDetailCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<BillPaymentResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/pa/billpayment?";
        if (debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' cannot be null.");
        else if (debtHeaderId !== undefined)
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (bill === null)
            throw new Error("The parameter 'bill' cannot be null.");
        else if (bill !== undefined)
            url_ += "Bill=" + encodeURIComponent("" + bill) + "&";
        if (summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' cannot be null.");
        else if (summaryDetailId !== undefined)
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (summaryDetailCode === null)
            throw new Error("The parameter 'summaryDetailCode' cannot be null.");
        else if (summaryDetailCode !== undefined)
            url_ += "SummaryDetailCode=" + encodeURIComponent("" + summaryDetailCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillpayment(_response);
        });
    }

    protected processBillpayment(response: AxiosResponse): Promise<BillPaymentResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<BillPaymentResponseDtoServiceResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillPaymentResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param summaryDetailId (optional) 
     * @param summaryDetailCode (optional) 
     * @return OK
     */
    payslip(summaryDetailId?: string | undefined, summaryDetailCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaySlipResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/pa/payslip?";
        if (summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' cannot be null.");
        else if (summaryDetailId !== undefined)
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (summaryDetailCode === null)
            throw new Error("The parameter 'summaryDetailCode' cannot be null.");
        else if (summaryDetailCode !== undefined)
            url_ += "SummaryDetailCode=" + encodeURIComponent("" + summaryDetailCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPayslip(_response);
        });
    }

    protected processPayslip(response: AxiosResponse): Promise<PaySlipResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<PaySlipResponseDtoServiceResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaySlipResponseDtoServiceResponse>(null as any);
    }

    /**
     * @return OK
     */
    summarydetail(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<SummaryDetailResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/pa/summarydetail?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummarydetail(_response);
        });
    }

    protected processSummarydetail(response: AxiosResponse): Promise<SummaryDetailResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SummaryDetailResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SummaryDetailResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param paymentStatusId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debtheaders2(applicationCode: string, paymentStatusId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<DebtHeadersResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/pa/debtheaders?";
        if (applicationCode === undefined || applicationCode === null)
            throw new Error("The parameter 'applicationCode' must be defined and cannot be null.");
        else
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtheaders2(_response);
        });
    }

    protected processDebtheaders2(response: AxiosResponse): Promise<DebtHeadersResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebtHeadersResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebtHeadersResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    paymenthistory(applicationCode: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<PaymentHistoryReponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/pa/paymenthistory?";
        if (applicationCode === undefined || applicationCode === null)
            throw new Error("The parameter 'applicationCode' must be defined and cannot be null.");
        else
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPaymenthistory(_response);
        });
    }

    protected processPaymenthistory(response: AxiosResponse): Promise<PaymentHistoryReponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<PaymentHistoryReponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentHistoryReponseDtoListServiceResponseWithPagination>(null as any);
    }
}

export class PAReportClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param schoolYear (optional) 
     * @param branchId (optional) 
     * @param paymentStatusIdList (optional) 
     * @param paymentMethodTypeIdList (optional) 
     * @param searchTypeId (optional) 
     * @param searchDetail (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    newapppremiumpareport(schoolYear?: number | undefined, branchId?: number | undefined, paymentStatusIdList?: string | undefined, paymentMethodTypeIdList?: string | undefined, searchTypeId?: number | undefined, searchDetail?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_ReportNewAppPAPremium_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/pareport/newapppremiumpareport?";
        if (schoolYear === null)
            throw new Error("The parameter 'schoolYear' cannot be null.");
        else if (schoolYear !== undefined)
            url_ += "SchoolYear=" + encodeURIComponent("" + schoolYear) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (paymentStatusIdList === null)
            throw new Error("The parameter 'paymentStatusIdList' cannot be null.");
        else if (paymentStatusIdList !== undefined)
            url_ += "PaymentStatusIdList=" + encodeURIComponent("" + paymentStatusIdList) + "&";
        if (paymentMethodTypeIdList === null)
            throw new Error("The parameter 'paymentMethodTypeIdList' cannot be null.");
        else if (paymentMethodTypeIdList !== undefined)
            url_ += "PaymentMethodTypeIdList=" + encodeURIComponent("" + paymentMethodTypeIdList) + "&";
        if (searchTypeId === null)
            throw new Error("The parameter 'searchTypeId' cannot be null.");
        else if (searchTypeId !== undefined)
            url_ += "SearchTypeId=" + encodeURIComponent("" + searchTypeId) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewapppremiumpareport(_response);
        });
    }

    protected processNewapppremiumpareport(response: AxiosResponse): Promise<Usp_ReportNewAppPAPremium_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_ReportNewAppPAPremium_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_ReportNewAppPAPremium_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param schoolYear (optional) 
     * @param branchId (optional) 
     * @param paymentStatusIdList (optional) 
     * @param paymentMethodTypeIdList (optional) 
     * @param searchTypeId (optional) 
     * @param searchDetail (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    downloadnewapppremiumpareport(schoolYear?: number | undefined, branchId?: number | undefined, paymentStatusIdList?: string | undefined, paymentMethodTypeIdList?: string | undefined, searchTypeId?: number | undefined, searchDetail?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/pareport/downloadnewapppremiumpareport?";
        if (schoolYear === null)
            throw new Error("The parameter 'schoolYear' cannot be null.");
        else if (schoolYear !== undefined)
            url_ += "SchoolYear=" + encodeURIComponent("" + schoolYear) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (paymentStatusIdList === null)
            throw new Error("The parameter 'paymentStatusIdList' cannot be null.");
        else if (paymentStatusIdList !== undefined)
            url_ += "PaymentStatusIdList=" + encodeURIComponent("" + paymentStatusIdList) + "&";
        if (paymentMethodTypeIdList === null)
            throw new Error("The parameter 'paymentMethodTypeIdList' cannot be null.");
        else if (paymentMethodTypeIdList !== undefined)
            url_ += "PaymentMethodTypeIdList=" + encodeURIComponent("" + paymentMethodTypeIdList) + "&";
        if (searchTypeId === null)
            throw new Error("The parameter 'searchTypeId' cannot be null.");
        else if (searchTypeId !== undefined)
            url_ += "SearchTypeId=" + encodeURIComponent("" + searchTypeId) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadnewapppremiumpareport(_response);
        });
    }

    protected processDownloadnewapppremiumpareport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    downloadReportNewAppPAPaymentDate(body?: ReportNewAppPAPaymentDateRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/pareport/reportnewapppapaymentdate/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportNewAppPAPaymentDate(_response);
        });
    }

    protected processDownloadReportNewAppPAPaymentDate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PAReportV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param schoolYear (optional) 
     * @param branchId (optional) 
     * @param paymentStatusIdList (optional) 
     * @param paymentMethodTypeIdList (optional) 
     * @param searchTypeId (optional) 
     * @param searchDetail (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    newAppPremiumPAReportV2(schoolYear?: number | undefined, branchId?: number | undefined, paymentStatusIdList?: string | undefined, paymentMethodTypeIdList?: string | undefined, searchTypeId?: number | undefined, searchDetail?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_ReportNewAppPAPremium_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/pareport/newapppremiumpareport?";
        if (schoolYear === null)
            throw new Error("The parameter 'schoolYear' cannot be null.");
        else if (schoolYear !== undefined)
            url_ += "SchoolYear=" + encodeURIComponent("" + schoolYear) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (paymentStatusIdList === null)
            throw new Error("The parameter 'paymentStatusIdList' cannot be null.");
        else if (paymentStatusIdList !== undefined)
            url_ += "PaymentStatusIdList=" + encodeURIComponent("" + paymentStatusIdList) + "&";
        if (paymentMethodTypeIdList === null)
            throw new Error("The parameter 'paymentMethodTypeIdList' cannot be null.");
        else if (paymentMethodTypeIdList !== undefined)
            url_ += "PaymentMethodTypeIdList=" + encodeURIComponent("" + paymentMethodTypeIdList) + "&";
        if (searchTypeId === null)
            throw new Error("The parameter 'searchTypeId' cannot be null.");
        else if (searchTypeId !== undefined)
            url_ += "SearchTypeId=" + encodeURIComponent("" + searchTypeId) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewAppPremiumPAReportV2(_response);
        });
    }

    protected processNewAppPremiumPAReportV2(response: AxiosResponse): Promise<Usp_ReportNewAppPAPremium_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_ReportNewAppPAPremium_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_ReportNewAppPAPremium_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param schoolYear (optional) 
     * @param branchId (optional) 
     * @param paymentStatusIdList (optional) 
     * @param paymentMethodTypeIdList (optional) 
     * @param searchTypeId (optional) 
     * @param searchDetail (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    downloadNewAppPremiumPAReportV2(schoolYear?: number | undefined, branchId?: number | undefined, paymentStatusIdList?: string | undefined, paymentMethodTypeIdList?: string | undefined, searchTypeId?: number | undefined, searchDetail?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/pareport/downloadnewapppremiumpareport?";
        if (schoolYear === null)
            throw new Error("The parameter 'schoolYear' cannot be null.");
        else if (schoolYear !== undefined)
            url_ += "SchoolYear=" + encodeURIComponent("" + schoolYear) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (paymentStatusIdList === null)
            throw new Error("The parameter 'paymentStatusIdList' cannot be null.");
        else if (paymentStatusIdList !== undefined)
            url_ += "PaymentStatusIdList=" + encodeURIComponent("" + paymentStatusIdList) + "&";
        if (paymentMethodTypeIdList === null)
            throw new Error("The parameter 'paymentMethodTypeIdList' cannot be null.");
        else if (paymentMethodTypeIdList !== undefined)
            url_ += "PaymentMethodTypeIdList=" + encodeURIComponent("" + paymentMethodTypeIdList) + "&";
        if (searchTypeId === null)
            throw new Error("The parameter 'searchTypeId' cannot be null.");
        else if (searchTypeId !== undefined)
            url_ += "SearchTypeId=" + encodeURIComponent("" + searchTypeId) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadNewAppPremiumPAReportV2(_response);
        });
    }

    protected processDownloadNewAppPremiumPAReportV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PAV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param debtHeaderId (optional) 
     * @param bill (optional) 
     * @param summaryDetailId (optional) 
     * @param summaryDetailCode (optional) 
     * @return OK
     */
    pAGetBillPaymentV2(debtHeaderId?: string | undefined, bill?: string | undefined, summaryDetailId?: string | undefined, summaryDetailCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<BillPaymentResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/pa/billpayment?";
        if (debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' cannot be null.");
        else if (debtHeaderId !== undefined)
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (bill === null)
            throw new Error("The parameter 'bill' cannot be null.");
        else if (bill !== undefined)
            url_ += "Bill=" + encodeURIComponent("" + bill) + "&";
        if (summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' cannot be null.");
        else if (summaryDetailId !== undefined)
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (summaryDetailCode === null)
            throw new Error("The parameter 'summaryDetailCode' cannot be null.");
        else if (summaryDetailCode !== undefined)
            url_ += "SummaryDetailCode=" + encodeURIComponent("" + summaryDetailCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPAGetBillPaymentV2(_response);
        });
    }

    protected processPAGetBillPaymentV2(response: AxiosResponse): Promise<BillPaymentResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<BillPaymentResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillPaymentResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param summaryDetailId (optional) 
     * @param summaryDetailCode (optional) 
     * @return OK
     */
    pAGetPaySlipV2(summaryDetailId?: string | undefined, summaryDetailCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaySlipResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/pa/payslip?";
        if (summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' cannot be null.");
        else if (summaryDetailId !== undefined)
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (summaryDetailCode === null)
            throw new Error("The parameter 'summaryDetailCode' cannot be null.");
        else if (summaryDetailCode !== undefined)
            url_ += "SummaryDetailCode=" + encodeURIComponent("" + summaryDetailCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPAGetPaySlipV2(_response);
        });
    }

    protected processPAGetPaySlipV2(response: AxiosResponse): Promise<PaySlipResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<PaySlipResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaySlipResponseDtoServiceResponse>(null as any);
    }

    /**
     * @return OK
     */
    pAGetSummaryDetailV2(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<SummaryDetailResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/pa/summarydetail?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPAGetSummaryDetailV2(_response);
        });
    }

    protected processPAGetSummaryDetailV2(response: AxiosResponse): Promise<SummaryDetailResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SummaryDetailResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SummaryDetailResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param paymentStatusId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    pAGetDebtHeadersV2(applicationCode: string, paymentStatusId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<DebtHeadersResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/pa/debtheaders?";
        if (applicationCode === undefined || applicationCode === null)
            throw new Error("The parameter 'applicationCode' must be defined and cannot be null.");
        else
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPAGetDebtHeadersV2(_response);
        });
    }

    protected processPAGetDebtHeadersV2(response: AxiosResponse): Promise<DebtHeadersResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebtHeadersResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebtHeadersResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    pAPaymentHistoryV2(applicationCode: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<PaymentHistoryReponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/pa/paymenthistory?";
        if (applicationCode === undefined || applicationCode === null)
            throw new Error("The parameter 'applicationCode' must be defined and cannot be null.");
        else
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPAPaymentHistoryV2(_response);
        });
    }

    protected processPAPaymentHistoryV2(response: AxiosResponse): Promise<PaymentHistoryReponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<PaymentHistoryReponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentHistoryReponseDtoListServiceResponseWithPagination>(null as any);
    }
}

export class PremiumClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Get BillPayment // สำหรับลูกค้า ไม่มี Authorize
     * @return OK
     */
    billpayment2(summaryDetailCode: string, cancelToken?: CancelToken | undefined): Promise<GetBillPaymentDto_ResponseServiceResponse> {
        let url_ = this.baseUrl + "/premium/billpayment/{summaryDetailCode}";
        if (summaryDetailCode === undefined || summaryDetailCode === null)
            throw new Error("The parameter 'summaryDetailCode' must be defined.");
        url_ = url_.replace("{summaryDetailCode}", encodeURIComponent("" + summaryDetailCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillpayment2(_response);
        });
    }

    protected processBillpayment2(response: AxiosResponse): Promise<GetBillPaymentDto_ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBillPaymentDto_ResponseServiceResponse>(null as any);
    }

    /**
     * Get Pay Slip  // สำหรับลูกค้า ไม่มี Authorize
     * @return OK
     */
    payslip2(summaryDetailCode: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/payslip/{summaryDetailCode}";
        if (summaryDetailCode === undefined || summaryDetailCode === null)
            throw new Error("The parameter 'summaryDetailCode' must be defined.");
        url_ = url_.replace("{summaryDetailCode}", encodeURIComponent("" + summaryDetailCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPayslip2(_response);
        });
    }

    protected processPayslip2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Debt
     * @param billNo (optional) 
     * @return OK
     */
    debt(debtHeaderId: string, billNo?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debt?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (billNo === null)
            throw new Error("The parameter 'billNo' cannot be null.");
        else if (billNo !== undefined)
            url_ += "BillNo=" + encodeURIComponent("" + billNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebt(_response);
        });
    }

    protected processDebt(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get BillPayment by Debt header
     * @return OK
     */
    billpaymentbydebtheader(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/premium/billpaymentbydebtheader/{debtHeaderId}";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined.");
        url_ = url_.replace("{debtHeaderId}", encodeURIComponent("" + debtHeaderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillpaymentbydebtheader(_response);
        });
    }

    protected processBillpaymentbydebtheader(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get GenBillingAndPaySlip
     * @return OK
     */
    genbillingandpayslip(billing: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/genbillingandpayslip/{billing}";
        if (billing === undefined || billing === null)
            throw new Error("The parameter 'billing' must be defined.");
        url_ = url_.replace("{billing}", encodeURIComponent("" + billing));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenbillingandpayslip(_response);
        });
    }

    protected processGenbillingandpayslip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Summary FileNo To Excel
     * @param summaryFileNoId (optional) 
     * @return OK
     */
    summaryfilenotoexcel(summaryHeaderId: string, summaryFileNoId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/summaryfilenotoexcel?";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined and cannot be null.");
        else
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        if (summaryFileNoId === null)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else if (summaryFileNoId !== undefined)
            url_ += "SummaryFileNoId=" + encodeURIComponent("" + summaryFileNoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummaryfilenotoexcel(_response);
        });
    }

    protected processSummaryfilenotoexcel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * SummaryFileNoExportFile
     * @param summaryFileNoId (optional) 
     * @return OK
     */
    summaryfilenoexportfile(summaryHeaderId: string, summaryFileNoId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/summaryfilenoexportfile?";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined and cannot be null.");
        else
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        if (summaryFileNoId === null)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else if (summaryFileNoId !== undefined)
            url_ += "SummaryFileNoId=" + encodeURIComponent("" + summaryFileNoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummaryfilenoexportfile(_response);
        });
    }

    protected processSummaryfilenoexportfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Summary FileNo Error To Excel
     * @return OK
     */
    summaryfilenoerror(tempId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/summaryfilenoerror?";
        if (tempId === undefined || tempId === null)
            throw new Error("The parameter 'tempId' must be defined and cannot be null.");
        else
            url_ += "tempId=" + encodeURIComponent("" + tempId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummaryfilenoerror(_response);
        });
    }

    protected processSummaryfilenoerror(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Summary Insert
     * @param body (optional) 
     * @return OK
     */
    summary(body?: SummaryInsertDto_Request | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/summary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummary(_response);
        });
    }

    protected processSummary(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Summary Header Status Update
     * @return OK
     */
    summaryheaderstatusPOST(summaryHeaderId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/summaryheaderstatus?";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined and cannot be null.");
        else
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummaryheaderstatusPOST(_response);
        });
    }

    protected processSummaryheaderstatusPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Temp Result For Bank Manual
     * @param summaryFileNoId (optional) 
     * @param bankId (optional) 
     * @param transactionDateTime (optional) 
     * @param file (optional) 
     * @return OK
     */
    tempresultforbankmanual(summaryFileNoId?: string | undefined, bankId?: number | undefined, transactionDateTime?: dayjs.Dayjs | undefined, file?: FileParameter | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/upload/tempresultforbankmanual";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (summaryFileNoId === null || summaryFileNoId === undefined)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else
            content_.append("SummaryFileNoId", summaryFileNoId.toString());
        if (bankId === null || bankId === undefined)
            throw new Error("The parameter 'bankId' cannot be null.");
        else
            content_.append("BankId", bankId.toString());
        if (transactionDateTime === null || transactionDateTime === undefined)
            throw new Error("The parameter 'transactionDateTime' cannot be null.");
        else
            content_.append("TransactionDateTime", transactionDateTime.toJSON());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempresultforbankmanual(_response);
        });
    }

    protected processTempresultforbankmanual(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * TempResultForBankManualFormatBank
     * @param summaryFileNoId (optional) 
     * @param bankId (optional) 
     * @param transactionDateTime (optional) 
     * @param file (optional) 
     * @return OK
     */
    tempresultforbankmanualformatbank(summaryFileNoId?: string | undefined, bankId?: number | undefined, transactionDateTime?: dayjs.Dayjs | undefined, file?: FileParameter | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/upload/tempresultforbankmanualformatbank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (summaryFileNoId === null || summaryFileNoId === undefined)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else
            content_.append("SummaryFileNoId", summaryFileNoId.toString());
        if (bankId === null || bankId === undefined)
            throw new Error("The parameter 'bankId' cannot be null.");
        else
            content_.append("BankId", bankId.toString());
        if (transactionDateTime === null || transactionDateTime === undefined)
            throw new Error("The parameter 'transactionDateTime' cannot be null.");
        else
            content_.append("TransactionDateTime", transactionDateTime.toJSON());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempresultforbankmanualformatbank(_response);
        });
    }

    protected processTempresultforbankmanualformatbank(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Temp Result To Summary For Bank Manual Update
     * @param tempId (optional) 
     * @return OK
     */
    tempresulttosummaryforbankmanualupdate(tempId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/tempresulttosummaryforbankmanualupdate?";
        if (tempId === null)
            throw new Error("The parameter 'tempId' cannot be null.");
        else if (tempId !== undefined)
            url_ += "tempId=" + encodeURIComponent("" + tempId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempresulttosummaryforbankmanualupdate(_response);
        });
    }

    protected processTempresulttosummaryforbankmanualupdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get DebtGroupConfirmToSummarys
     * @param searchText (optional) 
     * @param debtGroupCode (optional) 
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param debtGroupStatusListId (optional) 
     * @param debtGroupReferTypeListId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debtgroupconfirmtosummarys(searchText?: string | undefined, debtGroupCode?: string | undefined, dateFrom?: dayjs.Dayjs | undefined, dateTo?: dayjs.Dayjs | undefined, debtGroupStatusListId?: string | undefined, debtGroupReferTypeListId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtgroupconfirmtosummarys?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (debtGroupCode === null)
            throw new Error("The parameter 'debtGroupCode' cannot be null.");
        else if (debtGroupCode !== undefined)
            url_ += "DebtGroupCode=" + encodeURIComponent("" + debtGroupCode) + "&";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupStatusListId === null)
            throw new Error("The parameter 'debtGroupStatusListId' cannot be null.");
        else if (debtGroupStatusListId !== undefined)
            url_ += "DebtGroupStatusListId=" + encodeURIComponent("" + debtGroupStatusListId) + "&";
        if (debtGroupReferTypeListId === null)
            throw new Error("The parameter 'debtGroupReferTypeListId' cannot be null.");
        else if (debtGroupReferTypeListId !== undefined)
            url_ += "DebtGroupReferTypeListId=" + encodeURIComponent("" + debtGroupReferTypeListId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtgroupconfirmtosummarys(_response);
        });
    }

    protected processDebtgroupconfirmtosummarys(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get DebtDetailConfirmToSummarys
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debtdetailconfirmtosummarys(debtGroupId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtdetailconfirmtosummarys?";
        if (debtGroupId === undefined || debtGroupId === null)
            throw new Error("The parameter 'debtGroupId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupId=" + encodeURIComponent("" + debtGroupId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtdetailconfirmtosummarys(_response);
        });
    }

    protected processDebtdetailconfirmtosummarys(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Batchs
     * @param searchDetail (optional) 
     * @param debtGroupCode (optional) 
     * @param summaryHeaderCode (optional) 
     * @param payableDateFrom (optional) 
     * @param payableDateTo (optional) 
     * @param bankId (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param sourceTypeId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    batchs(searchDetail?: string | undefined, debtGroupCode?: string | undefined, summaryHeaderCode?: string | undefined, payableDateFrom?: dayjs.Dayjs | undefined, payableDateTo?: dayjs.Dayjs | undefined, bankId?: string | undefined, summaryHeaderStatusId?: string | undefined, sourceTypeId?: number | undefined, debtGroupReferTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/batchs?";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (debtGroupCode === null)
            throw new Error("The parameter 'debtGroupCode' cannot be null.");
        else if (debtGroupCode !== undefined)
            url_ += "DebtGroupCode=" + encodeURIComponent("" + debtGroupCode) + "&";
        if (summaryHeaderCode === null)
            throw new Error("The parameter 'summaryHeaderCode' cannot be null.");
        else if (summaryHeaderCode !== undefined)
            url_ += "SummaryHeaderCode=" + encodeURIComponent("" + summaryHeaderCode) + "&";
        if (payableDateFrom === null)
            throw new Error("The parameter 'payableDateFrom' cannot be null.");
        else if (payableDateFrom !== undefined)
            url_ += "PayableDateFrom=" + encodeURIComponent(payableDateFrom ? "" + payableDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payableDateTo === null)
            throw new Error("The parameter 'payableDateTo' cannot be null.");
        else if (payableDateTo !== undefined)
            url_ += "PayableDateTo=" + encodeURIComponent(payableDateTo ? "" + payableDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (sourceTypeId === null)
            throw new Error("The parameter 'sourceTypeId' cannot be null.");
        else if (sourceTypeId !== undefined)
            url_ += "SourceTypeId=" + encodeURIComponent("" + sourceTypeId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchs(_response);
        });
    }

    protected processBatchs(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get All Batch Files
     * @param summaryHeaderId (optional) 
     * @param summaryFileNoId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    allbatchfiles(summaryHeaderId?: string | undefined, summaryFileNoId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/allbatchfiles?";
        if (summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' cannot be null.");
        else if (summaryHeaderId !== undefined)
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        if (summaryFileNoId === null)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else if (summaryFileNoId !== undefined)
            url_ += "SummaryFileNoId=" + encodeURIComponent("" + summaryFileNoId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAllbatchfiles(_response);
        });
    }

    protected processAllbatchfiles(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Batch Details
     * @param searchDetail (optional) 
     * @param summaryHeaderId (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param summaryFileNoId (optional) 
     * @param isSucceed (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    batchdetails(searchDetail?: string | undefined, summaryHeaderId?: string | undefined, summaryHeaderStatusId?: string | undefined, summaryFileNoId?: string | undefined, isSucceed?: boolean | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/batchdetails?";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' cannot be null.");
        else if (summaryHeaderId !== undefined)
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (summaryFileNoId === null)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else if (summaryFileNoId !== undefined)
            url_ += "SummaryFileNoId=" + encodeURIComponent("" + summaryFileNoId) + "&";
        if (isSucceed === null)
            throw new Error("The parameter 'isSucceed' cannot be null.");
        else if (isSucceed !== undefined)
            url_ += "IsSucceed=" + encodeURIComponent("" + isSucceed) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchdetails(_response);
        });
    }

    protected processBatchdetails(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET SummaryDetailXRefDebt
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    summarydetailxrefdebt(summaryDetailId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/summarydetailxrefdebt?";
        if (summaryDetailId === undefined || summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' must be defined and cannot be null.");
        else
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummarydetailxrefdebt(_response);
        });
    }

    protected processSummarydetailxrefdebt(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Temp Result For Bank Manual Preview
     * @param tempId (optional) 
     * @return OK
     */
    tempresultforbankmanualpreview(tempId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/tempresultforbankmanualpreview?";
        if (tempId === null)
            throw new Error("The parameter 'tempId' cannot be null.");
        else if (tempId !== undefined)
            url_ += "tempId=" + encodeURIComponent("" + tempId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempresultforbankmanualpreview(_response);
        });
    }

    protected processTempresultforbankmanualpreview(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get CountResultForBankManual
     * @return OK
     */
    tempId(tempId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/tempId/{tempId}";
        if (tempId === undefined || tempId === null)
            throw new Error("The parameter 'tempId' must be defined.");
        url_ = url_.replace("{tempId}", encodeURIComponent("" + tempId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempId(_response);
        });
    }

    protected processTempId(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Debts
     * @param searchDetail (optional) 
     * @param payablePeriodFromStart (optional) 
     * @param payablePeriodFromEnd (optional) 
     * @param payablePeriodToStart (optional) 
     * @param payablePeriodToEnd (optional) 
     * @param productName (optional) 
     * @param productGruopName (optional) 
     * @param paymentStatusId (optional) 
     * @param transactionDatetimeStart (optional) 
     * @param transactionDatetimeEnd (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debts(searchDetail?: string | undefined, payablePeriodFromStart?: dayjs.Dayjs | undefined, payablePeriodFromEnd?: dayjs.Dayjs | undefined, payablePeriodToStart?: dayjs.Dayjs | undefined, payablePeriodToEnd?: dayjs.Dayjs | undefined, productName?: string | undefined, productGruopName?: string | undefined, paymentStatusId?: string | undefined, transactionDatetimeStart?: dayjs.Dayjs | undefined, transactionDatetimeEnd?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debts?";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (payablePeriodFromStart === null)
            throw new Error("The parameter 'payablePeriodFromStart' cannot be null.");
        else if (payablePeriodFromStart !== undefined)
            url_ += "PayablePeriodFromStart=" + encodeURIComponent(payablePeriodFromStart ? "" + payablePeriodFromStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodFromEnd === null)
            throw new Error("The parameter 'payablePeriodFromEnd' cannot be null.");
        else if (payablePeriodFromEnd !== undefined)
            url_ += "PayablePeriodFromEnd=" + encodeURIComponent(payablePeriodFromEnd ? "" + payablePeriodFromEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToStart === null)
            throw new Error("The parameter 'payablePeriodToStart' cannot be null.");
        else if (payablePeriodToStart !== undefined)
            url_ += "PayablePeriodToStart=" + encodeURIComponent(payablePeriodToStart ? "" + payablePeriodToStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToEnd === null)
            throw new Error("The parameter 'payablePeriodToEnd' cannot be null.");
        else if (payablePeriodToEnd !== undefined)
            url_ += "PayablePeriodToEnd=" + encodeURIComponent(payablePeriodToEnd ? "" + payablePeriodToEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productName === null)
            throw new Error("The parameter 'productName' cannot be null.");
        else if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&";
        if (productGruopName === null)
            throw new Error("The parameter 'productGruopName' cannot be null.");
        else if (productGruopName !== undefined)
            url_ += "ProductGruopName=" + encodeURIComponent("" + productGruopName) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (transactionDatetimeStart === null)
            throw new Error("The parameter 'transactionDatetimeStart' cannot be null.");
        else if (transactionDatetimeStart !== undefined)
            url_ += "TransactionDatetimeStart=" + encodeURIComponent(transactionDatetimeStart ? "" + transactionDatetimeStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeEnd === null)
            throw new Error("The parameter 'transactionDatetimeEnd' cannot be null.");
        else if (transactionDatetimeEnd !== undefined)
            url_ += "TransactionDatetimeEnd=" + encodeURIComponent(transactionDatetimeEnd ? "" + transactionDatetimeEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebts(_response);
        });
    }

    protected processDebts(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Debts V4
     * @param payablePeriodFromStart (optional) 
     * @param payablePeriodFromEnd (optional) 
     * @param payablePeriodToStart (optional) 
     * @param payablePeriodToEnd (optional) 
     * @param productNameList (optional) 
     * @param productGroupNameList (optional) 
     * @param paymentStatusIdList (optional) 
     * @param transactionDatetimeStart (optional) 
     * @param transactionDatetimeEnd (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param b (optional) 
     * @param iN (optional) 
     * @param applicationCode (optional) 
     * @param payerName (optional) 
     * @param custName (optional) 
     * @param viewPoint (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debtsv4(payablePeriodFromStart?: dayjs.Dayjs | undefined, payablePeriodFromEnd?: dayjs.Dayjs | undefined, payablePeriodToStart?: dayjs.Dayjs | undefined, payablePeriodToEnd?: dayjs.Dayjs | undefined, productNameList?: string | undefined, productGroupNameList?: string | undefined, paymentStatusIdList?: string | undefined, transactionDatetimeStart?: dayjs.Dayjs | undefined, transactionDatetimeEnd?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, b?: string | undefined, iN?: string | undefined, applicationCode?: string | undefined, payerName?: string | undefined, custName?: string | undefined, viewPoint?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtsv4?";
        if (payablePeriodFromStart === null)
            throw new Error("The parameter 'payablePeriodFromStart' cannot be null.");
        else if (payablePeriodFromStart !== undefined)
            url_ += "PayablePeriodFromStart=" + encodeURIComponent(payablePeriodFromStart ? "" + payablePeriodFromStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodFromEnd === null)
            throw new Error("The parameter 'payablePeriodFromEnd' cannot be null.");
        else if (payablePeriodFromEnd !== undefined)
            url_ += "PayablePeriodFromEnd=" + encodeURIComponent(payablePeriodFromEnd ? "" + payablePeriodFromEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToStart === null)
            throw new Error("The parameter 'payablePeriodToStart' cannot be null.");
        else if (payablePeriodToStart !== undefined)
            url_ += "PayablePeriodToStart=" + encodeURIComponent(payablePeriodToStart ? "" + payablePeriodToStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToEnd === null)
            throw new Error("The parameter 'payablePeriodToEnd' cannot be null.");
        else if (payablePeriodToEnd !== undefined)
            url_ += "PayablePeriodToEnd=" + encodeURIComponent(payablePeriodToEnd ? "" + payablePeriodToEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productNameList === null)
            throw new Error("The parameter 'productNameList' cannot be null.");
        else if (productNameList !== undefined)
            url_ += "ProductNameList=" + encodeURIComponent("" + productNameList) + "&";
        if (productGroupNameList === null)
            throw new Error("The parameter 'productGroupNameList' cannot be null.");
        else if (productGroupNameList !== undefined)
            url_ += "ProductGroupNameList=" + encodeURIComponent("" + productGroupNameList) + "&";
        if (paymentStatusIdList === null)
            throw new Error("The parameter 'paymentStatusIdList' cannot be null.");
        else if (paymentStatusIdList !== undefined)
            url_ += "PaymentStatusIdList=" + encodeURIComponent("" + paymentStatusIdList) + "&";
        if (transactionDatetimeStart === null)
            throw new Error("The parameter 'transactionDatetimeStart' cannot be null.");
        else if (transactionDatetimeStart !== undefined)
            url_ += "TransactionDatetimeStart=" + encodeURIComponent(transactionDatetimeStart ? "" + transactionDatetimeStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeEnd === null)
            throw new Error("The parameter 'transactionDatetimeEnd' cannot be null.");
        else if (transactionDatetimeEnd !== undefined)
            url_ += "TransactionDatetimeEnd=" + encodeURIComponent(transactionDatetimeEnd ? "" + transactionDatetimeEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (iN === null)
            throw new Error("The parameter 'iN' cannot be null.");
        else if (iN !== undefined)
            url_ += "IN=" + encodeURIComponent("" + iN) + "&";
        if (applicationCode === null)
            throw new Error("The parameter 'applicationCode' cannot be null.");
        else if (applicationCode !== undefined)
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (custName === null)
            throw new Error("The parameter 'custName' cannot be null.");
        else if (custName !== undefined)
            url_ += "CustName=" + encodeURIComponent("" + custName) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtsv4(_response);
        });
    }

    protected processDebtsv4(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET DebtPeriods
     * @param productNameList (optional) 
     * @param productGroupNameList (optional) 
     * @param paymentStatusIdList (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param b (optional) 
     * @param iN (optional) 
     * @param applicationCode (optional) 
     * @param payerName (optional) 
     * @param custName (optional) 
     * @param viewPoint (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debtperiods(period: dayjs.Dayjs, productNameList?: string | undefined, productGroupNameList?: string | undefined, paymentStatusIdList?: string | undefined, debtGroupReferTypeId?: number | undefined, b?: string | undefined, iN?: string | undefined, applicationCode?: string | undefined, payerName?: string | undefined, custName?: string | undefined, viewPoint?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtperiods?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productNameList === null)
            throw new Error("The parameter 'productNameList' cannot be null.");
        else if (productNameList !== undefined)
            url_ += "ProductNameList=" + encodeURIComponent("" + productNameList) + "&";
        if (productGroupNameList === null)
            throw new Error("The parameter 'productGroupNameList' cannot be null.");
        else if (productGroupNameList !== undefined)
            url_ += "ProductGroupNameList=" + encodeURIComponent("" + productGroupNameList) + "&";
        if (paymentStatusIdList === null)
            throw new Error("The parameter 'paymentStatusIdList' cannot be null.");
        else if (paymentStatusIdList !== undefined)
            url_ += "PaymentStatusIdList=" + encodeURIComponent("" + paymentStatusIdList) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (iN === null)
            throw new Error("The parameter 'iN' cannot be null.");
        else if (iN !== undefined)
            url_ += "IN=" + encodeURIComponent("" + iN) + "&";
        if (applicationCode === null)
            throw new Error("The parameter 'applicationCode' cannot be null.");
        else if (applicationCode !== undefined)
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (custName === null)
            throw new Error("The parameter 'custName' cannot be null.");
        else if (custName !== undefined)
            url_ += "CustName=" + encodeURIComponent("" + custName) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtperiods(_response);
        });
    }

    protected processDebtperiods(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET DebtPeriods V2
     * @param productId (optional) 
     * @param productGroupId (optional) 
     * @param paymentStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param viewPoint (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debtPeriodsV2(period: dayjs.Dayjs, productId?: number | undefined, productGroupId?: number | undefined, paymentStatusId?: number | undefined, debtGroupReferTypeId?: number | undefined, searchIndex?: number | undefined, searchText?: string | undefined, viewPoint?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DebtPeriodsNew_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/recurring/debtperiodsv2?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtPeriodsV2(_response);
        });
    }

    protected processDebtPeriodsV2(response: AxiosResponse): Promise<Usp_DebtPeriodsNew_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtPeriodsNew_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtPeriodsNew_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get DebtsUser
     * @param searchDetail (optional) 
     * @param payablePeriodFromStart (optional) 
     * @param payablePeriodFromEnd (optional) 
     * @param payablePeriodToStart (optional) 
     * @param payablePeriodToEnd (optional) 
     * @param productName (optional) 
     * @param productGruopName (optional) 
     * @param paymentStatusId (optional) 
     * @param transactionDatetimeStart (optional) 
     * @param transactionDatetimeEnd (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debsuser(searchDetail?: string | undefined, payablePeriodFromStart?: dayjs.Dayjs | undefined, payablePeriodFromEnd?: dayjs.Dayjs | undefined, payablePeriodToStart?: dayjs.Dayjs | undefined, payablePeriodToEnd?: dayjs.Dayjs | undefined, productName?: string | undefined, productGruopName?: string | undefined, paymentStatusId?: string | undefined, transactionDatetimeStart?: dayjs.Dayjs | undefined, transactionDatetimeEnd?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debsuser?";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (payablePeriodFromStart === null)
            throw new Error("The parameter 'payablePeriodFromStart' cannot be null.");
        else if (payablePeriodFromStart !== undefined)
            url_ += "PayablePeriodFromStart=" + encodeURIComponent(payablePeriodFromStart ? "" + payablePeriodFromStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodFromEnd === null)
            throw new Error("The parameter 'payablePeriodFromEnd' cannot be null.");
        else if (payablePeriodFromEnd !== undefined)
            url_ += "PayablePeriodFromEnd=" + encodeURIComponent(payablePeriodFromEnd ? "" + payablePeriodFromEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToStart === null)
            throw new Error("The parameter 'payablePeriodToStart' cannot be null.");
        else if (payablePeriodToStart !== undefined)
            url_ += "PayablePeriodToStart=" + encodeURIComponent(payablePeriodToStart ? "" + payablePeriodToStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToEnd === null)
            throw new Error("The parameter 'payablePeriodToEnd' cannot be null.");
        else if (payablePeriodToEnd !== undefined)
            url_ += "PayablePeriodToEnd=" + encodeURIComponent(payablePeriodToEnd ? "" + payablePeriodToEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productName === null)
            throw new Error("The parameter 'productName' cannot be null.");
        else if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&";
        if (productGruopName === null)
            throw new Error("The parameter 'productGruopName' cannot be null.");
        else if (productGruopName !== undefined)
            url_ += "ProductGruopName=" + encodeURIComponent("" + productGruopName) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (transactionDatetimeStart === null)
            throw new Error("The parameter 'transactionDatetimeStart' cannot be null.");
        else if (transactionDatetimeStart !== undefined)
            url_ += "TransactionDatetimeStart=" + encodeURIComponent(transactionDatetimeStart ? "" + transactionDatetimeStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeEnd === null)
            throw new Error("The parameter 'transactionDatetimeEnd' cannot be null.");
        else if (transactionDatetimeEnd !== undefined)
            url_ += "TransactionDatetimeEnd=" + encodeURIComponent(transactionDatetimeEnd ? "" + transactionDatetimeEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebsuser(_response);
        });
    }

    protected processDebsuser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Debt Details
     * @param debtHeaderId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debtdetails(debtHeaderId?: string | undefined, debtGroupReferTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtdetails?";
        if (debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' cannot be null.");
        else if (debtHeaderId !== undefined)
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtdetails(_response);
        });
    }

    protected processDebtdetails(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET Application
     * @return OK
     */
    application(applicationCode: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/application/{applicationCode}";
        if (applicationCode === undefined || applicationCode === null)
            throw new Error("The parameter 'applicationCode' must be defined.");
        url_ = url_.replace("{applicationCode}", encodeURIComponent("" + applicationCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplication(_response);
        });
    }

    protected processApplication(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET Debt History
     * @return OK
     */
    debthistory(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debthistory?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "debtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebthistory(_response);
        });
    }

    protected processDebthistory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET Debt Events History
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debteventshistory(debtHeaderId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debteventshistory?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebteventshistory(_response);
        });
    }

    protected processDebteventshistory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Refund Headers
     * @param searchDetail (optional) 
     * @param bankId (optional) 
     * @param refundHeaderStatusId (optional) 
     * @param transferDateFrom (optional) 
     * @param transferDateTo (optional) 
     * @param appCode (optional) 
     * @param payerName (optional) 
     * @param payerIdentityCard (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    refundheaders(searchDetail?: string | undefined, bankId?: string | undefined, refundHeaderStatusId?: string | undefined, transferDateFrom?: dayjs.Dayjs | undefined, transferDateTo?: dayjs.Dayjs | undefined, appCode?: string | undefined, payerName?: string | undefined, payerIdentityCard?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/refundheaders?";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (refundHeaderStatusId === null)
            throw new Error("The parameter 'refundHeaderStatusId' cannot be null.");
        else if (refundHeaderStatusId !== undefined)
            url_ += "RefundHeaderStatusId=" + encodeURIComponent("" + refundHeaderStatusId) + "&";
        if (transferDateFrom === null)
            throw new Error("The parameter 'transferDateFrom' cannot be null.");
        else if (transferDateFrom !== undefined)
            url_ += "TransferDateFrom=" + encodeURIComponent(transferDateFrom ? "" + transferDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transferDateTo === null)
            throw new Error("The parameter 'transferDateTo' cannot be null.");
        else if (transferDateTo !== undefined)
            url_ += "TransferDateTo=" + encodeURIComponent(transferDateTo ? "" + transferDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (appCode === null)
            throw new Error("The parameter 'appCode' cannot be null.");
        else if (appCode !== undefined)
            url_ += "AppCode=" + encodeURIComponent("" + appCode) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (payerIdentityCard === null)
            throw new Error("The parameter 'payerIdentityCard' cannot be null.");
        else if (payerIdentityCard !== undefined)
            url_ += "PayerIdentityCard=" + encodeURIComponent("" + payerIdentityCard) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefundheaders(_response);
        });
    }

    protected processRefundheaders(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Refund Details
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    refunddetails(refundHeaderId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/refunddetails?";
        if (refundHeaderId === undefined || refundHeaderId === null)
            throw new Error("The parameter 'refundHeaderId' must be defined and cannot be null.");
        else
            url_ += "RefundHeaderId=" + encodeURIComponent("" + refundHeaderId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefunddetails(_response);
        });
    }

    protected processRefunddetails(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    tempresultrefund(file?: FileParameter | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/tempresultrefund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempresultrefund(_response);
        });
    }

    protected processTempresultrefund(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET Temp Result Refund Preview
     * @return OK
     */
    tempresultrefundpreview(tempId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/tempresultrefundpreview?";
        if (tempId === undefined || tempId === null)
            throw new Error("The parameter 'tempId' must be defined and cannot be null.");
        else
            url_ += "TempId=" + encodeURIComponent("" + tempId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempresultrefundpreview(_response);
        });
    }

    protected processTempresultrefundpreview(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST Temp Result Refund To Refund Header Update
     * @return OK
     */
    tempresultrefundtorefundheaderupdate(tempId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/tempresultrefundtorefundheaderupdate?";
        if (tempId === undefined || tempId === null)
            throw new Error("The parameter 'tempId' must be defined and cannot be null.");
        else
            url_ += "TempId=" + encodeURIComponent("" + tempId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempresultrefundtorefundheaderupdate(_response);
        });
    }

    protected processTempresultrefundtorefundheaderupdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get SMS Detail Monitors
     * @param searchText (optional) 
     * @param sendDateFrom (optional) 
     * @param sendDateTo (optional) 
     * @param debtGroupReferTypeListId (optional) 
     * @param sMSDetailStatusListId (optional) 
     * @param sMSTypeListId (optional) 
     * @param b (optional) 
     * @param payerName (optional) 
     * @param phoneNo (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    smsdetailmonitors(searchText?: string | undefined, sendDateFrom?: dayjs.Dayjs | undefined, sendDateTo?: dayjs.Dayjs | undefined, debtGroupReferTypeListId?: string | undefined, sMSDetailStatusListId?: string | undefined, sMSTypeListId?: string | undefined, b?: string | undefined, payerName?: string | undefined, phoneNo?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/smsdetailmonitors?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (sendDateFrom === null)
            throw new Error("The parameter 'sendDateFrom' cannot be null.");
        else if (sendDateFrom !== undefined)
            url_ += "SendDateFrom=" + encodeURIComponent(sendDateFrom ? "" + sendDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (sendDateTo === null)
            throw new Error("The parameter 'sendDateTo' cannot be null.");
        else if (sendDateTo !== undefined)
            url_ += "SendDateTo=" + encodeURIComponent(sendDateTo ? "" + sendDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeListId === null)
            throw new Error("The parameter 'debtGroupReferTypeListId' cannot be null.");
        else if (debtGroupReferTypeListId !== undefined)
            url_ += "DebtGroupReferTypeListId=" + encodeURIComponent("" + debtGroupReferTypeListId) + "&";
        if (sMSDetailStatusListId === null)
            throw new Error("The parameter 'sMSDetailStatusListId' cannot be null.");
        else if (sMSDetailStatusListId !== undefined)
            url_ += "SMSDetailStatusListId=" + encodeURIComponent("" + sMSDetailStatusListId) + "&";
        if (sMSTypeListId === null)
            throw new Error("The parameter 'sMSTypeListId' cannot be null.");
        else if (sMSTypeListId !== undefined)
            url_ += "SMSTypeListId=" + encodeURIComponent("" + sMSTypeListId) + "&";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (phoneNo === null)
            throw new Error("The parameter 'phoneNo' cannot be null.");
        else if (phoneNo !== undefined)
            url_ += "PhoneNo=" + encodeURIComponent("" + phoneNo) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSmsdetailmonitors(_response);
        });
    }

    protected processSmsdetailmonitors(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get SMSDetailSubMonitors
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    smsdetailsubmonitors(debtHeaderId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/smsdetailsubmonitors?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSmsdetailsubmonitors(_response);
        });
    }

    protected processSmsdetailsubmonitors(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET SMSDetailMonitorByOrderSelect
     * @param searchText (optional) 
     * @param sendDateFrom (optional) 
     * @param sendDateTo (optional) 
     * @param debtGroupReferTypeListId (optional) 
     * @param sMSTypeListId (optional) 
     * @param b (optional) 
     * @param payerName (optional) 
     * @param phoneNo (optional) 
     * @param sourceTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    smsdetailmonitorbyorderselect(searchText?: string | undefined, sendDateFrom?: dayjs.Dayjs | undefined, sendDateTo?: dayjs.Dayjs | undefined, debtGroupReferTypeListId?: string | undefined, sMSTypeListId?: string | undefined, b?: string | undefined, payerName?: string | undefined, phoneNo?: string | undefined, sourceTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/smsdetailmonitorbyorderselect?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (sendDateFrom === null)
            throw new Error("The parameter 'sendDateFrom' cannot be null.");
        else if (sendDateFrom !== undefined)
            url_ += "SendDateFrom=" + encodeURIComponent(sendDateFrom ? "" + sendDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (sendDateTo === null)
            throw new Error("The parameter 'sendDateTo' cannot be null.");
        else if (sendDateTo !== undefined)
            url_ += "SendDateTo=" + encodeURIComponent(sendDateTo ? "" + sendDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeListId === null)
            throw new Error("The parameter 'debtGroupReferTypeListId' cannot be null.");
        else if (debtGroupReferTypeListId !== undefined)
            url_ += "DebtGroupReferTypeListId=" + encodeURIComponent("" + debtGroupReferTypeListId) + "&";
        if (sMSTypeListId === null)
            throw new Error("The parameter 'sMSTypeListId' cannot be null.");
        else if (sMSTypeListId !== undefined)
            url_ += "SMSTypeListId=" + encodeURIComponent("" + sMSTypeListId) + "&";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (phoneNo === null)
            throw new Error("The parameter 'phoneNo' cannot be null.");
        else if (phoneNo !== undefined)
            url_ += "PhoneNo=" + encodeURIComponent("" + phoneNo) + "&";
        if (sourceTypeId === null)
            throw new Error("The parameter 'sourceTypeId' cannot be null.");
        else if (sourceTypeId !== undefined)
            url_ += "SourceTypeId=" + encodeURIComponent("" + sourceTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSmsdetailmonitorbyorderselect(_response);
        });
    }

    protected processSmsdetailmonitorbyorderselect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST ReSend SMS
     * @param body (optional) 
     * @return OK
     */
    sendsms(body?: SMSCreateRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<SendSmsV2ResponseServiceResponse> {
        let url_ = this.baseUrl + "/sms/sendsms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendsms(_response);
        });
    }

    protected processSendsms(response: AxiosResponse): Promise<SendSmsV2ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SendSmsV2ResponseServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SendSmsV2ResponseServiceResponse>(null as any);
    }

    /**
     * POST UpSertPayableDate
     * @param summaryHeaderId (optional) 
     * @param payableDate (optional) 
     * @return OK
     */
    upsertpayabledate(summaryHeaderId?: string | undefined, payableDate?: dayjs.Dayjs | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/upsertpayabledate?";
        if (summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' cannot be null.");
        else if (summaryHeaderId !== undefined)
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        if (payableDate === null)
            throw new Error("The parameter 'payableDate' cannot be null.");
        else if (payableDate !== undefined)
            url_ += "PayableDate=" + encodeURIComponent(payableDate ? "" + payableDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpsertpayabledate(_response);
        });
    }

    protected processUpsertpayabledate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST Match
     * @param transferHeaderIdList (optional) 
     * @param statementIdList (optional) 
     * @return OK
     */
    match(transferHeaderIdList?: string | undefined, statementIdList?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/match?";
        if (transferHeaderIdList === null)
            throw new Error("The parameter 'transferHeaderIdList' cannot be null.");
        else if (transferHeaderIdList !== undefined)
            url_ += "TransferHeaderIdList=" + encodeURIComponent("" + transferHeaderIdList) + "&";
        if (statementIdList === null)
            throw new Error("The parameter 'statementIdList' cannot be null.");
        else if (statementIdList !== undefined)
            url_ += "StatementIdList=" + encodeURIComponent("" + statementIdList) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMatch(_response);
        });
    }

    protected processMatch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET BankAccountNoForMatch
     * @param bankId (optional) 
     * @return OK
     */
    bankaccountnoformatch(bankId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/bankaccountnoformatch?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankaccountnoformatch(_response);
        });
    }

    protected processBankaccountnoformatch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET BankForMatch
     * @param bankId (optional) 
     * @return OK
     */
    bankformatch(bankId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/bankformatch?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankformatch(_response);
        });
    }

    protected processBankformatch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get TranferHeaderWaitMatchs
     * @param transferDate (optional) 
     * @param bankId (optional) 
     * @param bankAccountNo (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    tranferheaderwaitmatchs(transferDate?: dayjs.Dayjs | undefined, bankId?: number | undefined, bankAccountNo?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/tranferheaderwaitmatchs?";
        if (transferDate === null)
            throw new Error("The parameter 'transferDate' cannot be null.");
        else if (transferDate !== undefined)
            url_ += "TransferDate=" + encodeURIComponent(transferDate ? "" + transferDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' cannot be null.");
        else if (bankAccountNo !== undefined)
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTranferheaderwaitmatchs(_response);
        });
    }

    protected processTranferheaderwaitmatchs(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get StatementWaitMatchs
     * @param transferDate (optional) 
     * @param bankId (optional) 
     * @param bankAccountNo (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    statementwaitmatchs(transferDate?: dayjs.Dayjs | undefined, bankId?: number | undefined, bankAccountNo?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/statementwaitmatchs?";
        if (transferDate === null)
            throw new Error("The parameter 'transferDate' cannot be null.");
        else if (transferDate !== undefined)
            url_ += "TransferDate=" + encodeURIComponent(transferDate ? "" + transferDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' cannot be null.");
        else if (bankAccountNo !== undefined)
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatementwaitmatchs(_response);
        });
    }

    protected processStatementwaitmatchs(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET DebitingHistories
     * @param bankAccountNo (optional) 
     * @param bankAccountName (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debitinghistories(period: dayjs.Dayjs, bankAccountNo?: string | undefined, bankAccountName?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debitinghistories?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' cannot be null.");
        else if (bankAccountNo !== undefined)
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (bankAccountName === null)
            throw new Error("The parameter 'bankAccountName' cannot be null.");
        else if (bankAccountName !== undefined)
            url_ += "BankAccountName=" + encodeURIComponent("" + bankAccountName) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebitinghistories(_response);
        });
    }

    protected processDebitinghistories(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET DebitingHistoryDetails
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debitinghistorydetails(summaryDetailId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debitinghistorydetails?";
        if (summaryDetailId === undefined || summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' must be defined and cannot be null.");
        else
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebitinghistorydetails(_response);
        });
    }

    protected processDebitinghistorydetails(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET DebtHeaderByRefAndBills
     * @param b (optional) 
     * @param ref1 (optional) 
     * @param ref2 (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debtheaderbyrefandbills(b?: string | undefined, ref1?: string | undefined, ref2?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtheaderbyrefandbills?";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (ref1 === null)
            throw new Error("The parameter 'ref1' cannot be null.");
        else if (ref1 !== undefined)
            url_ += "Ref1=" + encodeURIComponent("" + ref1) + "&";
        if (ref2 === null)
            throw new Error("The parameter 'ref2' cannot be null.");
        else if (ref2 !== undefined)
            url_ += "Ref2=" + encodeURIComponent("" + ref2) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtheaderbyrefandbills(_response);
        });
    }

    protected processDebtheaderbyrefandbills(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * DebitingHistoriesHeader
     * @param bankAccountNo (optional) 
     * @param bankAccountName (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debitinghistoriesheader(period: dayjs.Dayjs, bankAccountNo?: string | undefined, bankAccountName?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debitinghistoriesheader?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' cannot be null.");
        else if (bankAccountNo !== undefined)
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (bankAccountName === null)
            throw new Error("The parameter 'bankAccountName' cannot be null.");
        else if (bankAccountName !== undefined)
            url_ += "BankAccountName=" + encodeURIComponent("" + bankAccountName) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebitinghistoriesheader(_response);
        });
    }

    protected processDebitinghistoriesheader(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET SMSDetailLog
     * @return OK
     */
    smsdetaillog(smsDetailId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/smsdetaillog/{smsDetailId}";
        if (smsDetailId === undefined || smsDetailId === null)
            throw new Error("The parameter 'smsDetailId' must be defined.");
        url_ = url_.replace("{smsDetailId}", encodeURIComponent("" + smsDetailId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSmsdetaillog(_response);
        });
    }

    protected processSmsdetaillog(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * SummaryFileNoWaitReceiveFile
     * @param debtGroupReferTypeId (optional) 
     * @return OK
     */
    summaryfilenowaitreceive(bankId: number, debtGroupReferTypeId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/summaryfilenowaitreceive?";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummaryfilenowaitreceive(_response);
        });
    }

    protected processSummaryfilenowaitreceive(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET Summary Validate
     * @return OK
     */
    summaryvalidate(debtGroupId: string, bankId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/summaryvalidate?";
        if (debtGroupId === undefined || debtGroupId === null)
            throw new Error("The parameter 'debtGroupId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupId=" + encodeURIComponent("" + debtGroupId) + "&";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummaryvalidate(_response);
        });
    }

    protected processSummaryvalidate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET Debt Header Account Wrong Select
     * @return OK
     */
    debtheaderaccountwrongselect(debtGroupId: string, bankId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtheaderaccountwrongselect?";
        if (debtGroupId === undefined || debtGroupId === null)
            throw new Error("The parameter 'debtGroupId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupId=" + encodeURIComponent("" + debtGroupId) + "&";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtheaderaccountwrongselect(_response);
        });
    }

    protected processDebtheaderaccountwrongselect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST Debt Header Account Wrong Cancel Update
     * @return OK
     */
    debtheaderaccountwrongcancelupdate(debtGroupId: string, bankId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtheaderaccountwrongcancelupdate?";
        if (debtGroupId === undefined || debtGroupId === null)
            throw new Error("The parameter 'debtGroupId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupId=" + encodeURIComponent("" + debtGroupId) + "&";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtheaderaccountwrongcancelupdate(_response);
        });
    }

    protected processDebtheaderaccountwrongcancelupdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST Summary Detail Cancel Update
     * @return OK
     */
    summarydetailcancelupdate(summaryDetailId: string, description: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/summarydetailcancelupdate?";
        if (summaryDetailId === undefined || summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' must be defined and cannot be null.");
        else
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (description === undefined || description === null)
            throw new Error("The parameter 'description' must be defined and cannot be null.");
        else
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummarydetailcancelupdate(_response);
        });
    }

    protected processSummarydetailcancelupdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Summary Detail
     * @param bankAccountNo (optional) 
     * @param summaryFileNoId (optional) 
     * @param summaryDetailId (optional) 
     * @param summaryHeaderId (optional) 
     * @return OK
     */
    summarydetail2(bankAccountNo?: string | undefined, summaryFileNoId?: string | undefined, summaryDetailId?: string | undefined, summaryHeaderId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/summarydetail?";
        if (bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' cannot be null.");
        else if (bankAccountNo !== undefined)
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (summaryFileNoId === null)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else if (summaryFileNoId !== undefined)
            url_ += "SummaryFileNoId=" + encodeURIComponent("" + summaryFileNoId) + "&";
        if (summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' cannot be null.");
        else if (summaryDetailId !== undefined)
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' cannot be null.");
        else if (summaryHeaderId !== undefined)
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummarydetail2(_response);
        });
    }

    protected processSummarydetail2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Debt Detail
     * @param debtDetailId (optional) 
     * @return OK
     */
    debtdetail2(debtHeaderId: string, debtDetailId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtdetail?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (debtDetailId === null)
            throw new Error("The parameter 'debtDetailId' cannot be null.");
        else if (debtDetailId !== undefined)
            url_ += "DebtDetailId=" + encodeURIComponent("" + debtDetailId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtdetail2(_response);
        });
    }

    protected processDebtdetail2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET DebtHeaderforSplitBills
     * @param billNo (optional) 
     * @param payername (optional) 
     * @param payerIdentityCard (optional) 
     * @param searchDetail (optional) 
     * @param viewPoint (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    debtheaderforsplitbills(debtGroupReferTypeId: number, billNo?: string | undefined, payername?: string | undefined, payerIdentityCard?: string | undefined, searchDetail?: string | undefined, viewPoint?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtheaderforsplitbills?";
        if (debtGroupReferTypeId === undefined || debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (billNo === null)
            throw new Error("The parameter 'billNo' cannot be null.");
        else if (billNo !== undefined)
            url_ += "BillNo=" + encodeURIComponent("" + billNo) + "&";
        if (payername === null)
            throw new Error("The parameter 'payername' cannot be null.");
        else if (payername !== undefined)
            url_ += "Payername=" + encodeURIComponent("" + payername) + "&";
        if (payerIdentityCard === null)
            throw new Error("The parameter 'payerIdentityCard' cannot be null.");
        else if (payerIdentityCard !== undefined)
            url_ += "PayerIdentityCard=" + encodeURIComponent("" + payerIdentityCard) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtheaderforsplitbills(_response);
        });
    }

    protected processDebtheaderforsplitbills(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET DebtHeaderforSplitBill
     * @return OK
     */
    debtheaderforsplitbill(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/debtheaderforsplitbill?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "debtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtheaderforsplitbill(_response);
        });
    }

    protected processDebtheaderforsplitbill(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GET SummaryDetailCode
     * @return OK
     */
    summarydetailcode(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<StringServiceResponse> {
        let url_ = this.baseUrl + "/recurring/summarydetailcode?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "debtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummarydetailcode(_response);
        });
    }

    protected processSummarydetailcode(response: AxiosResponse): Promise<StringServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<StringServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringServiceResponse>(null as any);
    }

    /**
     * Get BankForTransferManual
     * @param bankId (optional) 
     * @return OK
     */
    bankfortransfermanual(bankId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/bankfortransfermanual?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankfortransfermanual(_response);
        });
    }

    protected processBankfortransfermanual(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get BankAccountNoForMatch
     * @param bankId (optional) 
     * @return OK
     */
    bankaccountnofortransfermanual(bankId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/bankaccountnofortransfermanual?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankaccountnofortransfermanual(_response);
        });
    }

    protected processBankaccountnofortransfermanual(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get BankAccountNoForMatch
     * @param receiveTypeId (optional) 
     * @return OK
     */
    receivetypefortransfermanual(receiveTypeId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/receivetypefortransfermanual?";
        if (receiveTypeId === null)
            throw new Error("The parameter 'receiveTypeId' cannot be null.");
        else if (receiveTypeId !== undefined)
            url_ += "ReceiveTypeId=" + encodeURIComponent("" + receiveTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceivetypefortransfermanual(_response);
        });
    }

    protected processReceivetypefortransfermanual(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Add CreateTransferManual
     * @return OK
     */
    createtransfermanual(paymentChanelId: number, bankId: number, bankAccountNo: string, transferDateTime: dayjs.Dayjs, transferAmount: number, transferRemark: string, receiveTypeId: number, custName: string, payerName: string, createdByUserId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/createtransfermanual?";
        if (paymentChanelId === undefined || paymentChanelId === null)
            throw new Error("The parameter 'paymentChanelId' must be defined and cannot be null.");
        else
            url_ += "PaymentChanelId=" + encodeURIComponent("" + paymentChanelId) + "&";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (bankAccountNo === undefined || bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' must be defined and cannot be null.");
        else
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (transferDateTime === undefined || transferDateTime === null)
            throw new Error("The parameter 'transferDateTime' must be defined and cannot be null.");
        else
            url_ += "TransferDateTime=" + encodeURIComponent(transferDateTime ? "" + transferDateTime.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transferAmount === undefined || transferAmount === null)
            throw new Error("The parameter 'transferAmount' must be defined and cannot be null.");
        else
            url_ += "TransferAmount=" + encodeURIComponent("" + transferAmount) + "&";
        if (transferRemark === undefined || transferRemark === null)
            throw new Error("The parameter 'transferRemark' must be defined and cannot be null.");
        else
            url_ += "TransferRemark=" + encodeURIComponent("" + transferRemark) + "&";
        if (receiveTypeId === undefined || receiveTypeId === null)
            throw new Error("The parameter 'receiveTypeId' must be defined and cannot be null.");
        else
            url_ += "ReceiveTypeId=" + encodeURIComponent("" + receiveTypeId) + "&";
        if (custName === undefined || custName === null)
            throw new Error("The parameter 'custName' must be defined and cannot be null.");
        else
            url_ += "CustName=" + encodeURIComponent("" + custName) + "&";
        if (payerName === undefined || payerName === null)
            throw new Error("The parameter 'payerName' must be defined and cannot be null.");
        else
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (createdByUserId === undefined || createdByUserId === null)
            throw new Error("The parameter 'createdByUserId' must be defined and cannot be null.");
        else
            url_ += "CreatedByUserId=" + encodeURIComponent("" + createdByUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatetransfermanual(_response);
        });
    }

    protected processCreatetransfermanual(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get ReceiveTypeForGenerateFeeBill
     * @param receiveTypeId (optional) 
     * @return OK
     */
    receivetypeforgeneratefeebill(receiveTypeId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/recurring/receivetypeforgeneratefeebill?";
        if (receiveTypeId === null)
            throw new Error("The parameter 'receiveTypeId' cannot be null.");
        else if (receiveTypeId !== undefined)
            url_ += "ReceiveTypeId=" + encodeURIComponent("" + receiveTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceivetypeforgeneratefeebill(_response);
        });
    }

    protected processReceivetypeforgeneratefeebill(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    premiumCheckProcessSummaryFileNo(body?: CheckProcessSummaryFileNoRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<CheckProcessSummaryFileNoResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/premium/checkprocesssummaryfileno";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPremiumCheckProcessSummaryFileNo(_response);
        });
    }

    protected processPremiumCheckProcessSummaryFileNo(response: AxiosResponse): Promise<CheckProcessSummaryFileNoResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<CheckProcessSummaryFileNoResponseDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckProcessSummaryFileNoResponseDtoListServiceResponse>(null as any);
    }

    /**
     * @return OK
     */
    summaryfileno(summaryheaderid: string, cancelToken?: CancelToken | undefined): Promise<GetSummaryFileNoBySummaryHeaderIdResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/premium/summaryfileno/{summaryheaderid}";
        if (summaryheaderid === undefined || summaryheaderid === null)
            throw new Error("The parameter 'summaryheaderid' must be defined.");
        url_ = url_.replace("{summaryheaderid}", encodeURIComponent("" + summaryheaderid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummaryfileno(_response);
        });
    }

    protected processSummaryfileno(response: AxiosResponse): Promise<GetSummaryFileNoBySummaryHeaderIdResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetSummaryFileNoBySummaryHeaderIdResponseDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetSummaryFileNoBySummaryHeaderIdResponseDtoListServiceResponse>(null as any);
    }
}

export class PremiumReportClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-1	รายงานการตั้งหนี้ New App
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatus (optional) 
     * @param productTypeId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatus?: string | undefined, productTypeId?: string | undefined, paymentMethodTypeId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/newappreport/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter(_response);
        });
    }

    protected processFilter(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-1	รายงานการตั้งหนี้ New App
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatus (optional) 
     * @param productTypeId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    newappreport(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatus?: string | undefined, productTypeId?: string | undefined, paymentMethodTypeId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/newappreport?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewappreport(_response);
        });
    }

    protected processNewappreport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-3	รายงานการตั้งหนี้ ต่ออายุรายปี
     * @param searchText (optional) 
     * @param searchIndex (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatusListId (optional) 
     * @param productGroupListId (optional) 
     * @param paymentMethodTypeListId (optional) 
     * @param branchListId (optional) 
     * @return OK
     */
    debtyearlyrenewreport(period: dayjs.Dayjs, searchText?: string | undefined, searchIndex?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatusListId?: string | undefined, productGroupListId?: string | undefined, paymentMethodTypeListId?: string | undefined, branchListId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/debtyearlyrenewreport?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatusListId === null)
            throw new Error("The parameter 'paymentStatusListId' cannot be null.");
        else if (paymentStatusListId !== undefined)
            url_ += "PaymentStatusListId=" + encodeURIComponent("" + paymentStatusListId) + "&";
        if (productGroupListId === null)
            throw new Error("The parameter 'productGroupListId' cannot be null.");
        else if (productGroupListId !== undefined)
            url_ += "ProductGroupListId=" + encodeURIComponent("" + productGroupListId) + "&";
        if (paymentMethodTypeListId === null)
            throw new Error("The parameter 'paymentMethodTypeListId' cannot be null.");
        else if (paymentMethodTypeListId !== undefined)
            url_ += "PaymentMethodTypeListId=" + encodeURIComponent("" + paymentMethodTypeListId) + "&";
        if (branchListId === null)
            throw new Error("The parameter 'branchListId' cannot be null.");
        else if (branchListId !== undefined)
            url_ += "BranchListId=" + encodeURIComponent("" + branchListId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtyearlyrenewreport(_response);
        });
    }

    protected processDebtyearlyrenewreport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-5	รายงานการตั้งหนี้ ขึ้นจัดเก็บ สาขาผู้ชำระเบี้ย
     * @param searchText (optional) 
     * @param searchIndex (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param paymentChannelId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter2(period: dayjs.Dayjs, searchText?: string | undefined, searchIndex?: string | undefined, debtGroupReferTypeId?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, paymentChannelId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportdebtcollect/filter?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentChannelId === null)
            throw new Error("The parameter 'paymentChannelId' cannot be null.");
        else if (paymentChannelId !== undefined)
            url_ += "PaymentChannelId=" + encodeURIComponent("" + paymentChannelId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter2(_response);
        });
    }

    protected processFilter2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-5 รายงานการตั้งหนี้ ขึ้นจัดเก็บ สาขาผู้ชำระเบี้ย
     * @param searchText (optional) 
     * @param searchIndex (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param paymentChannelId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    reportdebtcollect(period: dayjs.Dayjs, searchText?: string | undefined, searchIndex?: string | undefined, debtGroupReferTypeId?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, paymentChannelId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportdebtcollect?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentChannelId === null)
            throw new Error("The parameter 'paymentChannelId' cannot be null.");
        else if (paymentChannelId !== undefined)
            url_ += "PaymentChannelId=" + encodeURIComponent("" + paymentChannelId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportdebtcollect(_response);
        });
    }

    protected processReportdebtcollect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-7 รายงานหักบัญชีธนาคาร : ต่ออายุรายเดือน
     * @param searchText (optional) 
     * @param searchIndex (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter3(period: dayjs.Dayjs, searchText?: string | undefined, searchIndex?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportdebtmonthlyrenew/filter?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter3(_response);
        });
    }

    protected processFilter3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-7 รายงานหักบัญชีธนาคาร : ต่ออายุรายเดือน
     * @param searchText (optional) 
     * @param searchIndex (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    reportdebtmonthlyrenew(period: dayjs.Dayjs, searchText?: string | undefined, searchIndex?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportdebtmonthlyrenew?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportdebtmonthlyrenew(_response);
        });
    }

    protected processReportdebtmonthlyrenew(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-9	รายงานการตั้งหนี้ คืนความคุ้มครอง
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatus (optional) 
     * @param productTypeId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter4(startCoverDate: dayjs.Dayjs, indexSearch: number, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatus?: number | undefined, productTypeId?: number | undefined, paymentMethodTypeId?: number | undefined, branchId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportdebtrefund/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (indexSearch === undefined || indexSearch === null)
            throw new Error("The parameter 'indexSearch' must be defined and cannot be null.");
        else
            url_ += "IndexSearch=" + encodeURIComponent("" + indexSearch) + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter4(_response);
        });
    }

    protected processFilter4(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-9 รายงานการตั้งหนี้ คืนความคุ้มครอง
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatus (optional) 
     * @param productTypeId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    reportdebtrefund(startCoverDate: dayjs.Dayjs, indexSearch: number, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatus?: number | undefined, productTypeId?: number | undefined, paymentMethodTypeId?: number | undefined, branchId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportdebtrefund?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (indexSearch === undefined || indexSearch === null)
            throw new Error("The parameter 'indexSearch' must be defined and cannot be null.");
        else
            url_ += "IndexSearch=" + encodeURIComponent("" + indexSearch) + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportdebtrefund(_response);
        });
    }

    protected processReportdebtrefund(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-11	รายงานการหักบัญชีธนาคาร (RD)
     * @param textSearch (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param recurringStatusId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter5(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, recurringStatusId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportrecurringdetail/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (recurringStatusId === null)
            throw new Error("The parameter 'recurringStatusId' cannot be null.");
        else if (recurringStatusId !== undefined)
            url_ += "RecurringStatusId=" + encodeURIComponent("" + recurringStatusId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter5(_response);
        });
    }

    protected processFilter5(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-11	รายงานการหักบัญชีธนาคาร (RD)
     * @param textSearch (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param recurringStatusId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    reportrecurringdetail(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, recurringStatusId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportrecurringdetail?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (recurringStatusId === null)
            throw new Error("The parameter 'recurringStatusId' cannot be null.");
        else if (recurringStatusId !== undefined)
            url_ += "RecurringStatusId=" + encodeURIComponent("" + recurringStatusId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportrecurringdetail(_response);
        });
    }

    protected processReportrecurringdetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-12	รายงาน Summary ผลหักตามบัญชี
     * @param payableDate (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param productTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter6(debtPeriod: dayjs.Dayjs, payableDate?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, productTypeId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportrecurringbank/filter?";
        if (debtPeriod === undefined || debtPeriod === null)
            throw new Error("The parameter 'debtPeriod' must be defined and cannot be null.");
        else
            url_ += "DebtPeriod=" + encodeURIComponent(debtPeriod ? "" + debtPeriod.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payableDate === null)
            throw new Error("The parameter 'payableDate' cannot be null.");
        else if (payableDate !== undefined)
            url_ += "PayableDate=" + encodeURIComponent("" + payableDate) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter6(_response);
        });
    }

    protected processFilter6(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-12	รายงาน Summary ผลหักตามบัญชี
     * @param payableDate (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param productTypeId (optional) 
     * @return OK
     */
    reportrecurringbank(debtPeriod: dayjs.Dayjs, payableDate?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, productTypeId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportrecurringbank?";
        if (debtPeriod === undefined || debtPeriod === null)
            throw new Error("The parameter 'debtPeriod' must be defined and cannot be null.");
        else
            url_ += "DebtPeriod=" + encodeURIComponent(debtPeriod ? "" + debtPeriod.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payableDate === null)
            throw new Error("The parameter 'payableDate' cannot be null.");
        else if (payableDate !== undefined)
            url_ += "PayableDate=" + encodeURIComponent("" + payableDate) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportrecurringbank(_response);
        });
    }

    protected processReportrecurringbank(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-13	รายงานผลการส่งหักเบี้ยธนาคาร (RB) แยกตามสาขาผู้ชำระเบี้ย
     * @param textSearch (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param recurringStatusId (optional) 
     * @param branchId (optional) 
     * @param productTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter7(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, recurringStatusId?: string | undefined, branchId?: string | undefined, productTypeId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportrecurringbranch/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (recurringStatusId === null)
            throw new Error("The parameter 'recurringStatusId' cannot be null.");
        else if (recurringStatusId !== undefined)
            url_ += "RecurringStatusId=" + encodeURIComponent("" + recurringStatusId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter7(_response);
        });
    }

    protected processFilter7(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-13	รายงานผลการส่งหักเบี้ยธนาคาร (RB) แยกตามสาขาผู้ชำระเบี้ย
     * @param textSearch (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param recurringStatusId (optional) 
     * @param branchId (optional) 
     * @param productTypeId (optional) 
     * @return OK
     */
    reportrecurringbranch(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, recurringStatusId?: string | undefined, branchId?: string | undefined, productTypeId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportrecurringbranch?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (recurringStatusId === null)
            throw new Error("The parameter 'recurringStatusId' cannot be null.");
        else if (recurringStatusId !== undefined)
            url_ += "RecurringStatusId=" + encodeURIComponent("" + recurringStatusId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportrecurringbranch(_response);
        });
    }

    protected processReportrecurringbranch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-14	รายงานการคืนเงิน (RFG)
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param refundHeaderStatusId (optional) 
     * @param productTypeId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter8(startCoverDate: dayjs.Dayjs, endCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, refundHeaderStatusId?: string | undefined, productTypeId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportrefundheader/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (endCoverDate === undefined || endCoverDate === null)
            throw new Error("The parameter 'endCoverDate' must be defined and cannot be null.");
        else
            url_ += "EndCoverDate=" + encodeURIComponent(endCoverDate ? "" + endCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (refundHeaderStatusId === null)
            throw new Error("The parameter 'refundHeaderStatusId' cannot be null.");
        else if (refundHeaderStatusId !== undefined)
            url_ += "RefundHeaderStatusId=" + encodeURIComponent("" + refundHeaderStatusId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter8(_response);
        });
    }

    protected processFilter8(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-14	รายงานการคืนเงิน (RFG)
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param refundHeaderStatusId (optional) 
     * @param productTypeId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    reportrefundheader(startCoverDate: dayjs.Dayjs, endCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, refundHeaderStatusId?: string | undefined, productTypeId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportrefundheader?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (endCoverDate === undefined || endCoverDate === null)
            throw new Error("The parameter 'endCoverDate' must be defined and cannot be null.");
        else
            url_ += "EndCoverDate=" + encodeURIComponent(endCoverDate ? "" + endCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (refundHeaderStatusId === null)
            throw new Error("The parameter 'refundHeaderStatusId' cannot be null.");
        else if (refundHeaderStatusId !== undefined)
            url_ += "RefundHeaderStatusId=" + encodeURIComponent("" + refundHeaderStatusId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportrefundheader(_response);
        });
    }

    protected processReportrefundheader(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-15	รายงานการคืนเงิน (RF)
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param refundHeaderStatusId (optional) 
     * @param productTypeId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter9(startCoverDate: dayjs.Dayjs, endCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, refundHeaderStatusId?: string | undefined, productTypeId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportrefunddetail/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (endCoverDate === undefined || endCoverDate === null)
            throw new Error("The parameter 'endCoverDate' must be defined and cannot be null.");
        else
            url_ += "EndCoverDate=" + encodeURIComponent(endCoverDate ? "" + endCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (refundHeaderStatusId === null)
            throw new Error("The parameter 'refundHeaderStatusId' cannot be null.");
        else if (refundHeaderStatusId !== undefined)
            url_ += "RefundHeaderStatusId=" + encodeURIComponent("" + refundHeaderStatusId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter9(_response);
        });
    }

    protected processFilter9(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-15	รายงานการคืนเงิน (RF)
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param refundHeaderStatusId (optional) 
     * @param productTypeId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    reportrefunddetail(startCoverDate: dayjs.Dayjs, endCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, refundHeaderStatusId?: string | undefined, productTypeId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportrefunddetail?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (endCoverDate === undefined || endCoverDate === null)
            throw new Error("The parameter 'endCoverDate' must be defined and cannot be null.");
        else
            url_ += "EndCoverDate=" + encodeURIComponent(endCoverDate ? "" + endCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (refundHeaderStatusId === null)
            throw new Error("The parameter 'refundHeaderStatusId' cannot be null.");
        else if (refundHeaderStatusId !== undefined)
            url_ += "RefundHeaderStatusId=" + encodeURIComponent("" + refundHeaderStatusId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportrefunddetail(_response);
        });
    }

    protected processReportrefunddetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  UI-9-16 รายงานการล้างหนี้หักธนาคาร
     * @param bankId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter10(debtPeriod: dayjs.Dayjs, bankId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportsummaryheaderrecurringbank/filter?";
        if (debtPeriod === undefined || debtPeriod === null)
            throw new Error("The parameter 'debtPeriod' must be defined and cannot be null.");
        else
            url_ += "DebtPeriod=" + encodeURIComponent(debtPeriod ? "" + debtPeriod.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter10(_response);
        });
    }

    protected processFilter10(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-16 รายงานการล้างหนี้หักธนาคาร
     * @return OK
     */
    reportsummaryheaderrecurringbank(summaryHeaderId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportsummaryheaderrecurringbank?";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined and cannot be null.");
        else
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportsummaryheaderrecurringbank(_response);
        });
    }

    protected processReportsummaryheaderrecurringbank(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-16 รายงานหักธนาคารล่วงหน้าไม่ได้
     * @return OK
     */
    reportsummaryheaderrecurringbankcannotdeduct(summaryHeaderId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportsummaryheaderrecurringbankcannotdeduct?";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined and cannot be null.");
        else
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportsummaryheaderrecurringbankcannotdeduct(_response);
        });
    }

    protected processReportsummaryheaderrecurringbankcannotdeduct(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR3-3 รายงานแอพขึ้นจัดเก็บที่ไม่ได้รับชำระ
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter11(period: dayjs.Dayjs, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportdebtoverduedate/filter?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter11(_response);
        });
    }

    protected processFilter11(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR3-3 รายงานแอพขึ้นจัดเก็บที่ไม่ได้รับชำระ
     * @return OK
     */
    reportdebtoverduedate(period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportdebtoverduedate?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportdebtoverduedate(_response);
        });
    }

    protected processReportdebtoverduedate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-7	รายงาน บัญชีธนาคารที่ไม่ส่งหัก
     * @param bankId (optional) 
     * @param period (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter12(bankId?: number | undefined, period?: dayjs.Dayjs | undefined, searchIndex?: string | undefined, searchText?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportbankaccountnotrecurring/filter?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter12(_response);
        });
    }

    protected processFilter12(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-7 รายงาน บัญชีธนาคารที่ไม่ส่งหัก
     * @param bankId (optional) 
     * @param period (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @return OK
     */
    reportbankaccountnotrecurring(bankId?: number | undefined, period?: dayjs.Dayjs | undefined, searchIndex?: string | undefined, searchText?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportbankaccountnotrecurring?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportbankaccountnotrecurring(_response);
        });
    }

    protected processReportbankaccountnotrecurring(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR3-8 รายงานบัญชีที่หักไม่สำเร็จ : สาเหตุจากธนาคาร
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param period (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter13(debtGroupReferTypeId?: number | undefined, bankId?: number | undefined, period?: dayjs.Dayjs | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportbankaccountunsuccessrecurring/filter?";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter13(_response);
        });
    }

    protected processFilter13(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR3-8 รายงานบัญชีที่หักไม่สำเร็จ : สาเหตุจากธนาคาร
     * @return OK
     */
    reportbankaccountunsuccessrecurring(summaryHeaderId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportbankaccountunsuccessrecurring/{summaryHeaderId}";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined.");
        url_ = url_.replace("{summaryHeaderId}", encodeURIComponent("" + summaryHeaderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportbankaccountunsuccessrecurring(_response);
        });
    }

    protected processReportbankaccountunsuccessrecurring(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-14	รายงาน New App สำหรับฝ่ายเบี้ย
     * @param paymentMethodTypeId (optional) 
     * @param bankId (optional) 
     * @param productGroupId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter14(startCoverDate: dayjs.Dayjs, paymentMethodTypeId?: string | undefined, bankId?: string | undefined, productGroupId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportnewapppremium/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter14(_response);
        });
    }

    protected processFilter14(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-14	รายงาน New App สำหรับฝ่ายเบี้ย
     * @param startCoverDate (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param bankId (optional) 
     * @param productGroupId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    reportnewapppremium(startCoverDate?: dayjs.Dayjs | undefined, paymentMethodTypeId?: string | undefined, bankId?: string | undefined, productGroupId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportnewapppremium?";
        if (startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' cannot be null.");
        else if (startCoverDate !== undefined)
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportnewapppremium(_response);
        });
    }

    protected processReportnewapppremium(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * CR6-2 PaymentHistoryHeader
     * @return OK
     */
    getpaymenthistoryheader(applicationCode: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/getpaymenthistoryheader/{applicationCode}";
        if (applicationCode === undefined || applicationCode === null)
            throw new Error("The parameter 'applicationCode' must be defined.");
        url_ = url_.replace("{applicationCode}", encodeURIComponent("" + applicationCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetpaymenthistoryheader(_response);
        });
    }

    protected processGetpaymenthistoryheader(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * CR6-2 PaymentHistoryList
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    data(applicationCode: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/getpaymenthistorylist/data?";
        if (applicationCode === undefined || applicationCode === null)
            throw new Error("The parameter 'applicationCode' must be defined and cannot be null.");
        else
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processData(_response);
        });
    }

    protected processData(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * CR6-2 GetPaymentHistoryDetail
     * @return OK
     */
    getpaymenthistorydetail(iN: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/getpaymenthistorydetail/{IN}";
        if (iN === undefined || iN === null)
            throw new Error("The parameter 'iN' must be defined.");
        url_ = url_.replace("{IN}", encodeURIComponent("" + iN));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetpaymenthistorydetail(_response);
        });
    }

    protected processGetpaymenthistorydetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-18	รายงาน Summary ตั้งหนี้สาขา แยกช่องทางการชำระ
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter15(period: dayjs.Dayjs, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportdebtbranchdebtgrouprefertype/filter?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter15(_response);
        });
    }

    protected processFilter15(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-18	รายงาน Summary ตั้งหนี้สาขา แยกช่องทางการชำระ
     * @param branchId (optional) 
     * @return OK
     */
    reportdebtbranchdebtgrouprefertype(period: dayjs.Dayjs, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportdebtbranchdebtgrouprefertype?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportdebtbranchdebtgrouprefertype(_response);
        });
    }

    protected processReportdebtbranchdebtgrouprefertype(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-19	รายงาน Summary ตั้งหนี้สาขา แยกผลิตภัณฑ์
     * @param debtGroupReferTypeId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter16(period: dayjs.Dayjs, debtGroupReferTypeId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportdebtbranchproductgroup/filter?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter16(_response);
        });
    }

    protected processFilter16(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-19	รายงาน Summary ตั้งหนี้สาขา แยกผลิตภัณฑ์
     * @param debtGroupReferTypeId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    reportdebtbranchproductgroup(period: dayjs.Dayjs, debtGroupReferTypeId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/reportdebtbranchproductgroup?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportdebtbranchproductgroup(_response);
        });
    }

    protected processReportdebtbranchproductgroup(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-23 รายงานจัดเก็บเบี้ยพื้นที่ (คิดผลงาน)
     * @param orderingFeild (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    filter17(debtPeriod: dayjs.Dayjs, orderingFeild?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/reportdebtreportcollectdetail/filter?";
        if (debtPeriod === undefined || debtPeriod === null)
            throw new Error("The parameter 'debtPeriod' must be defined and cannot be null.");
        else
            url_ += "DebtPeriod=" + encodeURIComponent(debtPeriod ? "" + debtPeriod.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (orderingFeild === null)
            throw new Error("The parameter 'orderingFeild' cannot be null.");
        else if (orderingFeild !== undefined)
            url_ += "OrderingFeild=" + encodeURIComponent("" + orderingFeild) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter17(_response);
        });
    }

    protected processFilter17(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel  CR 3-23 รายงานจัดเก็บเบี้ยพื้นที่ (คิดผลงาน)
     * @param debtPeriod (optional) 
     * @return OK
     */
    debtreportcollectdetail(debtPeriod?: dayjs.Dayjs | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/debtreportcollectdetail?";
        if (debtPeriod === null)
            throw new Error("The parameter 'debtPeriod' cannot be null.");
        else if (debtPeriod !== undefined)
            url_ += "DebtPeriod=" + encodeURIComponent(debtPeriod ? "" + debtPeriod.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtreportcollectdetail(_response);
        });
    }

    protected processDebtreportcollectdetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-27  รายงาน New App v2
     * @param debtGroupReferTypeId (optional) 
     * @param productGroupId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param payerBranchId (optional) 
     * @param saleBranchId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param searchIndex (optional) 
     * @param textSearch (optional) 
     * @param paymentStatus (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    filter18(startCoverDate: dayjs.Dayjs, debtGroupReferTypeId?: string | undefined, productGroupId?: string | undefined, paymentMethodTypeId?: string | undefined, payerBranchId?: string | undefined, saleBranchId?: string | undefined, saleEmployeeCode?: string | undefined, searchIndex?: string | undefined, textSearch?: string | undefined, paymentStatus?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/newappreportv2/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (payerBranchId === null)
            throw new Error("The parameter 'payerBranchId' cannot be null.");
        else if (payerBranchId !== undefined)
            url_ += "PayerBranchId=" + encodeURIComponent("" + payerBranchId) + "&";
        if (saleBranchId === null)
            throw new Error("The parameter 'saleBranchId' cannot be null.");
        else if (saleBranchId !== undefined)
            url_ += "SaleBranchId=" + encodeURIComponent("" + saleBranchId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter18(_response);
        });
    }

    protected processFilter18(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-27  รายงาน New App v2
     * @param debtGroupReferTypeId (optional) 
     * @param productGroupId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param payerBranchId (optional) 
     * @param saleBranchId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param searchIndex (optional) 
     * @param textSearch (optional) 
     * @param paymentStatus (optional) 
     * @return OK
     */
    newappreportv2(startCoverDate: dayjs.Dayjs, debtGroupReferTypeId?: string | undefined, productGroupId?: string | undefined, paymentMethodTypeId?: string | undefined, payerBranchId?: string | undefined, saleBranchId?: string | undefined, saleEmployeeCode?: string | undefined, searchIndex?: string | undefined, textSearch?: string | undefined, paymentStatus?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/download/newappreportv2?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (payerBranchId === null)
            throw new Error("The parameter 'payerBranchId' cannot be null.");
        else if (payerBranchId !== undefined)
            url_ += "PayerBranchId=" + encodeURIComponent("" + payerBranchId) + "&";
        if (saleBranchId === null)
            throw new Error("The parameter 'saleBranchId' cannot be null.");
        else if (saleBranchId !== undefined)
            url_ += "SaleBranchId=" + encodeURIComponent("" + saleBranchId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewappreportv2(_response);
        });
    }

    protected processNewappreportv2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PremiumReportV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-1	รายงานการตั้งหนี้ New App
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatus (optional) 
     * @param productTypeId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportDebtNewAppV2(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatus?: string | undefined, productTypeId?: string | undefined, paymentMethodTypeId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetDebtNewAppReportDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/newappreport/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtNewAppV2(_response);
        });
    }

    protected processGetReportDebtNewAppV2(response: AxiosResponse): Promise<GetDebtNewAppReportDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDebtNewAppReportDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDebtNewAppReportDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-1	รายงานการตั้งหนี้ New App
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatus (optional) 
     * @param productTypeId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    downloadDebtNewAppReportV2(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatus?: string | undefined, productTypeId?: string | undefined, paymentMethodTypeId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/newappreport?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadDebtNewAppReportV2(_response);
        });
    }

    protected processDownloadDebtNewAppReportV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-5	รายงานการตั้งหนี้ ขึ้นจัดเก็บ สาขาผู้ชำระเบี้ย
     * @param searchText (optional) 
     * @param searchIndex (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param paymentChannelId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportDebtCollectV2(period: dayjs.Dayjs, searchText?: string | undefined, searchIndex?: string | undefined, debtGroupReferTypeId?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, paymentChannelId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportDebtCollectDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportdebtcollect/filter?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentChannelId === null)
            throw new Error("The parameter 'paymentChannelId' cannot be null.");
        else if (paymentChannelId !== undefined)
            url_ += "PaymentChannelId=" + encodeURIComponent("" + paymentChannelId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtCollectV2(_response);
        });
    }

    protected processGetReportDebtCollectV2(response: AxiosResponse): Promise<GetReportDebtCollectDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportDebtCollectDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportDebtCollectDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-5 รายงานการตั้งหนี้ ขึ้นจัดเก็บ สาขาผู้ชำระเบี้ย
     * @param searchText (optional) 
     * @param searchIndex (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param paymentChannelId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    downloadReportDebtCollectV2(period: dayjs.Dayjs, searchText?: string | undefined, searchIndex?: string | undefined, debtGroupReferTypeId?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, paymentChannelId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportdebtcollect?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentChannelId === null)
            throw new Error("The parameter 'paymentChannelId' cannot be null.");
        else if (paymentChannelId !== undefined)
            url_ += "PaymentChannelId=" + encodeURIComponent("" + paymentChannelId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportDebtCollectV2(_response);
        });
    }

    protected processDownloadReportDebtCollectV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-7 รายงานหักบัญชีธนาคาร : ต่ออายุรายเดือน
     * @param searchText (optional) 
     * @param searchIndex (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportDebtMonthlyReNewV2(period: dayjs.Dayjs, searchText?: string | undefined, searchIndex?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportDebtMonthlyReNewDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportdebtmonthlyrenew/filter?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtMonthlyReNewV2(_response);
        });
    }

    protected processGetReportDebtMonthlyReNewV2(response: AxiosResponse): Promise<GetReportDebtMonthlyReNewDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportDebtMonthlyReNewDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportDebtMonthlyReNewDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-7 รายงานหักบัญชีธนาคาร : ต่ออายุรายเดือน
     * @param searchText (optional) 
     * @param searchIndex (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatusId (optional) 
     * @param productGroupId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    downloadReportDebtMonthlyReNewV2(period: dayjs.Dayjs, searchText?: string | undefined, searchIndex?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatusId?: string | undefined, productGroupId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportdebtmonthlyrenew?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportDebtMonthlyReNewV2(_response);
        });
    }

    protected processDownloadReportDebtMonthlyReNewV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-9	รายงานการตั้งหนี้ คืนความคุ้มครอง
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatus (optional) 
     * @param productTypeId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportDebtRefundV2(startCoverDate: dayjs.Dayjs, indexSearch: number, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatus?: number | undefined, productTypeId?: number | undefined, paymentMethodTypeId?: number | undefined, branchId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportDebtRecoverDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportdebtrefund/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (indexSearch === undefined || indexSearch === null)
            throw new Error("The parameter 'indexSearch' must be defined and cannot be null.");
        else
            url_ += "IndexSearch=" + encodeURIComponent("" + indexSearch) + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtRefundV2(_response);
        });
    }

    protected processGetReportDebtRefundV2(response: AxiosResponse): Promise<GetReportDebtRecoverDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportDebtRecoverDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportDebtRecoverDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-9 รายงานการตั้งหนี้ คืนความคุ้มครอง
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param paymentStatus (optional) 
     * @param productTypeId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    downloadReportDebtRefundV2(startCoverDate: dayjs.Dayjs, indexSearch: number, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, paymentStatus?: number | undefined, productTypeId?: number | undefined, paymentMethodTypeId?: number | undefined, branchId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportdebtrefund?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (indexSearch === undefined || indexSearch === null)
            throw new Error("The parameter 'indexSearch' must be defined and cannot be null.");
        else
            url_ += "IndexSearch=" + encodeURIComponent("" + indexSearch) + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportDebtRefundV2(_response);
        });
    }

    protected processDownloadReportDebtRefundV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-11	รายงานการหักบัญชีธนาคาร (RD)
     * @param textSearch (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param recurringStatusId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportRecurringDetailV2(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, recurringStatusId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportRecurringDetailDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportrecurringdetail/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (recurringStatusId === null)
            throw new Error("The parameter 'recurringStatusId' cannot be null.");
        else if (recurringStatusId !== undefined)
            url_ += "RecurringStatusId=" + encodeURIComponent("" + recurringStatusId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportRecurringDetailV2(_response);
        });
    }

    protected processGetReportRecurringDetailV2(response: AxiosResponse): Promise<GetReportRecurringDetailDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportRecurringDetailDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportRecurringDetailDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-11	รายงานการหักบัญชีธนาคาร (RD)
     * @param textSearch (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param recurringStatusId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    downloadReportRecurringDetailV2(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, recurringStatusId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportrecurringdetail?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (recurringStatusId === null)
            throw new Error("The parameter 'recurringStatusId' cannot be null.");
        else if (recurringStatusId !== undefined)
            url_ += "RecurringStatusId=" + encodeURIComponent("" + recurringStatusId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportRecurringDetailV2(_response);
        });
    }

    protected processDownloadReportRecurringDetailV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-12	รายงาน Summary ผลหักตามบัญชี
     * @param payableDate (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param productTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportRecurringBankV2(debtPeriod: dayjs.Dayjs, payableDate?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, productTypeId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportRecurringBankDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportrecurringbank/filter?";
        if (debtPeriod === undefined || debtPeriod === null)
            throw new Error("The parameter 'debtPeriod' must be defined and cannot be null.");
        else
            url_ += "DebtPeriod=" + encodeURIComponent(debtPeriod ? "" + debtPeriod.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payableDate === null)
            throw new Error("The parameter 'payableDate' cannot be null.");
        else if (payableDate !== undefined)
            url_ += "PayableDate=" + encodeURIComponent("" + payableDate) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportRecurringBankV2(_response);
        });
    }

    protected processGetReportRecurringBankV2(response: AxiosResponse): Promise<GetReportRecurringBankDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportRecurringBankDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportRecurringBankDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-12	รายงาน Summary ผลหักตามบัญชี
     * @param payableDate (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param productTypeId (optional) 
     * @return OK
     */
    downloadReportRecurringBankV2(debtPeriod: dayjs.Dayjs, payableDate?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, productTypeId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportrecurringbank?";
        if (debtPeriod === undefined || debtPeriod === null)
            throw new Error("The parameter 'debtPeriod' must be defined and cannot be null.");
        else
            url_ += "DebtPeriod=" + encodeURIComponent(debtPeriod ? "" + debtPeriod.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payableDate === null)
            throw new Error("The parameter 'payableDate' cannot be null.");
        else if (payableDate !== undefined)
            url_ += "PayableDate=" + encodeURIComponent("" + payableDate) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportRecurringBankV2(_response);
        });
    }

    protected processDownloadReportRecurringBankV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-13	รายงานผลการส่งหักเบี้ยธนาคาร (RB) แยกตามสาขาผู้ชำระเบี้ย
     * @param textSearch (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param recurringStatusId (optional) 
     * @param branchId (optional) 
     * @param productTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportRecurringBranchV2(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, recurringStatusId?: string | undefined, branchId?: string | undefined, productTypeId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportRecurringBranchDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportrecurringbranch/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (recurringStatusId === null)
            throw new Error("The parameter 'recurringStatusId' cannot be null.");
        else if (recurringStatusId !== undefined)
            url_ += "RecurringStatusId=" + encodeURIComponent("" + recurringStatusId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportRecurringBranchV2(_response);
        });
    }

    protected processGetReportRecurringBranchV2(response: AxiosResponse): Promise<GetReportRecurringBranchDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportRecurringBranchDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportRecurringBranchDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-13	รายงานผลการส่งหักเบี้ยธนาคาร (RB) แยกตามสาขาผู้ชำระเบี้ย
     * @param textSearch (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param recurringStatusId (optional) 
     * @param branchId (optional) 
     * @param productTypeId (optional) 
     * @return OK
     */
    downloadReportRecurringBranchV2(startCoverDate: dayjs.Dayjs, textSearch?: string | undefined, summaryHeaderStatusId?: string | undefined, debtGroupReferTypeId?: string | undefined, bankId?: string | undefined, recurringStatusId?: string | undefined, branchId?: string | undefined, productTypeId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportrecurringbranch?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (recurringStatusId === null)
            throw new Error("The parameter 'recurringStatusId' cannot be null.");
        else if (recurringStatusId !== undefined)
            url_ += "RecurringStatusId=" + encodeURIComponent("" + recurringStatusId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportRecurringBranchV2(_response);
        });
    }

    protected processDownloadReportRecurringBranchV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-14	รายงานการคืนเงิน (RFG)
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param refundHeaderStatusId (optional) 
     * @param productTypeId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportRefundHeaderV2(startCoverDate: dayjs.Dayjs, endCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, refundHeaderStatusId?: string | undefined, productTypeId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportRefundHeaderDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportrefundheader/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (endCoverDate === undefined || endCoverDate === null)
            throw new Error("The parameter 'endCoverDate' must be defined and cannot be null.");
        else
            url_ += "EndCoverDate=" + encodeURIComponent(endCoverDate ? "" + endCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (refundHeaderStatusId === null)
            throw new Error("The parameter 'refundHeaderStatusId' cannot be null.");
        else if (refundHeaderStatusId !== undefined)
            url_ += "RefundHeaderStatusId=" + encodeURIComponent("" + refundHeaderStatusId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportRefundHeaderV2(_response);
        });
    }

    protected processGetReportRefundHeaderV2(response: AxiosResponse): Promise<GetReportRefundHeaderDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportRefundHeaderDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportRefundHeaderDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-14	รายงานการคืนเงิน (RFG)
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param refundHeaderStatusId (optional) 
     * @param productTypeId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    downloadReportRefundHeaderV2(startCoverDate: dayjs.Dayjs, endCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, refundHeaderStatusId?: string | undefined, productTypeId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportrefundheader?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (endCoverDate === undefined || endCoverDate === null)
            throw new Error("The parameter 'endCoverDate' must be defined and cannot be null.");
        else
            url_ += "EndCoverDate=" + encodeURIComponent(endCoverDate ? "" + endCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (refundHeaderStatusId === null)
            throw new Error("The parameter 'refundHeaderStatusId' cannot be null.");
        else if (refundHeaderStatusId !== undefined)
            url_ += "RefundHeaderStatusId=" + encodeURIComponent("" + refundHeaderStatusId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportRefundHeaderV2(_response);
        });
    }

    protected processDownloadReportRefundHeaderV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล UI-9-15	รายงานการคืนเงิน (RF)
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param refundHeaderStatusId (optional) 
     * @param productTypeId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportRefundDetailV2(startCoverDate: dayjs.Dayjs, endCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, refundHeaderStatusId?: string | undefined, productTypeId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportRefundDetailDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportrefunddetail/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (endCoverDate === undefined || endCoverDate === null)
            throw new Error("The parameter 'endCoverDate' must be defined and cannot be null.");
        else
            url_ += "EndCoverDate=" + encodeURIComponent(endCoverDate ? "" + endCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (refundHeaderStatusId === null)
            throw new Error("The parameter 'refundHeaderStatusId' cannot be null.");
        else if (refundHeaderStatusId !== undefined)
            url_ += "RefundHeaderStatusId=" + encodeURIComponent("" + refundHeaderStatusId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportRefundDetailV2(_response);
        });
    }

    protected processGetReportRefundDetailV2(response: AxiosResponse): Promise<GetReportRefundDetailDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportRefundDetailDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportRefundDetailDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-15	รายงานการคืนเงิน (RF)
     * @param textSearch (optional) 
     * @param saleEmployeeCode (optional) 
     * @param refundHeaderStatusId (optional) 
     * @param productTypeId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    downloadReportRefundDetailV2(startCoverDate: dayjs.Dayjs, endCoverDate: dayjs.Dayjs, textSearch?: string | undefined, saleEmployeeCode?: string | undefined, refundHeaderStatusId?: string | undefined, productTypeId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportrefunddetail?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (endCoverDate === undefined || endCoverDate === null)
            throw new Error("The parameter 'endCoverDate' must be defined and cannot be null.");
        else
            url_ += "EndCoverDate=" + encodeURIComponent(endCoverDate ? "" + endCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (refundHeaderStatusId === null)
            throw new Error("The parameter 'refundHeaderStatusId' cannot be null.");
        else if (refundHeaderStatusId !== undefined)
            url_ += "RefundHeaderStatusId=" + encodeURIComponent("" + refundHeaderStatusId) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "ProductTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportRefundDetailV2(_response);
        });
    }

    protected processDownloadReportRefundDetailV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  UI-9-16 รายงานการล้างหนี้หักธนาคาร
     * @param bankId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportSummaryHeaderRecurringBankV2(debtPeriod: dayjs.Dayjs, bankId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetSummaryHeaderRecurringBankDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportsummaryheaderrecurringbank/filter?";
        if (debtPeriod === undefined || debtPeriod === null)
            throw new Error("The parameter 'debtPeriod' must be defined and cannot be null.");
        else
            url_ += "DebtPeriod=" + encodeURIComponent(debtPeriod ? "" + debtPeriod.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportSummaryHeaderRecurringBankV2(_response);
        });
    }

    protected processGetReportSummaryHeaderRecurringBankV2(response: AxiosResponse): Promise<GetSummaryHeaderRecurringBankDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetSummaryHeaderRecurringBankDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetSummaryHeaderRecurringBankDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-16 รายงานการล้างหนี้หักธนาคาร
     * @return OK
     */
    downloadReportSummaryHeaderRecurringBankV2(summaryHeaderId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportsummaryheaderrecurringbank?";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined and cannot be null.");
        else
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportSummaryHeaderRecurringBankV2(_response);
        });
    }

    protected processDownloadReportSummaryHeaderRecurringBankV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel UI-9-16 รายงานหักธนาคารล่วงหน้าไม่ได้
     * @return OK
     */
    downloadGetSummaryHeaderRecurringBankCannotDeductV2(summaryHeaderId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportsummaryheaderrecurringbankcannotdeduct?";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined and cannot be null.");
        else
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadGetSummaryHeaderRecurringBankCannotDeductV2(_response);
        });
    }

    protected processDownloadGetSummaryHeaderRecurringBankCannotDeductV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR3-3 รายงานแอพขึ้นจัดเก็บที่ไม่ได้รับชำระ
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportDebtOverdueDateV2(period: dayjs.Dayjs, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportDebtOverdueDate_ReponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportdebtoverduedate/filter?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtOverdueDateV2(_response);
        });
    }

    protected processGetReportDebtOverdueDateV2(response: AxiosResponse): Promise<GetReportDebtOverdueDate_ReponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportDebtOverdueDate_ReponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportDebtOverdueDate_ReponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR3-3 รายงานแอพขึ้นจัดเก็บที่ไม่ได้รับชำระ
     * @return OK
     */
    downloadGetReportDebtOverdueDateV2(period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportdebtoverduedate?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadGetReportDebtOverdueDateV2(_response);
        });
    }

    protected processDownloadGetReportDebtOverdueDateV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-7	รายงาน บัญชีธนาคารที่ไม่ส่งหัก
     * @param bankId (optional) 
     * @param period (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportBankAccountNotRecurringV2(bankId?: number | undefined, period?: dayjs.Dayjs | undefined, searchIndex?: string | undefined, searchText?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportBankAccountNotRecurringDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportbankaccountnotrecurring/filter?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportBankAccountNotRecurringV2(_response);
        });
    }

    protected processGetReportBankAccountNotRecurringV2(response: AxiosResponse): Promise<GetReportBankAccountNotRecurringDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportBankAccountNotRecurringDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportBankAccountNotRecurringDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-7 รายงาน บัญชีธนาคารที่ไม่ส่งหัก
     * @param bankId (optional) 
     * @param period (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @return OK
     */
    downloadReportBankAccountNotRecurringV2(bankId?: number | undefined, period?: dayjs.Dayjs | undefined, searchIndex?: string | undefined, searchText?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportbankaccountnotrecurring?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportBankAccountNotRecurringV2(_response);
        });
    }

    protected processDownloadReportBankAccountNotRecurringV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR3-8 รายงานบัญชีที่หักไม่สำเร็จ : สาเหตุจากธนาคาร
     * @param debtGroupReferTypeId (optional) 
     * @param bankId (optional) 
     * @param period (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportBankAccountUnSuccessRecurringV2(debtGroupReferTypeId?: number | undefined, bankId?: number | undefined, period?: dayjs.Dayjs | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportBankAccountUnSuccessRecurringDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportbankaccountunsuccessrecurring/filter?";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportBankAccountUnSuccessRecurringV2(_response);
        });
    }

    protected processGetReportBankAccountUnSuccessRecurringV2(response: AxiosResponse): Promise<GetReportBankAccountUnSuccessRecurringDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportBankAccountUnSuccessRecurringDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportBankAccountUnSuccessRecurringDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR3-8 รายงานบัญชีที่หักไม่สำเร็จ : สาเหตุจากธนาคาร
     * @return OK
     */
    downloadGetReportBankAccountUnSuccessRecurringV2(summaryHeaderId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportbankaccountunsuccessrecurring/{summaryHeaderId}";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined.");
        url_ = url_.replace("{summaryHeaderId}", encodeURIComponent("" + summaryHeaderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadGetReportBankAccountUnSuccessRecurringV2(_response);
        });
    }

    protected processDownloadGetReportBankAccountUnSuccessRecurringV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-14	รายงาน New App สำหรับฝ่ายเบี้ย
     * @param paymentMethodTypeId (optional) 
     * @param bankId (optional) 
     * @param productGroupId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportNewAppPremiumV2(startCoverDate: dayjs.Dayjs, paymentMethodTypeId?: string | undefined, bankId?: string | undefined, productGroupId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportNewAppPremiumDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportnewapppremium/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportNewAppPremiumV2(_response);
        });
    }

    protected processGetReportNewAppPremiumV2(response: AxiosResponse): Promise<GetReportNewAppPremiumDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportNewAppPremiumDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportNewAppPremiumDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-14	รายงาน New App สำหรับฝ่ายเบี้ย
     * @param startCoverDate (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param bankId (optional) 
     * @param productGroupId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    downloadGetReportNewAppPremiumV2(startCoverDate?: dayjs.Dayjs | undefined, paymentMethodTypeId?: string | undefined, bankId?: string | undefined, productGroupId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportnewapppremium?";
        if (startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' cannot be null.");
        else if (startCoverDate !== undefined)
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadGetReportNewAppPremiumV2(_response);
        });
    }

    protected processDownloadGetReportNewAppPremiumV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * CR6-2 PaymentHistoryHeader
     * @return OK
     */
    getPaymentHistoryHeaderV2(applicationCode: string, cancelToken?: CancelToken | undefined): Promise<Usp_PaymentHistoryHeader_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/report/getpaymenthistoryheader/{applicationCode}";
        if (applicationCode === undefined || applicationCode === null)
            throw new Error("The parameter 'applicationCode' must be defined.");
        url_ = url_.replace("{applicationCode}", encodeURIComponent("" + applicationCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaymentHistoryHeaderV2(_response);
        });
    }

    protected processGetPaymentHistoryHeaderV2(response: AxiosResponse): Promise<Usp_PaymentHistoryHeader_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_PaymentHistoryHeader_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_PaymentHistoryHeader_SelectResultListServiceResponse>(null as any);
    }

    /**
     * CR6-2 PaymentHistoryList
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getPaymentHistoryListV2(applicationCode: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_PaymentHistoryList_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/getpaymenthistorylist/data?";
        if (applicationCode === undefined || applicationCode === null)
            throw new Error("The parameter 'applicationCode' must be defined and cannot be null.");
        else
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaymentHistoryListV2(_response);
        });
    }

    protected processGetPaymentHistoryListV2(response: AxiosResponse): Promise<Usp_PaymentHistoryList_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_PaymentHistoryList_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_PaymentHistoryList_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * CR6-2 GetPaymentHistoryDetail
     * @return OK
     */
    getPaymentHistoryDetailV2(iN: string, cancelToken?: CancelToken | undefined): Promise<Usp_PaymentHistoryDetail_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/report/getpaymenthistorydetail/{IN}";
        if (iN === undefined || iN === null)
            throw new Error("The parameter 'iN' must be defined.");
        url_ = url_.replace("{IN}", encodeURIComponent("" + iN));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaymentHistoryDetailV2(_response);
        });
    }

    protected processGetPaymentHistoryDetailV2(response: AxiosResponse): Promise<Usp_PaymentHistoryDetail_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_PaymentHistoryDetail_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_PaymentHistoryDetail_SelectResultListServiceResponse>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-18	รายงาน Summary ตั้งหนี้สาขา แยกช่องทางการชำระ
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportDebtBranchDebtGroupReferTypeV2(period: dayjs.Dayjs, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportDebtBranchDebtGroupReferTypeDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportdebtbranchdebtgrouprefertype/filter?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtBranchDebtGroupReferTypeV2(_response);
        });
    }

    protected processGetReportDebtBranchDebtGroupReferTypeV2(response: AxiosResponse): Promise<GetReportDebtBranchDebtGroupReferTypeDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportDebtBranchDebtGroupReferTypeDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportDebtBranchDebtGroupReferTypeDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-18	รายงาน Summary ตั้งหนี้สาขา แยกช่องทางการชำระ
     * @param branchId (optional) 
     * @return OK
     */
    downloadGetReportDebtBranchDebtGroupReferTypeV2(period: dayjs.Dayjs, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportdebtbranchdebtgrouprefertype?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadGetReportDebtBranchDebtGroupReferTypeV2(_response);
        });
    }

    protected processDownloadGetReportDebtBranchDebtGroupReferTypeV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-19	รายงาน Summary ตั้งหนี้สาขา แยกผลิตภัณฑ์
     * @param debtGroupReferTypeId (optional) 
     * @param branchId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getReportDebtBranchProductGroupV2(period: dayjs.Dayjs, debtGroupReferTypeId?: string | undefined, branchId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetReportDebtBranchProductGroupDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportdebtbranchproductgroup/filter?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtBranchProductGroupV2(_response);
        });
    }

    protected processGetReportDebtBranchProductGroupV2(response: AxiosResponse): Promise<GetReportDebtBranchProductGroupDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetReportDebtBranchProductGroupDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetReportDebtBranchProductGroupDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-19	รายงาน Summary ตั้งหนี้สาขา แยกผลิตภัณฑ์
     * @param debtGroupReferTypeId (optional) 
     * @param branchId (optional) 
     * @return OK
     */
    downloadGetReportDebtBranchProductGroupV2(period: dayjs.Dayjs, debtGroupReferTypeId?: string | undefined, branchId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportdebtbranchproductgroup?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadGetReportDebtBranchProductGroupV2(_response);
        });
    }

    protected processDownloadGetReportDebtBranchProductGroupV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-23 รายงานจัดเก็บเบี้ยพื้นที่ (คิดผลงาน)
     * @param orderingFeild (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getDebtReportCollectDetailV2(debtPeriod: dayjs.Dayjs, orderingFeild?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetDebtReportCollectSaleDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/reportdebtreportcollectdetail/filter?";
        if (debtPeriod === undefined || debtPeriod === null)
            throw new Error("The parameter 'debtPeriod' must be defined and cannot be null.");
        else
            url_ += "DebtPeriod=" + encodeURIComponent(debtPeriod ? "" + debtPeriod.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (orderingFeild === null)
            throw new Error("The parameter 'orderingFeild' cannot be null.");
        else if (orderingFeild !== undefined)
            url_ += "OrderingFeild=" + encodeURIComponent("" + orderingFeild) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtReportCollectDetailV2(_response);
        });
    }

    protected processGetDebtReportCollectDetailV2(response: AxiosResponse): Promise<GetDebtReportCollectSaleDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDebtReportCollectSaleDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorize", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDebtReportCollectSaleDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel  CR 3-23 รายงานจัดเก็บเบี้ยพื้นที่ (คิดผลงาน)
     * @param debtPeriod (optional) 
     * @return OK
     */
    downloadGetDebtReportCollectDetailV2(debtPeriod?: dayjs.Dayjs | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/debtreportcollectdetail?";
        if (debtPeriod === null)
            throw new Error("The parameter 'debtPeriod' cannot be null.");
        else if (debtPeriod !== undefined)
            url_ += "DebtPeriod=" + encodeURIComponent(debtPeriod ? "" + debtPeriod.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadGetDebtReportCollectDetailV2(_response);
        });
    }

    protected processDownloadGetDebtReportCollectDetailV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * สำหรับ ดึงข้อมูล  CR 3-27  รายงาน New App v2
     * @param debtGroupReferTypeId (optional) 
     * @param productGroupId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param payerBranchId (optional) 
     * @param saleBranchId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param searchIndex (optional) 
     * @param textSearch (optional) 
     * @param paymentStatus (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getReportDebtNewAppV2V2(startCoverDate: dayjs.Dayjs, debtGroupReferTypeId?: string | undefined, productGroupId?: string | undefined, paymentMethodTypeId?: string | undefined, payerBranchId?: string | undefined, saleBranchId?: string | undefined, saleEmployeeCode?: string | undefined, searchIndex?: string | undefined, textSearch?: string | undefined, paymentStatus?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetDebtNewAppReportDtoV2_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/report/newappreportv2/filter?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (payerBranchId === null)
            throw new Error("The parameter 'payerBranchId' cannot be null.");
        else if (payerBranchId !== undefined)
            url_ += "PayerBranchId=" + encodeURIComponent("" + payerBranchId) + "&";
        if (saleBranchId === null)
            throw new Error("The parameter 'saleBranchId' cannot be null.");
        else if (saleBranchId !== undefined)
            url_ += "SaleBranchId=" + encodeURIComponent("" + saleBranchId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReportDebtNewAppV2V2(_response);
        });
    }

    protected processGetReportDebtNewAppV2V2(response: AxiosResponse): Promise<GetDebtNewAppReportDtoV2_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDebtNewAppReportDtoV2_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDebtNewAppReportDtoV2_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * สำหรับ ดาวโหลดข้อมูล TO Excel CR 3-27  รายงาน New App v2
     * @param debtGroupReferTypeId (optional) 
     * @param productGroupId (optional) 
     * @param paymentMethodTypeId (optional) 
     * @param payerBranchId (optional) 
     * @param saleBranchId (optional) 
     * @param saleEmployeeCode (optional) 
     * @param searchIndex (optional) 
     * @param textSearch (optional) 
     * @param paymentStatus (optional) 
     * @return OK
     */
    downloadDebtNewAppReportV2V2(startCoverDate: dayjs.Dayjs, debtGroupReferTypeId?: string | undefined, productGroupId?: string | undefined, paymentMethodTypeId?: string | undefined, payerBranchId?: string | undefined, saleBranchId?: string | undefined, saleEmployeeCode?: string | undefined, searchIndex?: string | undefined, textSearch?: string | undefined, paymentStatus?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/newappreportv2?";
        if (startCoverDate === undefined || startCoverDate === null)
            throw new Error("The parameter 'startCoverDate' must be defined and cannot be null.");
        else
            url_ += "StartCoverDate=" + encodeURIComponent(startCoverDate ? "" + startCoverDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentMethodTypeId === null)
            throw new Error("The parameter 'paymentMethodTypeId' cannot be null.");
        else if (paymentMethodTypeId !== undefined)
            url_ += "PaymentMethodTypeId=" + encodeURIComponent("" + paymentMethodTypeId) + "&";
        if (payerBranchId === null)
            throw new Error("The parameter 'payerBranchId' cannot be null.");
        else if (payerBranchId !== undefined)
            url_ += "PayerBranchId=" + encodeURIComponent("" + payerBranchId) + "&";
        if (saleBranchId === null)
            throw new Error("The parameter 'saleBranchId' cannot be null.");
        else if (saleBranchId !== undefined)
            url_ += "SaleBranchId=" + encodeURIComponent("" + saleBranchId) + "&";
        if (saleEmployeeCode === null)
            throw new Error("The parameter 'saleEmployeeCode' cannot be null.");
        else if (saleEmployeeCode !== undefined)
            url_ += "SaleEmployeeCode=" + encodeURIComponent("" + saleEmployeeCode) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (textSearch === null)
            throw new Error("The parameter 'textSearch' cannot be null.");
        else if (textSearch !== undefined)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "PaymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadDebtNewAppReportV2V2(_response);
        });
    }

    protected processDownloadDebtNewAppReportV2V2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    downloadReportDebtReNewPeriod(body?: GetReportDebtReNewPeriodRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/download/reportdebtrenewperiod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportDebtReNewPeriod(_response);
        });
    }

    protected processDownloadReportDebtReNewPeriod(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PremiumV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Get BillPayment // สำหรับลูกค้า ไม่มี Authorize
     * @return OK
     */
    getBillPaymentV2(summaryDetailCode: string, cancelToken?: CancelToken | undefined): Promise<GetBillPaymentDto_ResponseServiceResponse> {
        let url_ = this.baseUrl + "/v2/premium/billpayment/{summaryDetailCode}";
        if (summaryDetailCode === undefined || summaryDetailCode === null)
            throw new Error("The parameter 'summaryDetailCode' must be defined.");
        url_ = url_.replace("{summaryDetailCode}", encodeURIComponent("" + summaryDetailCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBillPaymentV2(_response);
        });
    }

    protected processGetBillPaymentV2(response: AxiosResponse): Promise<GetBillPaymentDto_ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetBillPaymentDto_ResponseServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBillPaymentDto_ResponseServiceResponse>(null as any);
    }

    /**
     * Get Pay Slip  // สำหรับลูกค้า ไม่มี Authorize
     * @return OK
     */
    getPaySlipV2(summaryDetailCode: string, cancelToken?: CancelToken | undefined): Promise<GetPaySlipDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/payslip/{summaryDetailCode}";
        if (summaryDetailCode === undefined || summaryDetailCode === null)
            throw new Error("The parameter 'summaryDetailCode' must be defined.");
        url_ = url_.replace("{summaryDetailCode}", encodeURIComponent("" + summaryDetailCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaySlipV2(_response);
        });
    }

    protected processGetPaySlipV2(response: AxiosResponse): Promise<GetPaySlipDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetPaySlipDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPaySlipDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Debt
     * @param billNo (optional) 
     * @return OK
     */
    getDebtV2(debtHeaderId: string, billNo?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetDebtDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/debt?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (billNo === null)
            throw new Error("The parameter 'billNo' cannot be null.");
        else if (billNo !== undefined)
            url_ += "BillNo=" + encodeURIComponent("" + billNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtV2(_response);
        });
    }

    protected processGetDebtV2(response: AxiosResponse): Promise<GetDebtDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDebtDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDebtDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get BillPayment by Debt header
     * @return OK
     */
    getBillPaymentByDebtHeaderV2(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<GetBillPaymentDto_ResponseServiceResponse> {
        let url_ = this.baseUrl + "/v2/premium/billpaymentbydebtheader/{debtHeaderId}";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined.");
        url_ = url_.replace("{debtHeaderId}", encodeURIComponent("" + debtHeaderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBillPaymentByDebtHeaderV2(_response);
        });
    }

    protected processGetBillPaymentByDebtHeaderV2(response: AxiosResponse): Promise<GetBillPaymentDto_ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetBillPaymentDto_ResponseServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBillPaymentDto_ResponseServiceResponse>(null as any);
    }

    /**
     * Get GenBillingAndPaySlip
     * @return OK
     */
    genBillingAndPaySlipV2(billing: string, cancelToken?: CancelToken | undefined): Promise<Usp_GenBillingAndPaySlip_TestResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/genbillingandpayslip/{billing}";
        if (billing === undefined || billing === null)
            throw new Error("The parameter 'billing' must be defined.");
        url_ = url_.replace("{billing}", encodeURIComponent("" + billing));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenBillingAndPaySlipV2(_response);
        });
    }

    protected processGenBillingAndPaySlipV2(response: AxiosResponse): Promise<Usp_GenBillingAndPaySlip_TestResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_GenBillingAndPaySlip_TestResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_GenBillingAndPaySlip_TestResultListServiceResponse>(null as any);
    }

    /**
     * Get Summary FileNo To Excel
     * @param summaryFileNoId (optional) 
     * @return OK
     */
    getSummaryFileNoToExcelV2(summaryHeaderId: string, summaryFileNoId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/recurring/summaryfilenotoexcel?";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined and cannot be null.");
        else
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        if (summaryFileNoId === null)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else if (summaryFileNoId !== undefined)
            url_ += "SummaryFileNoId=" + encodeURIComponent("" + summaryFileNoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummaryFileNoToExcelV2(_response);
        });
    }

    protected processGetSummaryFileNoToExcelV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * SummaryFileNoExportFile
     * @param summaryFileNoId (optional) 
     * @return OK
     */
    getSummaryFileNoExportFileV2(summaryHeaderId: string, summaryFileNoId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/recurring/summaryfilenoexportfile?";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined and cannot be null.");
        else
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        if (summaryFileNoId === null)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else if (summaryFileNoId !== undefined)
            url_ += "SummaryFileNoId=" + encodeURIComponent("" + summaryFileNoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummaryFileNoExportFileV2(_response);
        });
    }

    protected processGetSummaryFileNoExportFileV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Summary FileNo Error To Excel
     * @return OK
     */
    getSummaryFileNoErrorToExcelV2(tempId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/recurring/summaryfilenoerror?";
        if (tempId === undefined || tempId === null)
            throw new Error("The parameter 'tempId' must be defined and cannot be null.");
        else
            url_ += "tempId=" + encodeURIComponent("" + tempId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummaryFileNoErrorToExcelV2(_response);
        });
    }

    protected processGetSummaryFileNoErrorToExcelV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Summary Insert
     * @param body (optional) 
     * @return OK
     */
    summaryInsertV2(body?: SummaryInsertDto_Request | undefined, cancelToken?: CancelToken | undefined): Promise<SummaryInsertDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/summary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummaryInsertV2(_response);
        });
    }

    protected processSummaryInsertV2(response: AxiosResponse): Promise<SummaryInsertDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SummaryInsertDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SummaryInsertDtoServiceResponse>(null as any);
    }

    /**
     * Summary Header Status Update
     * @return OK
     */
    summaryHeaderStatusUpdateV2(summaryHeaderId: string, cancelToken?: CancelToken | undefined): Promise<Usp_SummaryHeaderStatus_UpdateResultServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/summaryheaderstatus?";
        if (summaryHeaderId === undefined || summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' must be defined and cannot be null.");
        else
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummaryHeaderStatusUpdateV2(_response);
        });
    }

    protected processSummaryHeaderStatusUpdateV2(response: AxiosResponse): Promise<Usp_SummaryHeaderStatus_UpdateResultServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_SummaryHeaderStatus_UpdateResultServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_SummaryHeaderStatus_UpdateResultServiceResponse>(null as any);
    }

    /**
     * Temp Result For Bank Manual
     * @param summaryFileNoId (optional) 
     * @param bankId (optional) 
     * @param transactionDateTime (optional) 
     * @param file (optional) 
     * @return OK
     */
    tempResultForBankManualV2(summaryFileNoId?: string | undefined, bankId?: number | undefined, transactionDateTime?: dayjs.Dayjs | undefined, file?: FileParameter | undefined, cancelToken?: CancelToken | undefined): Promise<TempResultForBankManualDto_ResponseServiceResponse> {
        let url_ = this.baseUrl + "/v2/upload/tempresultforbankmanual";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (summaryFileNoId === null || summaryFileNoId === undefined)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else
            content_.append("SummaryFileNoId", summaryFileNoId.toString());
        if (bankId === null || bankId === undefined)
            throw new Error("The parameter 'bankId' cannot be null.");
        else
            content_.append("BankId", bankId.toString());
        if (transactionDateTime === null || transactionDateTime === undefined)
            throw new Error("The parameter 'transactionDateTime' cannot be null.");
        else
            content_.append("TransactionDateTime", transactionDateTime.toJSON());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempResultForBankManualV2(_response);
        });
    }

    protected processTempResultForBankManualV2(response: AxiosResponse): Promise<TempResultForBankManualDto_ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<TempResultForBankManualDto_ResponseServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TempResultForBankManualDto_ResponseServiceResponse>(null as any);
    }

    /**
     * TempResultForBankManualFormatBank
     * @param summaryFileNoId (optional) 
     * @param bankId (optional) 
     * @param transactionDateTime (optional) 
     * @param file (optional) 
     * @return OK
     */
    tempResultForBankManualFormatBankV2(summaryFileNoId?: string | undefined, bankId?: number | undefined, transactionDateTime?: dayjs.Dayjs | undefined, file?: FileParameter | undefined, cancelToken?: CancelToken | undefined): Promise<TempResultForBankManualDto_ResponseServiceResponse> {
        let url_ = this.baseUrl + "/v2/upload/tempresultforbankmanualformatbank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (summaryFileNoId === null || summaryFileNoId === undefined)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else
            content_.append("SummaryFileNoId", summaryFileNoId.toString());
        if (bankId === null || bankId === undefined)
            throw new Error("The parameter 'bankId' cannot be null.");
        else
            content_.append("BankId", bankId.toString());
        if (transactionDateTime === null || transactionDateTime === undefined)
            throw new Error("The parameter 'transactionDateTime' cannot be null.");
        else
            content_.append("TransactionDateTime", transactionDateTime.toJSON());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempResultForBankManualFormatBankV2(_response);
        });
    }

    protected processTempResultForBankManualFormatBankV2(response: AxiosResponse): Promise<TempResultForBankManualDto_ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<TempResultForBankManualDto_ResponseServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TempResultForBankManualDto_ResponseServiceResponse>(null as any);
    }

    /**
     * Temp Result To Summary For Bank Manual Update
     * @param tempId (optional) 
     * @return OK
     */
    tempResultToSummaryForBankManualUpdateV2(tempId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_TempResultToSummary_ForBankManual_UpdateResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/tempresulttosummaryforbankmanualupdate?";
        if (tempId === null)
            throw new Error("The parameter 'tempId' cannot be null.");
        else if (tempId !== undefined)
            url_ += "tempId=" + encodeURIComponent("" + tempId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempResultToSummaryForBankManualUpdateV2(_response);
        });
    }

    protected processTempResultToSummaryForBankManualUpdateV2(response: AxiosResponse): Promise<Usp_TempResultToSummary_ForBankManual_UpdateResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_TempResultToSummary_ForBankManual_UpdateResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_TempResultToSummary_ForBankManual_UpdateResultListServiceResponse>(null as any);
    }

    /**
     * Get DebtGroupConfirmToSummarys
     * @param searchText (optional) 
     * @param debtGroupCode (optional) 
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param debtGroupStatusListId (optional) 
     * @param debtGroupReferTypeListId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtGroupConfirmToSummarysV2(searchText?: string | undefined, debtGroupCode?: string | undefined, dateFrom?: dayjs.Dayjs | undefined, dateTo?: dayjs.Dayjs | undefined, debtGroupStatusListId?: string | undefined, debtGroupReferTypeListId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DebtGroupConfirmToSummary_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debtgroupconfirmtosummarys?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (debtGroupCode === null)
            throw new Error("The parameter 'debtGroupCode' cannot be null.");
        else if (debtGroupCode !== undefined)
            url_ += "DebtGroupCode=" + encodeURIComponent("" + debtGroupCode) + "&";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupStatusListId === null)
            throw new Error("The parameter 'debtGroupStatusListId' cannot be null.");
        else if (debtGroupStatusListId !== undefined)
            url_ += "DebtGroupStatusListId=" + encodeURIComponent("" + debtGroupStatusListId) + "&";
        if (debtGroupReferTypeListId === null)
            throw new Error("The parameter 'debtGroupReferTypeListId' cannot be null.");
        else if (debtGroupReferTypeListId !== undefined)
            url_ += "DebtGroupReferTypeListId=" + encodeURIComponent("" + debtGroupReferTypeListId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtGroupConfirmToSummarysV2(_response);
        });
    }

    protected processGetDebtGroupConfirmToSummarysV2(response: AxiosResponse): Promise<Usp_DebtGroupConfirmToSummary_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtGroupConfirmToSummary_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtGroupConfirmToSummary_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get DebtDetailConfirmToSummarys
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtDetailConfirmToSummarysV2(debtGroupId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DebtDetailConfirmToSummary_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debtdetailconfirmtosummarys?";
        if (debtGroupId === undefined || debtGroupId === null)
            throw new Error("The parameter 'debtGroupId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupId=" + encodeURIComponent("" + debtGroupId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtDetailConfirmToSummarysV2(_response);
        });
    }

    protected processGetDebtDetailConfirmToSummarysV2(response: AxiosResponse): Promise<Usp_DebtDetailConfirmToSummary_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtDetailConfirmToSummary_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtDetailConfirmToSummary_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get Batchs
     * @param searchDetail (optional) 
     * @param debtGroupCode (optional) 
     * @param summaryHeaderCode (optional) 
     * @param payableDateFrom (optional) 
     * @param payableDateTo (optional) 
     * @param bankId (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param sourceTypeId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getBatchsV2(searchDetail?: string | undefined, debtGroupCode?: string | undefined, summaryHeaderCode?: string | undefined, payableDateFrom?: dayjs.Dayjs | undefined, payableDateTo?: dayjs.Dayjs | undefined, bankId?: string | undefined, summaryHeaderStatusId?: string | undefined, sourceTypeId?: number | undefined, debtGroupReferTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetBatchsDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/batchs?";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (debtGroupCode === null)
            throw new Error("The parameter 'debtGroupCode' cannot be null.");
        else if (debtGroupCode !== undefined)
            url_ += "DebtGroupCode=" + encodeURIComponent("" + debtGroupCode) + "&";
        if (summaryHeaderCode === null)
            throw new Error("The parameter 'summaryHeaderCode' cannot be null.");
        else if (summaryHeaderCode !== undefined)
            url_ += "SummaryHeaderCode=" + encodeURIComponent("" + summaryHeaderCode) + "&";
        if (payableDateFrom === null)
            throw new Error("The parameter 'payableDateFrom' cannot be null.");
        else if (payableDateFrom !== undefined)
            url_ += "PayableDateFrom=" + encodeURIComponent(payableDateFrom ? "" + payableDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payableDateTo === null)
            throw new Error("The parameter 'payableDateTo' cannot be null.");
        else if (payableDateTo !== undefined)
            url_ += "PayableDateTo=" + encodeURIComponent(payableDateTo ? "" + payableDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (sourceTypeId === null)
            throw new Error("The parameter 'sourceTypeId' cannot be null.");
        else if (sourceTypeId !== undefined)
            url_ += "SourceTypeId=" + encodeURIComponent("" + sourceTypeId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBatchsV2(_response);
        });
    }

    protected processGetBatchsV2(response: AxiosResponse): Promise<GetBatchsDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetBatchsDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBatchsDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get All Batch Files
     * @param summaryHeaderId (optional) 
     * @param summaryFileNoId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getAllBatchFilesV2(summaryHeaderId?: string | undefined, summaryFileNoId?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetAllBatchFilesDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/allbatchfiles?";
        if (summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' cannot be null.");
        else if (summaryHeaderId !== undefined)
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        if (summaryFileNoId === null)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else if (summaryFileNoId !== undefined)
            url_ += "SummaryFileNoId=" + encodeURIComponent("" + summaryFileNoId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllBatchFilesV2(_response);
        });
    }

    protected processGetAllBatchFilesV2(response: AxiosResponse): Promise<GetAllBatchFilesDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetAllBatchFilesDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllBatchFilesDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get Batch Details
     * @param searchDetail (optional) 
     * @param summaryHeaderId (optional) 
     * @param summaryHeaderStatusId (optional) 
     * @param summaryFileNoId (optional) 
     * @param isSucceed (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getBatchDetailsV2(searchDetail?: string | undefined, summaryHeaderId?: string | undefined, summaryHeaderStatusId?: string | undefined, summaryFileNoId?: string | undefined, isSucceed?: boolean | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetBatchDetailsDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/batchdetails?";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' cannot be null.");
        else if (summaryHeaderId !== undefined)
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        if (summaryHeaderStatusId === null)
            throw new Error("The parameter 'summaryHeaderStatusId' cannot be null.");
        else if (summaryHeaderStatusId !== undefined)
            url_ += "SummaryHeaderStatusId=" + encodeURIComponent("" + summaryHeaderStatusId) + "&";
        if (summaryFileNoId === null)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else if (summaryFileNoId !== undefined)
            url_ += "SummaryFileNoId=" + encodeURIComponent("" + summaryFileNoId) + "&";
        if (isSucceed === null)
            throw new Error("The parameter 'isSucceed' cannot be null.");
        else if (isSucceed !== undefined)
            url_ += "IsSucceed=" + encodeURIComponent("" + isSucceed) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBatchDetailsV2(_response);
        });
    }

    protected processGetBatchDetailsV2(response: AxiosResponse): Promise<GetBatchDetailsDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetBatchDetailsDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetBatchDetailsDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET SummaryDetailXRefDebt
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getSummaryDetailXRefDebtV2(summaryDetailId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<SummaryDetailXRefDebtsDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/summarydetailxrefdebt?";
        if (summaryDetailId === undefined || summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' must be defined and cannot be null.");
        else
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummaryDetailXRefDebtV2(_response);
        });
    }

    protected processGetSummaryDetailXRefDebtV2(response: AxiosResponse): Promise<SummaryDetailXRefDebtsDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SummaryDetailXRefDebtsDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SummaryDetailXRefDebtsDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * Temp Result For Bank Manual Preview
     * @param tempId (optional) 
     * @return OK
     */
    getTempResultForBankManualPreviewV2(tempId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_TempResultForBankManual_PreviewResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/tempresultforbankmanualpreview?";
        if (tempId === null)
            throw new Error("The parameter 'tempId' cannot be null.");
        else if (tempId !== undefined)
            url_ += "tempId=" + encodeURIComponent("" + tempId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTempResultForBankManualPreviewV2(_response);
        });
    }

    protected processGetTempResultForBankManualPreviewV2(response: AxiosResponse): Promise<Usp_TempResultForBankManual_PreviewResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_TempResultForBankManual_PreviewResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_TempResultForBankManual_PreviewResultListServiceResponse>(null as any);
    }

    /**
     * Get CountResultForBankManual
     * @return OK
     */
    getCountResultForBankManualV2(tempId: string, cancelToken?: CancelToken | undefined): Promise<Usp_TempResultForBankManualCount_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/tempId/{tempId}";
        if (tempId === undefined || tempId === null)
            throw new Error("The parameter 'tempId' must be defined.");
        url_ = url_.replace("{tempId}", encodeURIComponent("" + tempId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCountResultForBankManualV2(_response);
        });
    }

    protected processGetCountResultForBankManualV2(response: AxiosResponse): Promise<Usp_TempResultForBankManualCount_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_TempResultForBankManualCount_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_TempResultForBankManualCount_SelectResultListServiceResponse>(null as any);
    }

    /**
     * Get Debts
     * @param searchDetail (optional) 
     * @param payablePeriodFromStart (optional) 
     * @param payablePeriodFromEnd (optional) 
     * @param payablePeriodToStart (optional) 
     * @param payablePeriodToEnd (optional) 
     * @param productName (optional) 
     * @param productGruopName (optional) 
     * @param paymentStatusId (optional) 
     * @param transactionDatetimeStart (optional) 
     * @param transactionDatetimeEnd (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtsV2(searchDetail?: string | undefined, payablePeriodFromStart?: dayjs.Dayjs | undefined, payablePeriodFromEnd?: dayjs.Dayjs | undefined, payablePeriodToStart?: dayjs.Dayjs | undefined, payablePeriodToEnd?: dayjs.Dayjs | undefined, productName?: string | undefined, productGruopName?: string | undefined, paymentStatusId?: string | undefined, transactionDatetimeStart?: dayjs.Dayjs | undefined, transactionDatetimeEnd?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_Debts_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debts?";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (payablePeriodFromStart === null)
            throw new Error("The parameter 'payablePeriodFromStart' cannot be null.");
        else if (payablePeriodFromStart !== undefined)
            url_ += "PayablePeriodFromStart=" + encodeURIComponent(payablePeriodFromStart ? "" + payablePeriodFromStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodFromEnd === null)
            throw new Error("The parameter 'payablePeriodFromEnd' cannot be null.");
        else if (payablePeriodFromEnd !== undefined)
            url_ += "PayablePeriodFromEnd=" + encodeURIComponent(payablePeriodFromEnd ? "" + payablePeriodFromEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToStart === null)
            throw new Error("The parameter 'payablePeriodToStart' cannot be null.");
        else if (payablePeriodToStart !== undefined)
            url_ += "PayablePeriodToStart=" + encodeURIComponent(payablePeriodToStart ? "" + payablePeriodToStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToEnd === null)
            throw new Error("The parameter 'payablePeriodToEnd' cannot be null.");
        else if (payablePeriodToEnd !== undefined)
            url_ += "PayablePeriodToEnd=" + encodeURIComponent(payablePeriodToEnd ? "" + payablePeriodToEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productName === null)
            throw new Error("The parameter 'productName' cannot be null.");
        else if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&";
        if (productGruopName === null)
            throw new Error("The parameter 'productGruopName' cannot be null.");
        else if (productGruopName !== undefined)
            url_ += "ProductGruopName=" + encodeURIComponent("" + productGruopName) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (transactionDatetimeStart === null)
            throw new Error("The parameter 'transactionDatetimeStart' cannot be null.");
        else if (transactionDatetimeStart !== undefined)
            url_ += "TransactionDatetimeStart=" + encodeURIComponent(transactionDatetimeStart ? "" + transactionDatetimeStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeEnd === null)
            throw new Error("The parameter 'transactionDatetimeEnd' cannot be null.");
        else if (transactionDatetimeEnd !== undefined)
            url_ += "TransactionDatetimeEnd=" + encodeURIComponent(transactionDatetimeEnd ? "" + transactionDatetimeEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtsV2(_response);
        });
    }

    protected processGetDebtsV2(response: AxiosResponse): Promise<Usp_Debts_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_Debts_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_Debts_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get Debts V4
     * @param payablePeriodFromStart (optional) 
     * @param payablePeriodFromEnd (optional) 
     * @param payablePeriodToStart (optional) 
     * @param payablePeriodToEnd (optional) 
     * @param productNameList (optional) 
     * @param productGroupNameList (optional) 
     * @param paymentStatusIdList (optional) 
     * @param transactionDatetimeStart (optional) 
     * @param transactionDatetimeEnd (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param b (optional) 
     * @param iN (optional) 
     * @param applicationCode (optional) 
     * @param payerName (optional) 
     * @param custName (optional) 
     * @param viewPoint (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtsV4V2(payablePeriodFromStart?: dayjs.Dayjs | undefined, payablePeriodFromEnd?: dayjs.Dayjs | undefined, payablePeriodToStart?: dayjs.Dayjs | undefined, payablePeriodToEnd?: dayjs.Dayjs | undefined, productNameList?: string | undefined, productGroupNameList?: string | undefined, paymentStatusIdList?: string | undefined, transactionDatetimeStart?: dayjs.Dayjs | undefined, transactionDatetimeEnd?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, b?: string | undefined, iN?: string | undefined, applicationCode?: string | undefined, payerName?: string | undefined, custName?: string | undefined, viewPoint?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_Debts_Select_v4ResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debtsv4?";
        if (payablePeriodFromStart === null)
            throw new Error("The parameter 'payablePeriodFromStart' cannot be null.");
        else if (payablePeriodFromStart !== undefined)
            url_ += "PayablePeriodFromStart=" + encodeURIComponent(payablePeriodFromStart ? "" + payablePeriodFromStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodFromEnd === null)
            throw new Error("The parameter 'payablePeriodFromEnd' cannot be null.");
        else if (payablePeriodFromEnd !== undefined)
            url_ += "PayablePeriodFromEnd=" + encodeURIComponent(payablePeriodFromEnd ? "" + payablePeriodFromEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToStart === null)
            throw new Error("The parameter 'payablePeriodToStart' cannot be null.");
        else if (payablePeriodToStart !== undefined)
            url_ += "PayablePeriodToStart=" + encodeURIComponent(payablePeriodToStart ? "" + payablePeriodToStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToEnd === null)
            throw new Error("The parameter 'payablePeriodToEnd' cannot be null.");
        else if (payablePeriodToEnd !== undefined)
            url_ += "PayablePeriodToEnd=" + encodeURIComponent(payablePeriodToEnd ? "" + payablePeriodToEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productNameList === null)
            throw new Error("The parameter 'productNameList' cannot be null.");
        else if (productNameList !== undefined)
            url_ += "ProductNameList=" + encodeURIComponent("" + productNameList) + "&";
        if (productGroupNameList === null)
            throw new Error("The parameter 'productGroupNameList' cannot be null.");
        else if (productGroupNameList !== undefined)
            url_ += "ProductGroupNameList=" + encodeURIComponent("" + productGroupNameList) + "&";
        if (paymentStatusIdList === null)
            throw new Error("The parameter 'paymentStatusIdList' cannot be null.");
        else if (paymentStatusIdList !== undefined)
            url_ += "PaymentStatusIdList=" + encodeURIComponent("" + paymentStatusIdList) + "&";
        if (transactionDatetimeStart === null)
            throw new Error("The parameter 'transactionDatetimeStart' cannot be null.");
        else if (transactionDatetimeStart !== undefined)
            url_ += "TransactionDatetimeStart=" + encodeURIComponent(transactionDatetimeStart ? "" + transactionDatetimeStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeEnd === null)
            throw new Error("The parameter 'transactionDatetimeEnd' cannot be null.");
        else if (transactionDatetimeEnd !== undefined)
            url_ += "TransactionDatetimeEnd=" + encodeURIComponent(transactionDatetimeEnd ? "" + transactionDatetimeEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (iN === null)
            throw new Error("The parameter 'iN' cannot be null.");
        else if (iN !== undefined)
            url_ += "IN=" + encodeURIComponent("" + iN) + "&";
        if (applicationCode === null)
            throw new Error("The parameter 'applicationCode' cannot be null.");
        else if (applicationCode !== undefined)
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (custName === null)
            throw new Error("The parameter 'custName' cannot be null.");
        else if (custName !== undefined)
            url_ += "CustName=" + encodeURIComponent("" + custName) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtsV4V2(_response);
        });
    }

    protected processGetDebtsV4V2(response: AxiosResponse): Promise<Usp_Debts_Select_v4ResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_Debts_Select_v4ResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_Debts_Select_v4ResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET DebtPeriods
     * @param productNameList (optional) 
     * @param productGroupNameList (optional) 
     * @param paymentStatusIdList (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param b (optional) 
     * @param iN (optional) 
     * @param applicationCode (optional) 
     * @param payerName (optional) 
     * @param custName (optional) 
     * @param viewPoint (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtPeriodsV2(period: dayjs.Dayjs, productNameList?: string | undefined, productGroupNameList?: string | undefined, paymentStatusIdList?: string | undefined, debtGroupReferTypeId?: number | undefined, b?: string | undefined, iN?: string | undefined, applicationCode?: string | undefined, payerName?: string | undefined, custName?: string | undefined, viewPoint?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DebtPeriods_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debtperiods?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productNameList === null)
            throw new Error("The parameter 'productNameList' cannot be null.");
        else if (productNameList !== undefined)
            url_ += "ProductNameList=" + encodeURIComponent("" + productNameList) + "&";
        if (productGroupNameList === null)
            throw new Error("The parameter 'productGroupNameList' cannot be null.");
        else if (productGroupNameList !== undefined)
            url_ += "ProductGroupNameList=" + encodeURIComponent("" + productGroupNameList) + "&";
        if (paymentStatusIdList === null)
            throw new Error("The parameter 'paymentStatusIdList' cannot be null.");
        else if (paymentStatusIdList !== undefined)
            url_ += "PaymentStatusIdList=" + encodeURIComponent("" + paymentStatusIdList) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (iN === null)
            throw new Error("The parameter 'iN' cannot be null.");
        else if (iN !== undefined)
            url_ += "IN=" + encodeURIComponent("" + iN) + "&";
        if (applicationCode === null)
            throw new Error("The parameter 'applicationCode' cannot be null.");
        else if (applicationCode !== undefined)
            url_ += "ApplicationCode=" + encodeURIComponent("" + applicationCode) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (custName === null)
            throw new Error("The parameter 'custName' cannot be null.");
        else if (custName !== undefined)
            url_ += "CustName=" + encodeURIComponent("" + custName) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtPeriodsV2(_response);
        });
    }

    protected processGetDebtPeriodsV2(response: AxiosResponse): Promise<Usp_DebtPeriods_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtPeriods_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtPeriods_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET DebtPeriods V2
     * @param productId (optional) 
     * @param productGroupId (optional) 
     * @param paymentStatusId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param viewPoint (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtPeriodsV2V2(period: dayjs.Dayjs, productId?: number | undefined, productGroupId?: number | undefined, paymentStatusId?: number | undefined, debtGroupReferTypeId?: number | undefined, searchIndex?: number | undefined, searchText?: string | undefined, viewPoint?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DebtPeriodsNew_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debtperiodsv2?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (productGroupId === null)
            throw new Error("The parameter 'productGroupId' cannot be null.");
        else if (productGroupId !== undefined)
            url_ += "ProductGroupId=" + encodeURIComponent("" + productGroupId) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtPeriodsV2V2(_response);
        });
    }

    protected processGetDebtPeriodsV2V2(response: AxiosResponse): Promise<Usp_DebtPeriodsNew_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtPeriodsNew_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtPeriodsNew_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get DebtsUser
     * @param searchDetail (optional) 
     * @param payablePeriodFromStart (optional) 
     * @param payablePeriodFromEnd (optional) 
     * @param payablePeriodToStart (optional) 
     * @param payablePeriodToEnd (optional) 
     * @param productName (optional) 
     * @param productGruopName (optional) 
     * @param paymentStatusId (optional) 
     * @param transactionDatetimeStart (optional) 
     * @param transactionDatetimeEnd (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtsUserV2(searchDetail?: string | undefined, payablePeriodFromStart?: dayjs.Dayjs | undefined, payablePeriodFromEnd?: dayjs.Dayjs | undefined, payablePeriodToStart?: dayjs.Dayjs | undefined, payablePeriodToEnd?: dayjs.Dayjs | undefined, productName?: string | undefined, productGruopName?: string | undefined, paymentStatusId?: string | undefined, transactionDatetimeStart?: dayjs.Dayjs | undefined, transactionDatetimeEnd?: dayjs.Dayjs | undefined, debtGroupReferTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetDebtsDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debsuser?";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (payablePeriodFromStart === null)
            throw new Error("The parameter 'payablePeriodFromStart' cannot be null.");
        else if (payablePeriodFromStart !== undefined)
            url_ += "PayablePeriodFromStart=" + encodeURIComponent(payablePeriodFromStart ? "" + payablePeriodFromStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodFromEnd === null)
            throw new Error("The parameter 'payablePeriodFromEnd' cannot be null.");
        else if (payablePeriodFromEnd !== undefined)
            url_ += "PayablePeriodFromEnd=" + encodeURIComponent(payablePeriodFromEnd ? "" + payablePeriodFromEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToStart === null)
            throw new Error("The parameter 'payablePeriodToStart' cannot be null.");
        else if (payablePeriodToStart !== undefined)
            url_ += "PayablePeriodToStart=" + encodeURIComponent(payablePeriodToStart ? "" + payablePeriodToStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (payablePeriodToEnd === null)
            throw new Error("The parameter 'payablePeriodToEnd' cannot be null.");
        else if (payablePeriodToEnd !== undefined)
            url_ += "PayablePeriodToEnd=" + encodeURIComponent(payablePeriodToEnd ? "" + payablePeriodToEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (productName === null)
            throw new Error("The parameter 'productName' cannot be null.");
        else if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&";
        if (productGruopName === null)
            throw new Error("The parameter 'productGruopName' cannot be null.");
        else if (productGruopName !== undefined)
            url_ += "ProductGruopName=" + encodeURIComponent("" + productGruopName) + "&";
        if (paymentStatusId === null)
            throw new Error("The parameter 'paymentStatusId' cannot be null.");
        else if (paymentStatusId !== undefined)
            url_ += "PaymentStatusId=" + encodeURIComponent("" + paymentStatusId) + "&";
        if (transactionDatetimeStart === null)
            throw new Error("The parameter 'transactionDatetimeStart' cannot be null.");
        else if (transactionDatetimeStart !== undefined)
            url_ += "TransactionDatetimeStart=" + encodeURIComponent(transactionDatetimeStart ? "" + transactionDatetimeStart.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transactionDatetimeEnd === null)
            throw new Error("The parameter 'transactionDatetimeEnd' cannot be null.");
        else if (transactionDatetimeEnd !== undefined)
            url_ += "TransactionDatetimeEnd=" + encodeURIComponent(transactionDatetimeEnd ? "" + transactionDatetimeEnd.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtsUserV2(_response);
        });
    }

    protected processGetDebtsUserV2(response: AxiosResponse): Promise<GetDebtsDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDebtsDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDebtsDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get Debt Details
     * @param debtHeaderId (optional) 
     * @param debtGroupReferTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtDetailsV2(debtHeaderId?: string | undefined, debtGroupReferTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetDebtDetailsDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debtdetails?";
        if (debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' cannot be null.");
        else if (debtHeaderId !== undefined)
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtDetailsV2(_response);
        });
    }

    protected processGetDebtDetailsV2(response: AxiosResponse): Promise<GetDebtDetailsDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDebtDetailsDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDebtDetailsDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET Application
     * @return OK
     */
    getApplicationV2(applicationCode: string, cancelToken?: CancelToken | undefined): Promise<Usp_Application_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/application/{applicationCode}";
        if (applicationCode === undefined || applicationCode === null)
            throw new Error("The parameter 'applicationCode' must be defined.");
        url_ = url_.replace("{applicationCode}", encodeURIComponent("" + applicationCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetApplicationV2(_response);
        });
    }

    protected processGetApplicationV2(response: AxiosResponse): Promise<Usp_Application_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_Application_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_Application_SelectResultListServiceResponse>(null as any);
    }

    /**
     * GET Debt History
     * @return OK
     */
    getDebtHistoryV2(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<GetDebtHistoryDto_ResponseServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/debthistory?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "debtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtHistoryV2(_response);
        });
    }

    protected processGetDebtHistoryV2(response: AxiosResponse): Promise<GetDebtHistoryDto_ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDebtHistoryDto_ResponseServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDebtHistoryDto_ResponseServiceResponse>(null as any);
    }

    /**
     * GET Debt Events History
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtEventsHistoryV2(debtHeaderId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<GetDebtEventsHistoryDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debteventshistory?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtEventsHistoryV2(_response);
        });
    }

    protected processGetDebtEventsHistoryV2(response: AxiosResponse): Promise<GetDebtEventsHistoryDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDebtEventsHistoryDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDebtEventsHistoryDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get Refund Headers
     * @param searchDetail (optional) 
     * @param bankId (optional) 
     * @param refundHeaderStatusId (optional) 
     * @param transferDateFrom (optional) 
     * @param transferDateTo (optional) 
     * @param appCode (optional) 
     * @param payerName (optional) 
     * @param payerIdentityCard (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getRefundHeadersV2(searchDetail?: string | undefined, bankId?: string | undefined, refundHeaderStatusId?: string | undefined, transferDateFrom?: dayjs.Dayjs | undefined, transferDateTo?: dayjs.Dayjs | undefined, appCode?: string | undefined, payerName?: string | undefined, payerIdentityCard?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<RefundHeadersDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/refundheaders?";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (refundHeaderStatusId === null)
            throw new Error("The parameter 'refundHeaderStatusId' cannot be null.");
        else if (refundHeaderStatusId !== undefined)
            url_ += "RefundHeaderStatusId=" + encodeURIComponent("" + refundHeaderStatusId) + "&";
        if (transferDateFrom === null)
            throw new Error("The parameter 'transferDateFrom' cannot be null.");
        else if (transferDateFrom !== undefined)
            url_ += "TransferDateFrom=" + encodeURIComponent(transferDateFrom ? "" + transferDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transferDateTo === null)
            throw new Error("The parameter 'transferDateTo' cannot be null.");
        else if (transferDateTo !== undefined)
            url_ += "TransferDateTo=" + encodeURIComponent(transferDateTo ? "" + transferDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (appCode === null)
            throw new Error("The parameter 'appCode' cannot be null.");
        else if (appCode !== undefined)
            url_ += "AppCode=" + encodeURIComponent("" + appCode) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (payerIdentityCard === null)
            throw new Error("The parameter 'payerIdentityCard' cannot be null.");
        else if (payerIdentityCard !== undefined)
            url_ += "PayerIdentityCard=" + encodeURIComponent("" + payerIdentityCard) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRefundHeadersV2(_response);
        });
    }

    protected processGetRefundHeadersV2(response: AxiosResponse): Promise<RefundHeadersDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<RefundHeadersDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundHeadersDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get Refund Details
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getRefundDetailsV2(refundHeaderId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<RefundDetailsDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/refunddetails?";
        if (refundHeaderId === undefined || refundHeaderId === null)
            throw new Error("The parameter 'refundHeaderId' must be defined and cannot be null.");
        else
            url_ += "RefundHeaderId=" + encodeURIComponent("" + refundHeaderId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRefundDetailsV2(_response);
        });
    }

    protected processGetRefundDetailsV2(response: AxiosResponse): Promise<RefundDetailsDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<RefundDetailsDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundDetailsDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    tempResultRefundV2(file?: FileParameter | undefined, cancelToken?: CancelToken | undefined): Promise<TempResultRefundDto_ResponseServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/tempresultrefund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempResultRefundV2(_response);
        });
    }

    protected processTempResultRefundV2(response: AxiosResponse): Promise<TempResultRefundDto_ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<TempResultRefundDto_ResponseServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TempResultRefundDto_ResponseServiceResponse>(null as any);
    }

    /**
     * GET Temp Result Refund Preview
     * @return OK
     */
    getTempResultRefundPreviewV2(tempId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/recurring/tempresultrefundpreview?";
        if (tempId === undefined || tempId === null)
            throw new Error("The parameter 'tempId' must be defined and cannot be null.");
        else
            url_ += "TempId=" + encodeURIComponent("" + tempId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTempResultRefundPreviewV2(_response);
        });
    }

    protected processGetTempResultRefundPreviewV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST Temp Result Refund To Refund Header Update
     * @return OK
     */
    postTempResultRefundToRefundHeaderUpdateV2(tempId: string, cancelToken?: CancelToken | undefined): Promise<Usp_TempResultRefundToRefundHeader_UpdateResultServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/tempresultrefundtorefundheaderupdate?";
        if (tempId === undefined || tempId === null)
            throw new Error("The parameter 'tempId' must be defined and cannot be null.");
        else
            url_ += "TempId=" + encodeURIComponent("" + tempId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostTempResultRefundToRefundHeaderUpdateV2(_response);
        });
    }

    protected processPostTempResultRefundToRefundHeaderUpdateV2(response: AxiosResponse): Promise<Usp_TempResultRefundToRefundHeader_UpdateResultServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_TempResultRefundToRefundHeader_UpdateResultServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_TempResultRefundToRefundHeader_UpdateResultServiceResponse>(null as any);
    }

    /**
     * Get SMS Detail Monitors
     * @param searchText (optional) 
     * @param sendDateFrom (optional) 
     * @param sendDateTo (optional) 
     * @param debtGroupReferTypeListId (optional) 
     * @param sMSDetailStatusListId (optional) 
     * @param sMSTypeListId (optional) 
     * @param b (optional) 
     * @param payerName (optional) 
     * @param phoneNo (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getSMSDetailMonitorsV2(searchText?: string | undefined, sendDateFrom?: dayjs.Dayjs | undefined, sendDateTo?: dayjs.Dayjs | undefined, debtGroupReferTypeListId?: string | undefined, sMSDetailStatusListId?: string | undefined, sMSTypeListId?: string | undefined, b?: string | undefined, payerName?: string | undefined, phoneNo?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_SMSDetailMonitor_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/smsdetailmonitors?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (sendDateFrom === null)
            throw new Error("The parameter 'sendDateFrom' cannot be null.");
        else if (sendDateFrom !== undefined)
            url_ += "SendDateFrom=" + encodeURIComponent(sendDateFrom ? "" + sendDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (sendDateTo === null)
            throw new Error("The parameter 'sendDateTo' cannot be null.");
        else if (sendDateTo !== undefined)
            url_ += "SendDateTo=" + encodeURIComponent(sendDateTo ? "" + sendDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeListId === null)
            throw new Error("The parameter 'debtGroupReferTypeListId' cannot be null.");
        else if (debtGroupReferTypeListId !== undefined)
            url_ += "DebtGroupReferTypeListId=" + encodeURIComponent("" + debtGroupReferTypeListId) + "&";
        if (sMSDetailStatusListId === null)
            throw new Error("The parameter 'sMSDetailStatusListId' cannot be null.");
        else if (sMSDetailStatusListId !== undefined)
            url_ += "SMSDetailStatusListId=" + encodeURIComponent("" + sMSDetailStatusListId) + "&";
        if (sMSTypeListId === null)
            throw new Error("The parameter 'sMSTypeListId' cannot be null.");
        else if (sMSTypeListId !== undefined)
            url_ += "SMSTypeListId=" + encodeURIComponent("" + sMSTypeListId) + "&";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (phoneNo === null)
            throw new Error("The parameter 'phoneNo' cannot be null.");
        else if (phoneNo !== undefined)
            url_ += "PhoneNo=" + encodeURIComponent("" + phoneNo) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSMSDetailMonitorsV2(_response);
        });
    }

    protected processGetSMSDetailMonitorsV2(response: AxiosResponse): Promise<Usp_SMSDetailMonitor_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_SMSDetailMonitor_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_SMSDetailMonitor_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get SMSDetailSubMonitors
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getSMSDetailSubMonitorsV2(debtHeaderId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_SMSDetailSubMonitor_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/smsdetailsubmonitors?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSMSDetailSubMonitorsV2(_response);
        });
    }

    protected processGetSMSDetailSubMonitorsV2(response: AxiosResponse): Promise<Usp_SMSDetailSubMonitor_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_SMSDetailSubMonitor_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_SMSDetailSubMonitor_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET SMSDetailMonitorByOrderSelect
     * @param searchText (optional) 
     * @param sendDateFrom (optional) 
     * @param sendDateTo (optional) 
     * @param debtGroupReferTypeListId (optional) 
     * @param sMSTypeListId (optional) 
     * @param b (optional) 
     * @param payerName (optional) 
     * @param phoneNo (optional) 
     * @param sourceTypeId (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getSMSDetailMonitorByOrderSelectV2(searchText?: string | undefined, sendDateFrom?: dayjs.Dayjs | undefined, sendDateTo?: dayjs.Dayjs | undefined, debtGroupReferTypeListId?: string | undefined, sMSTypeListId?: string | undefined, b?: string | undefined, payerName?: string | undefined, phoneNo?: string | undefined, sourceTypeId?: number | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_SMSDetailMonitorByOrder_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/smsdetailmonitorbyorderselect?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (sendDateFrom === null)
            throw new Error("The parameter 'sendDateFrom' cannot be null.");
        else if (sendDateFrom !== undefined)
            url_ += "SendDateFrom=" + encodeURIComponent(sendDateFrom ? "" + sendDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (sendDateTo === null)
            throw new Error("The parameter 'sendDateTo' cannot be null.");
        else if (sendDateTo !== undefined)
            url_ += "SendDateTo=" + encodeURIComponent(sendDateTo ? "" + sendDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeListId === null)
            throw new Error("The parameter 'debtGroupReferTypeListId' cannot be null.");
        else if (debtGroupReferTypeListId !== undefined)
            url_ += "DebtGroupReferTypeListId=" + encodeURIComponent("" + debtGroupReferTypeListId) + "&";
        if (sMSTypeListId === null)
            throw new Error("The parameter 'sMSTypeListId' cannot be null.");
        else if (sMSTypeListId !== undefined)
            url_ += "SMSTypeListId=" + encodeURIComponent("" + sMSTypeListId) + "&";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (payerName === null)
            throw new Error("The parameter 'payerName' cannot be null.");
        else if (payerName !== undefined)
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (phoneNo === null)
            throw new Error("The parameter 'phoneNo' cannot be null.");
        else if (phoneNo !== undefined)
            url_ += "PhoneNo=" + encodeURIComponent("" + phoneNo) + "&";
        if (sourceTypeId === null)
            throw new Error("The parameter 'sourceTypeId' cannot be null.");
        else if (sourceTypeId !== undefined)
            url_ += "SourceTypeId=" + encodeURIComponent("" + sourceTypeId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSMSDetailMonitorByOrderSelectV2(_response);
        });
    }

    protected processGetSMSDetailMonitorByOrderSelectV2(response: AxiosResponse): Promise<Usp_SMSDetailMonitorByOrder_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_SMSDetailMonitorByOrder_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_SMSDetailMonitorByOrder_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * POST ReSend SMS
     * @param body (optional) 
     * @return OK
     */
    sendSMSV2(body?: SMSCreateRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<SendSmsV2ResponseServiceResponse> {
        let url_ = this.baseUrl + "/v2/sms/sendsms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendSMSV2(_response);
        });
    }

    protected processSendSMSV2(response: AxiosResponse): Promise<SendSmsV2ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SendSmsV2ResponseServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SendSmsV2ResponseServiceResponse>(null as any);
    }

    /**
     * POST UpSertPayableDate
     * @param summaryHeaderId (optional) 
     * @param payableDate (optional) 
     * @return OK
     */
    upSertPayableDateV2(summaryHeaderId?: string | undefined, payableDate?: dayjs.Dayjs | undefined, cancelToken?: CancelToken | undefined): Promise<StringServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/upsertpayabledate?";
        if (summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' cannot be null.");
        else if (summaryHeaderId !== undefined)
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        if (payableDate === null)
            throw new Error("The parameter 'payableDate' cannot be null.");
        else if (payableDate !== undefined)
            url_ += "PayableDate=" + encodeURIComponent(payableDate ? "" + payableDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpSertPayableDateV2(_response);
        });
    }

    protected processUpSertPayableDateV2(response: AxiosResponse): Promise<StringServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<StringServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringServiceResponse>(null as any);
    }

    /**
     * POST Match
     * @param transferHeaderIdList (optional) 
     * @param statementIdList (optional) 
     * @return OK
     */
    matchV2(transferHeaderIdList?: string | undefined, statementIdList?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_rcc_MatchResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/match?";
        if (transferHeaderIdList === null)
            throw new Error("The parameter 'transferHeaderIdList' cannot be null.");
        else if (transferHeaderIdList !== undefined)
            url_ += "TransferHeaderIdList=" + encodeURIComponent("" + transferHeaderIdList) + "&";
        if (statementIdList === null)
            throw new Error("The parameter 'statementIdList' cannot be null.");
        else if (statementIdList !== undefined)
            url_ += "StatementIdList=" + encodeURIComponent("" + statementIdList) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMatchV2(_response);
        });
    }

    protected processMatchV2(response: AxiosResponse): Promise<Usp_rcc_MatchResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_rcc_MatchResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_rcc_MatchResultListServiceResponse>(null as any);
    }

    /**
     * GET BankAccountNoForMatch
     * @param bankId (optional) 
     * @return OK
     */
    getBankAccountNoForMatchV2(bankId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_rcc_BankAccountNoForMatch_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/bankaccountnoformatch?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBankAccountNoForMatchV2(_response);
        });
    }

    protected processGetBankAccountNoForMatchV2(response: AxiosResponse): Promise<Usp_rcc_BankAccountNoForMatch_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_rcc_BankAccountNoForMatch_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_rcc_BankAccountNoForMatch_SelectResultListServiceResponse>(null as any);
    }

    /**
     * GET BankForMatch
     * @param bankId (optional) 
     * @return OK
     */
    getBankForMatchV2(bankId?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_rcc_BankForMatch_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/bankformatch?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBankForMatchV2(_response);
        });
    }

    protected processGetBankForMatchV2(response: AxiosResponse): Promise<Usp_rcc_BankForMatch_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_rcc_BankForMatch_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_rcc_BankForMatch_SelectResultListServiceResponse>(null as any);
    }

    /**
     * Get TranferHeaderWaitMatchs
     * @param transferDate (optional) 
     * @param bankId (optional) 
     * @param bankAccountNo (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getTranferHeaderWaitMatchsV2(transferDate?: dayjs.Dayjs | undefined, bankId?: number | undefined, bankAccountNo?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_rcc_TransferHeader_WaitMatch_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/tranferheaderwaitmatchs?";
        if (transferDate === null)
            throw new Error("The parameter 'transferDate' cannot be null.");
        else if (transferDate !== undefined)
            url_ += "TransferDate=" + encodeURIComponent(transferDate ? "" + transferDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' cannot be null.");
        else if (bankAccountNo !== undefined)
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTranferHeaderWaitMatchsV2(_response);
        });
    }

    protected processGetTranferHeaderWaitMatchsV2(response: AxiosResponse): Promise<Usp_rcc_TransferHeader_WaitMatch_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_rcc_TransferHeader_WaitMatch_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_rcc_TransferHeader_WaitMatch_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * Get StatementWaitMatchs
     * @param transferDate (optional) 
     * @param bankId (optional) 
     * @param bankAccountNo (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getStatementWaitMatchsV2(transferDate?: dayjs.Dayjs | undefined, bankId?: number | undefined, bankAccountNo?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_rcc_Statement_WaitMatch_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/statementwaitmatchs?";
        if (transferDate === null)
            throw new Error("The parameter 'transferDate' cannot be null.");
        else if (transferDate !== undefined)
            url_ += "TransferDate=" + encodeURIComponent(transferDate ? "" + transferDate.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' cannot be null.");
        else if (bankAccountNo !== undefined)
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStatementWaitMatchsV2(_response);
        });
    }

    protected processGetStatementWaitMatchsV2(response: AxiosResponse): Promise<Usp_rcc_Statement_WaitMatch_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_rcc_Statement_WaitMatch_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_rcc_Statement_WaitMatch_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET DebitingHistories
     * @param bankAccountNo (optional) 
     * @param bankAccountName (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebitingHistoriesV2(period: dayjs.Dayjs, bankAccountNo?: string | undefined, bankAccountName?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<DebitingHistoriesDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debitinghistories?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' cannot be null.");
        else if (bankAccountNo !== undefined)
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (bankAccountName === null)
            throw new Error("The parameter 'bankAccountName' cannot be null.");
        else if (bankAccountName !== undefined)
            url_ += "BankAccountName=" + encodeURIComponent("" + bankAccountName) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebitingHistoriesV2(_response);
        });
    }

    protected processGetDebitingHistoriesV2(response: AxiosResponse): Promise<DebitingHistoriesDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebitingHistoriesDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebitingHistoriesDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET DebitingHistoryDetails
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebitingHistoryDetailsV2(summaryDetailId: string, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<DebitingHistoryDetailsDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debitinghistorydetails?";
        if (summaryDetailId === undefined || summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' must be defined and cannot be null.");
        else
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebitingHistoryDetailsV2(_response);
        });
    }

    protected processGetDebitingHistoryDetailsV2(response: AxiosResponse): Promise<DebitingHistoryDetailsDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebitingHistoryDetailsDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebitingHistoryDetailsDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET DebtHeaderByRefAndBills
     * @param b (optional) 
     * @param ref1 (optional) 
     * @param ref2 (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtHeaderByRefAndBillsV2(b?: string | undefined, ref1?: string | undefined, ref2?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<DebtHeaderByRefAndBillsDto_ResponseListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debtheaderbyrefandbills?";
        if (b === null)
            throw new Error("The parameter 'b' cannot be null.");
        else if (b !== undefined)
            url_ += "B=" + encodeURIComponent("" + b) + "&";
        if (ref1 === null)
            throw new Error("The parameter 'ref1' cannot be null.");
        else if (ref1 !== undefined)
            url_ += "Ref1=" + encodeURIComponent("" + ref1) + "&";
        if (ref2 === null)
            throw new Error("The parameter 'ref2' cannot be null.");
        else if (ref2 !== undefined)
            url_ += "Ref2=" + encodeURIComponent("" + ref2) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtHeaderByRefAndBillsV2(_response);
        });
    }

    protected processGetDebtHeaderByRefAndBillsV2(response: AxiosResponse): Promise<DebtHeaderByRefAndBillsDto_ResponseListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebtHeaderByRefAndBillsDto_ResponseListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebtHeaderByRefAndBillsDto_ResponseListServiceResponseWithPagination>(null as any);
    }

    /**
     * DebitingHistoriesHeader
     * @param bankAccountNo (optional) 
     * @param bankAccountName (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebitingHistoriesHeaderV2(period: dayjs.Dayjs, bankAccountNo?: string | undefined, bankAccountName?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<DebitingHistoriesHeaderDto_ResponseServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/debitinghistoriesheader?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' cannot be null.");
        else if (bankAccountNo !== undefined)
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (bankAccountName === null)
            throw new Error("The parameter 'bankAccountName' cannot be null.");
        else if (bankAccountName !== undefined)
            url_ += "BankAccountName=" + encodeURIComponent("" + bankAccountName) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebitingHistoriesHeaderV2(_response);
        });
    }

    protected processGetDebitingHistoriesHeaderV2(response: AxiosResponse): Promise<DebitingHistoriesHeaderDto_ResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<DebitingHistoriesHeaderDto_ResponseServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DebitingHistoriesHeaderDto_ResponseServiceResponse>(null as any);
    }

    /**
     * GET SMSDetailLog
     * @return OK
     */
    getSMSDetailLogV2(smsDetailId: string, cancelToken?: CancelToken | undefined): Promise<SMSDetailLogDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/smsdetaillog/{smsDetailId}";
        if (smsDetailId === undefined || smsDetailId === null)
            throw new Error("The parameter 'smsDetailId' must be defined.");
        url_ = url_.replace("{smsDetailId}", encodeURIComponent("" + smsDetailId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSMSDetailLogV2(_response);
        });
    }

    protected processGetSMSDetailLogV2(response: AxiosResponse): Promise<SMSDetailLogDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SMSDetailLogDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SMSDetailLogDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * SummaryFileNoWaitReceiveFile
     * @param debtGroupReferTypeId (optional) 
     * @return OK
     */
    getSummaryFileNoWaitReceiveFileV2(bankId: number, debtGroupReferTypeId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<SummaryFileNoWaitReceiveFileDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/summaryfilenowaitreceive?";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummaryFileNoWaitReceiveFileV2(_response);
        });
    }

    protected processGetSummaryFileNoWaitReceiveFileV2(response: AxiosResponse): Promise<SummaryFileNoWaitReceiveFileDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SummaryFileNoWaitReceiveFileDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SummaryFileNoWaitReceiveFileDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * GET Summary Validate
     * @return OK
     */
    getSummaryValidateV2(debtGroupId: string, bankId: number, cancelToken?: CancelToken | undefined): Promise<Usp_Summary_ValidateResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/summaryvalidate?";
        if (debtGroupId === undefined || debtGroupId === null)
            throw new Error("The parameter 'debtGroupId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupId=" + encodeURIComponent("" + debtGroupId) + "&";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummaryValidateV2(_response);
        });
    }

    protected processGetSummaryValidateV2(response: AxiosResponse): Promise<Usp_Summary_ValidateResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_Summary_ValidateResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_Summary_ValidateResultListServiceResponse>(null as any);
    }

    /**
     * GET Debt Header Account Wrong Select
     * @return OK
     */
    getDebtHeaderAccountWrongSelectV2(debtGroupId: string, bankId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/recurring/debtheaderaccountwrongselect?";
        if (debtGroupId === undefined || debtGroupId === null)
            throw new Error("The parameter 'debtGroupId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupId=" + encodeURIComponent("" + debtGroupId) + "&";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtHeaderAccountWrongSelectV2(_response);
        });
    }

    protected processGetDebtHeaderAccountWrongSelectV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST Debt Header Account Wrong Cancel Update
     * @return OK
     */
    getDebtHeaderAccountWrongCancelUpdateV2(debtGroupId: string, bankId: number, cancelToken?: CancelToken | undefined): Promise<Usp_DebtHeaderAccountWrongCancel_UpdateResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/debtheaderaccountwrongcancelupdate?";
        if (debtGroupId === undefined || debtGroupId === null)
            throw new Error("The parameter 'debtGroupId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupId=" + encodeURIComponent("" + debtGroupId) + "&";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtHeaderAccountWrongCancelUpdateV2(_response);
        });
    }

    protected processGetDebtHeaderAccountWrongCancelUpdateV2(response: AxiosResponse): Promise<Usp_DebtHeaderAccountWrongCancel_UpdateResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtHeaderAccountWrongCancel_UpdateResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtHeaderAccountWrongCancel_UpdateResultListServiceResponse>(null as any);
    }

    /**
     * POST Summary Detail Cancel Update
     * @return OK
     */
    getSummaryDetailCancelUpdateV2(summaryDetailId: string, description: string, cancelToken?: CancelToken | undefined): Promise<Usp_SummaryDetailCancel_UpdateResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/summarydetailcancelupdate?";
        if (summaryDetailId === undefined || summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' must be defined and cannot be null.");
        else
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (description === undefined || description === null)
            throw new Error("The parameter 'description' must be defined and cannot be null.");
        else
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummaryDetailCancelUpdateV2(_response);
        });
    }

    protected processGetSummaryDetailCancelUpdateV2(response: AxiosResponse): Promise<Usp_SummaryDetailCancel_UpdateResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_SummaryDetailCancel_UpdateResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_SummaryDetailCancel_UpdateResultListServiceResponse>(null as any);
    }

    /**
     * Get Summary Detail
     * @param bankAccountNo (optional) 
     * @param summaryFileNoId (optional) 
     * @param summaryDetailId (optional) 
     * @param summaryHeaderId (optional) 
     * @return OK
     */
    getSummaryDetailV2(bankAccountNo?: string | undefined, summaryFileNoId?: string | undefined, summaryDetailId?: string | undefined, summaryHeaderId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<SummaryDetailDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/summarydetail?";
        if (bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' cannot be null.");
        else if (bankAccountNo !== undefined)
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (summaryFileNoId === null)
            throw new Error("The parameter 'summaryFileNoId' cannot be null.");
        else if (summaryFileNoId !== undefined)
            url_ += "SummaryFileNoId=" + encodeURIComponent("" + summaryFileNoId) + "&";
        if (summaryDetailId === null)
            throw new Error("The parameter 'summaryDetailId' cannot be null.");
        else if (summaryDetailId !== undefined)
            url_ += "SummaryDetailId=" + encodeURIComponent("" + summaryDetailId) + "&";
        if (summaryHeaderId === null)
            throw new Error("The parameter 'summaryHeaderId' cannot be null.");
        else if (summaryHeaderId !== undefined)
            url_ += "SummaryHeaderId=" + encodeURIComponent("" + summaryHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummaryDetailV2(_response);
        });
    }

    protected processGetSummaryDetailV2(response: AxiosResponse): Promise<SummaryDetailDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<SummaryDetailDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SummaryDetailDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * Get Debt Detail
     * @param debtDetailId (optional) 
     * @return OK
     */
    getGetDebtDetailV2(debtHeaderId: string, debtDetailId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetDebtDetailDto_ResponseListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/debtdetail?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (debtDetailId === null)
            throw new Error("The parameter 'debtDetailId' cannot be null.");
        else if (debtDetailId !== undefined)
            url_ += "DebtDetailId=" + encodeURIComponent("" + debtDetailId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGetDebtDetailV2(_response);
        });
    }

    protected processGetGetDebtDetailV2(response: AxiosResponse): Promise<GetDebtDetailDto_ResponseListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDebtDetailDto_ResponseListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDebtDetailDto_ResponseListServiceResponse>(null as any);
    }

    /**
     * GET DebtHeaderforSplitBills
     * @param billNo (optional) 
     * @param payername (optional) 
     * @param payerIdentityCard (optional) 
     * @param searchDetail (optional) 
     * @param viewPoint (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtHeaderforSplitBillsV2(debtGroupReferTypeId: number, billNo?: string | undefined, payername?: string | undefined, payerIdentityCard?: string | undefined, searchDetail?: string | undefined, viewPoint?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DebtHeaderforSplitBills_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debtheaderforsplitbills?";
        if (debtGroupReferTypeId === undefined || debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' must be defined and cannot be null.");
        else
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (billNo === null)
            throw new Error("The parameter 'billNo' cannot be null.");
        else if (billNo !== undefined)
            url_ += "BillNo=" + encodeURIComponent("" + billNo) + "&";
        if (payername === null)
            throw new Error("The parameter 'payername' cannot be null.");
        else if (payername !== undefined)
            url_ += "Payername=" + encodeURIComponent("" + payername) + "&";
        if (payerIdentityCard === null)
            throw new Error("The parameter 'payerIdentityCard' cannot be null.");
        else if (payerIdentityCard !== undefined)
            url_ += "PayerIdentityCard=" + encodeURIComponent("" + payerIdentityCard) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (viewPoint === null)
            throw new Error("The parameter 'viewPoint' cannot be null.");
        else if (viewPoint !== undefined)
            url_ += "ViewPoint=" + encodeURIComponent("" + viewPoint) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtHeaderforSplitBillsV2(_response);
        });
    }

    protected processGetDebtHeaderforSplitBillsV2(response: AxiosResponse): Promise<Usp_DebtHeaderforSplitBills_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtHeaderforSplitBills_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtHeaderforSplitBills_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET DebtHeaderforSplitBill
     * @return OK
     */
    getDebtHeaderforSplitBillV2(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<Usp_DebtHeaderforSplitBillByDebtHeaderId_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/debtheaderforsplitbill?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "debtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtHeaderforSplitBillV2(_response);
        });
    }

    protected processGetDebtHeaderforSplitBillV2(response: AxiosResponse): Promise<Usp_DebtHeaderforSplitBillByDebtHeaderId_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtHeaderforSplitBillByDebtHeaderId_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtHeaderforSplitBillByDebtHeaderId_SelectResultListServiceResponse>(null as any);
    }

    /**
     * GET SummaryDetailCode
     * @return OK
     */
    getSummaryDetailCodeV2(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<StringServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/summarydetailcode?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "debtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummaryDetailCodeV2(_response);
        });
    }

    protected processGetSummaryDetailCodeV2(response: AxiosResponse): Promise<StringServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<StringServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringServiceResponse>(null as any);
    }

    /**
     * Get BankForTransferManual
     * @param bankId (optional) 
     * @return OK
     */
    getBankForTransferManualV2(bankId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_BankForTransferManual_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/bankfortransfermanual?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBankForTransferManualV2(_response);
        });
    }

    protected processGetBankForTransferManualV2(response: AxiosResponse): Promise<Usp_BankForTransferManual_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_BankForTransferManual_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_BankForTransferManual_SelectResultListServiceResponse>(null as any);
    }

    /**
     * Get BankAccountNoForMatch
     * @param bankId (optional) 
     * @return OK
     */
    getBankAccountNoForTransferManualV2(bankId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_BankAccountNoForTransferManual_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/bankaccountnofortransfermanual?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBankAccountNoForTransferManualV2(_response);
        });
    }

    protected processGetBankAccountNoForTransferManualV2(response: AxiosResponse): Promise<Usp_BankAccountNoForTransferManual_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_BankAccountNoForTransferManual_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_BankAccountNoForTransferManual_SelectResultListServiceResponse>(null as any);
    }

    /**
     * Get BankAccountNoForMatch
     * @param receiveTypeId (optional) 
     * @return OK
     */
    getReceiveTypeForTransferManualV2(receiveTypeId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_ReceiveTypeForTransferManual_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/receivetypefortransfermanual?";
        if (receiveTypeId === null)
            throw new Error("The parameter 'receiveTypeId' cannot be null.");
        else if (receiveTypeId !== undefined)
            url_ += "ReceiveTypeId=" + encodeURIComponent("" + receiveTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceiveTypeForTransferManualV2(_response);
        });
    }

    protected processGetReceiveTypeForTransferManualV2(response: AxiosResponse): Promise<Usp_ReceiveTypeForTransferManual_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_ReceiveTypeForTransferManual_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_ReceiveTypeForTransferManual_SelectResultListServiceResponse>(null as any);
    }

    /**
     * Add CreateTransferManual
     * @return OK
     */
    createTransferManualV2(paymentChanelId: number, bankId: number, bankAccountNo: string, transferDateTime: dayjs.Dayjs, transferAmount: number, transferRemark: string, receiveTypeId: number, custName: string, payerName: string, createdByUserId: number, cancelToken?: CancelToken | undefined): Promise<Usp_rcc_CreateTransferManual_InsertResultServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/createtransfermanual?";
        if (paymentChanelId === undefined || paymentChanelId === null)
            throw new Error("The parameter 'paymentChanelId' must be defined and cannot be null.");
        else
            url_ += "PaymentChanelId=" + encodeURIComponent("" + paymentChanelId) + "&";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined and cannot be null.");
        else
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        if (bankAccountNo === undefined || bankAccountNo === null)
            throw new Error("The parameter 'bankAccountNo' must be defined and cannot be null.");
        else
            url_ += "BankAccountNo=" + encodeURIComponent("" + bankAccountNo) + "&";
        if (transferDateTime === undefined || transferDateTime === null)
            throw new Error("The parameter 'transferDateTime' must be defined and cannot be null.");
        else
            url_ += "TransferDateTime=" + encodeURIComponent(transferDateTime ? "" + transferDateTime.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (transferAmount === undefined || transferAmount === null)
            throw new Error("The parameter 'transferAmount' must be defined and cannot be null.");
        else
            url_ += "TransferAmount=" + encodeURIComponent("" + transferAmount) + "&";
        if (transferRemark === undefined || transferRemark === null)
            throw new Error("The parameter 'transferRemark' must be defined and cannot be null.");
        else
            url_ += "TransferRemark=" + encodeURIComponent("" + transferRemark) + "&";
        if (receiveTypeId === undefined || receiveTypeId === null)
            throw new Error("The parameter 'receiveTypeId' must be defined and cannot be null.");
        else
            url_ += "ReceiveTypeId=" + encodeURIComponent("" + receiveTypeId) + "&";
        if (custName === undefined || custName === null)
            throw new Error("The parameter 'custName' must be defined and cannot be null.");
        else
            url_ += "CustName=" + encodeURIComponent("" + custName) + "&";
        if (payerName === undefined || payerName === null)
            throw new Error("The parameter 'payerName' must be defined and cannot be null.");
        else
            url_ += "PayerName=" + encodeURIComponent("" + payerName) + "&";
        if (createdByUserId === undefined || createdByUserId === null)
            throw new Error("The parameter 'createdByUserId' must be defined and cannot be null.");
        else
            url_ += "CreatedByUserId=" + encodeURIComponent("" + createdByUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateTransferManualV2(_response);
        });
    }

    protected processCreateTransferManualV2(response: AxiosResponse): Promise<Usp_rcc_CreateTransferManual_InsertResultServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_rcc_CreateTransferManual_InsertResultServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_rcc_CreateTransferManual_InsertResultServiceResponse>(null as any);
    }

    /**
     * Get ReceiveTypeForGenerateFeeBill
     * @param receiveTypeId (optional) 
     * @return OK
     */
    getReceiveTypeForGenerateFeeBillV2(receiveTypeId?: string | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_ReceiveTypeForGenerateFeeBill_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/receivetypeforgeneratefeebill?";
        if (receiveTypeId === null)
            throw new Error("The parameter 'receiveTypeId' cannot be null.");
        else if (receiveTypeId !== undefined)
            url_ += "ReceiveTypeId=" + encodeURIComponent("" + receiveTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceiveTypeForGenerateFeeBillV2(_response);
        });
    }

    protected processGetReceiveTypeForGenerateFeeBillV2(response: AxiosResponse): Promise<Usp_ReceiveTypeForGenerateFeeBill_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_ReceiveTypeForGenerateFeeBill_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_ReceiveTypeForGenerateFeeBill_SelectResultListServiceResponse>(null as any);
    }

    /**
     * GET DebtHeaderforSMSSelect
     * @param debtGroupReferTypeId (optional) 
     * @param searchIndex (optional) 
     * @param searchText (optional) 
     * @param orderingField (optional) 
     * @param ascendingOrder (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return OK
     */
    getDebtHeaderforSMSSelect(createdDateFrom: dayjs.Dayjs, createdDateTo: dayjs.Dayjs, debtGroupReferTypeId?: number | undefined, searchIndex?: number | undefined, searchText?: string | undefined, orderingField?: string | undefined, ascendingOrder?: boolean | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<Usp_DebtHeaderforSMS_SelectResultListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurring/debtheaderforsmsselect?";
        if (createdDateFrom === undefined || createdDateFrom === null)
            throw new Error("The parameter 'createdDateFrom' must be defined and cannot be null.");
        else
            url_ += "CreatedDateFrom=" + encodeURIComponent(createdDateFrom ? "" + createdDateFrom.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (createdDateTo === undefined || createdDateTo === null)
            throw new Error("The parameter 'createdDateTo' must be defined and cannot be null.");
        else
            url_ += "CreatedDateTo=" + encodeURIComponent(createdDateTo ? "" + createdDateTo.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        if (debtGroupReferTypeId === null)
            throw new Error("The parameter 'debtGroupReferTypeId' cannot be null.");
        else if (debtGroupReferTypeId !== undefined)
            url_ += "DebtGroupReferTypeId=" + encodeURIComponent("" + debtGroupReferTypeId) + "&";
        if (searchIndex === null)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined)
            url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (orderingField === null)
            throw new Error("The parameter 'orderingField' cannot be null.");
        else if (orderingField !== undefined)
            url_ += "OrderingField=" + encodeURIComponent("" + orderingField) + "&";
        if (ascendingOrder === null)
            throw new Error("The parameter 'ascendingOrder' cannot be null.");
        else if (ascendingOrder !== undefined)
            url_ += "AscendingOrder=" + encodeURIComponent("" + ascendingOrder) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtHeaderforSMSSelect(_response);
        });
    }

    protected processGetDebtHeaderforSMSSelect(response: AxiosResponse): Promise<Usp_DebtHeaderforSMS_SelectResultListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtHeaderforSMS_SelectResultListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtHeaderforSMS_SelectResultListServiceResponseWithPagination>(null as any);
    }

    /**
     * GET DebtHeaderforSMSDetailSelect
     * @return OK
     */
    getDebtHeaderforSMSDetailSelect(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<Usp_DebtHeaderforSMSDetail_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/debtheaderforsmsdetail?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "debtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtHeaderforSMSDetailSelect(_response);
        });
    }

    protected processGetDebtHeaderforSMSDetailSelect(response: AxiosResponse): Promise<Usp_DebtHeaderforSMSDetail_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtHeaderforSMSDetail_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtHeaderforSMSDetail_SelectResultListServiceResponse>(null as any);
    }

    /**
     * GET DebtHeaderforSendSMSSelect
     * @return OK
     */
    getDebtHeaderforSendSMSSelect(debtHeaderId: string, cancelToken?: CancelToken | undefined): Promise<Usp_DebtHeaderforSendSMS_SelectResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurring/debtheaderforsendsms?";
        if (debtHeaderId === undefined || debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' must be defined and cannot be null.");
        else
            url_ += "debtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDebtHeaderforSendSMSSelect(_response);
        });
    }

    protected processGetDebtHeaderforSendSMSSelect(response: AxiosResponse): Promise<Usp_DebtHeaderforSendSMS_SelectResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_DebtHeaderforSendSMS_SelectResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_DebtHeaderforSendSMS_SelectResultListServiceResponse>(null as any);
    }
}

export class QuartzClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * POST BatchSendSmsJob
     * @return OK
     */
    batchsendsmsjob( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Quartz/batchsendsmsjob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchsendsmsjob(_response);
        });
    }

    protected processBatchsendsmsjob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST DebtGroupExpireOfBankUpdateJob
     * @return OK
     */
    debtgroupexpireofbankupdatejob( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Quartz/debtgroupexpireofbankupdatejob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtgroupexpireofbankupdatejob(_response);
        });
    }

    protected processDebtgroupexpireofbankupdatejob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST DebtsGroupExpireJob
     * @return OK
     */
    debtsgroupexpirejob( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Quartz/debtsgroupexpirejob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebtsgroupexpirejob(_response);
        });
    }

    protected processDebtsgroupexpirejob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST ScheduleSentSMSListBillingJob
     * @return OK
     */
    schedulesentsmslistbillingjob( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Quartz/schedulesentsmslistbillingjob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSchedulesentsmslistbillingjob(_response);
        });
    }

    protected processSchedulesentsmslistbillingjob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST TempDebtToDebtJob
     * @return OK
     */
    tempdebttodebtjob( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Quartz/tempdebttodebtjob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempdebttodebtjob(_response);
        });
    }

    protected processTempdebttodebtjob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST TempRefundToRefundJob
     * @return OK
     */
    temprefundtorefundjob( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Quartz/temprefundtorefundjob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTemprefundtorefundjob(_response);
        });
    }

    protected processTemprefundtorefundjob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST TempSMSResultJob
     * @return OK
     */
    tempsmsresultjob( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Quartz/tempsmsresultjob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempsmsresultjob(_response);
        });
    }

    protected processTempsmsresultjob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * POST TempSummaryToSummaryJob
     * @return OK
     */
    tempsummarytosummaryjob( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Quartz/tempsummarytosummaryjob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempsummarytosummaryjob(_response);
        });
    }

    protected processTempsummarytosummaryjob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RecurringSMSClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Upload file RecurringSMS Motor
     * @param file (optional) 
     * @param period (optional) 
     * @return OK
     */
    upload(file?: FileParameter | undefined, period?: dayjs.Dayjs | undefined, cancelToken?: CancelToken | undefined): Promise<ExcelFileUploadResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/recurringsms/motor/failedtodeduct/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (period === null || period === undefined)
            throw new Error("The parameter 'period' cannot be null.");
        else
            content_.append("Period", period.toJSON());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: AxiosResponse): Promise<ExcelFileUploadResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<ExcelFileUploadResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExcelFileUploadResponseDtoServiceResponse>(null as any);
    }

    /**
     * รายละเอียดของไฟล์ ที่ลง TempRecurringSMS
     * @return OK
     */
    filedetail(tempcode: string, cancelToken?: CancelToken | undefined): Promise<Usp_TempRecurringSMS_CountResultListServiceResponse> {
        let url_ = this.baseUrl + "/temprecurringsms/{tempcode}/filedetail";
        if (tempcode === undefined || tempcode === null)
            throw new Error("The parameter 'tempcode' must be defined.");
        url_ = url_.replace("{tempcode}", encodeURIComponent("" + tempcode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFiledetail(_response);
        });
    }

    protected processFiledetail(response: AxiosResponse): Promise<Usp_TempRecurringSMS_CountResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_TempRecurringSMS_CountResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_TempRecurringSMS_CountResultListServiceResponse>(null as any);
    }

    /**
     * หลังจากอัพโหลดไฟล์ ถ้าติด validate จะออก report error ให้ดาวน์โหลด
     * @return OK
     */
    download3(tempcode: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/errortemprecurringsms/download?";
        if (tempcode === undefined || tempcode === null)
            throw new Error("The parameter 'tempcode' must be defined and cannot be null.");
        else
            url_ += "tempcode=" + encodeURIComponent("" + tempcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload3(_response);
        });
    }

    protected processDownload3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create RecurringSMS and set send SMS at communicate
     * @return OK
     */
    recurringsmsPOST(tempcode: string, period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<CreateRecurringSMSResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/temprecurringsms/{tempcode}/recurringsms?";
        if (tempcode === undefined || tempcode === null)
            throw new Error("The parameter 'tempcode' must be defined.");
        url_ = url_.replace("{tempcode}", encodeURIComponent("" + tempcode));
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecurringsmsPOST(_response);
        });
    }

    protected processRecurringsmsPOST(response: AxiosResponse): Promise<CreateRecurringSMSResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<CreateRecurringSMSResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateRecurringSMSResponseDtoServiceResponse>(null as any);
    }

    /**
     * UI ส่ง SMS แจ้งเตือนให้ลูกค้านำเงินเข้าบัญชี
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    recurringsmsGET(year: number, page?: number | undefined, recordsPerPage?: number | undefined, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetRecurringSMSResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/recurringsms/{year}?";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined.");
        url_ = url_.replace("{year}", encodeURIComponent("" + year));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecurringsmsGET(_response);
        });
    }

    protected processRecurringsmsGET(response: AxiosResponse): Promise<GetRecurringSMSResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetRecurringSMSResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRecurringSMSResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * Download report RecurringSMS result
     * @return OK
     */
    download4(recurringSMSHeaderId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/report/recurringsms/recurringsmsresult/download?";
        if (recurringSMSHeaderId === undefined || recurringSMSHeaderId === null)
            throw new Error("The parameter 'recurringSMSHeaderId' must be defined and cannot be null.");
        else
            url_ += "RecurringSMSHeaderId=" + encodeURIComponent("" + recurringSMSHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload4(_response);
        });
    }

    protected processDownload4(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * ใช้ปิดปุ่มอัพโหลดไฟล์
     * @return OK
     */
    recurringcheck(period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<RecurringCheckResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/recurringsms/recurringcheck?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecurringcheck(_response);
        });
    }

    protected processRecurringcheck(response: AxiosResponse): Promise<RecurringCheckResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<RecurringCheckResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecurringCheckResponseDtoServiceResponse>(null as any);
    }

    /**
     * TempRecurringSMSFromDebtUnPaidValidate
     * @return OK
     */
    validate(period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResultServiceResponse> {
        let url_ = this.baseUrl + "/temprecurringsms/debtunpaid/validate?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: AxiosResponse): Promise<Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResultServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResultServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResultServiceResponse>(null as any);
    }

    /**
     * @return OK
     */
    generateSMS(period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<ExcelFileUploadResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/recurringsms/generatesms?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenerateSMS(_response);
        });
    }

    protected processGenerateSMS(response: AxiosResponse): Promise<ExcelFileUploadResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<ExcelFileUploadResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExcelFileUploadResponseDtoServiceResponse>(null as any);
    }

    /**
     * @return OK
     */
    tempRecurringSMSDetail(tmpCode: string, cancelToken?: CancelToken | undefined): Promise<TempRecurringSMSDetailResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/recurringsms/temprecurringsmsdetail?";
        if (tmpCode === undefined || tmpCode === null)
            throw new Error("The parameter 'tmpCode' must be defined and cannot be null.");
        else
            url_ += "tmpCode=" + encodeURIComponent("" + tmpCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempRecurringSMSDetail(_response);
        });
    }

    protected processTempRecurringSMSDetail(response: AxiosResponse): Promise<TempRecurringSMSDetailResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<TempRecurringSMSDetailResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TempRecurringSMSDetailResponseDtoServiceResponse>(null as any);
    }
}

export class RecurringSMSV2Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Upload file RecurringSMS Motor
     * @param file (optional) 
     * @param period (optional) 
     * @return OK
     */
    accountFailedToDeductMotorUploadV2(file?: FileParameter | undefined, period?: dayjs.Dayjs | undefined, cancelToken?: CancelToken | undefined): Promise<ExcelFileUploadResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurringsms/motor/failedtodeduct/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (period === null || period === undefined)
            throw new Error("The parameter 'period' cannot be null.");
        else
            content_.append("Period", period.toJSON());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountFailedToDeductMotorUploadV2(_response);
        });
    }

    protected processAccountFailedToDeductMotorUploadV2(response: AxiosResponse): Promise<ExcelFileUploadResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<ExcelFileUploadResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExcelFileUploadResponseDtoServiceResponse>(null as any);
    }

    /**
     * รายละเอียดของไฟล์ ที่ลง TempRecurringSMS
     * @return OK
     */
    fileDetailV2(tempcode: string, cancelToken?: CancelToken | undefined): Promise<Usp_TempRecurringSMS_CountResultListServiceResponse> {
        let url_ = this.baseUrl + "/v2/temprecurringsms/{tempcode}/filedetail";
        if (tempcode === undefined || tempcode === null)
            throw new Error("The parameter 'tempcode' must be defined.");
        url_ = url_.replace("{tempcode}", encodeURIComponent("" + tempcode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFileDetailV2(_response);
        });
    }

    protected processFileDetailV2(response: AxiosResponse): Promise<Usp_TempRecurringSMS_CountResultListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_TempRecurringSMS_CountResultListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_TempRecurringSMS_CountResultListServiceResponse>(null as any);
    }

    /**
     * หลังจากอัพโหลดไฟล์ ถ้าติด validate จะออก report error ให้ดาวน์โหลด
     * @return OK
     */
    downloadReportErrorTempRecurringSMSV2(tempcode: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/errortemprecurringsms/download?";
        if (tempcode === undefined || tempcode === null)
            throw new Error("The parameter 'tempcode' must be defined and cannot be null.");
        else
            url_ += "tempcode=" + encodeURIComponent("" + tempcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadReportErrorTempRecurringSMSV2(_response);
        });
    }

    protected processDownloadReportErrorTempRecurringSMSV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create RecurringSMS and set send SMS at communicate
     * @return OK
     */
    createRecurringSMSAndSetSendSMSV2(tempcode: string, period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<CreateRecurringSMSResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/temprecurringsms/{tempcode}/recurringsms?";
        if (tempcode === undefined || tempcode === null)
            throw new Error("The parameter 'tempcode' must be defined.");
        url_ = url_.replace("{tempcode}", encodeURIComponent("" + tempcode));
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRecurringSMSAndSetSendSMSV2(_response);
        });
    }

    protected processCreateRecurringSMSAndSetSendSMSV2(response: AxiosResponse): Promise<CreateRecurringSMSResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<CreateRecurringSMSResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateRecurringSMSResponseDtoServiceResponse>(null as any);
    }

    /**
     * UI ส่ง SMS แจ้งเตือนให้ลูกค้านำเงินเข้าบัญชี
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    getRecurringSMSsV2(year: number, page?: number | undefined, recordsPerPage?: number | undefined, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetRecurringSMSResponseDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/v2/recurringsms/{year}?";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined.");
        url_ = url_.replace("{year}", encodeURIComponent("" + year));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecurringSMSsV2(_response);
        });
    }

    protected processGetRecurringSMSsV2(response: AxiosResponse): Promise<GetRecurringSMSResponseDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetRecurringSMSResponseDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRecurringSMSResponseDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * Download report RecurringSMS result
     * @return OK
     */
    reportRecurringSMSResultV2(recurringSMSHeaderId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/report/recurringsms/recurringsmsresult/download?";
        if (recurringSMSHeaderId === undefined || recurringSMSHeaderId === null)
            throw new Error("The parameter 'recurringSMSHeaderId' must be defined and cannot be null.");
        else
            url_ += "RecurringSMSHeaderId=" + encodeURIComponent("" + recurringSMSHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportRecurringSMSResultV2(_response);
        });
    }

    protected processReportRecurringSMSResultV2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * ใช้ปิดปุ่มอัพโหลดไฟล์
     * @return OK
     */
    recurringCheckV2(period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<RecurringCheckResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurringsms/recurringcheck?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecurringCheckV2(_response);
        });
    }

    protected processRecurringCheckV2(response: AxiosResponse): Promise<RecurringCheckResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<RecurringCheckResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecurringCheckResponseDtoServiceResponse>(null as any);
    }

    /**
     * TempRecurringSMSFromDebtUnPaidValidate
     * @return OK
     */
    tempRecurringSMSFromDebtUnPaidValidateV2(period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResultServiceResponse> {
        let url_ = this.baseUrl + "/v2/temprecurringsms/debtunpaid/validate?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempRecurringSMSFromDebtUnPaidValidateV2(_response);
        });
    }

    protected processTempRecurringSMSFromDebtUnPaidValidateV2(response: AxiosResponse): Promise<Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResultServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResultServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResultServiceResponse>(null as any);
    }

    /**
     * @return OK
     */
    generateSMSV2(period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<ExcelFileUploadResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurringsms/generatesms?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenerateSMSV2(_response);
        });
    }

    protected processGenerateSMSV2(response: AxiosResponse): Promise<ExcelFileUploadResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<ExcelFileUploadResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExcelFileUploadResponseDtoServiceResponse>(null as any);
    }

    /**
     * @return OK
     */
    tempRecurringSMSDetailV2(tmpCode: string, cancelToken?: CancelToken | undefined): Promise<TempRecurringSMSDetailResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/v2/recurringsms/temprecurringsmsdetail?";
        if (tmpCode === undefined || tmpCode === null)
            throw new Error("The parameter 'tmpCode' must be defined and cannot be null.");
        else
            url_ += "tmpCode=" + encodeURIComponent("" + tmpCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTempRecurringSMSDetailV2(_response);
        });
    }

    protected processTempRecurringSMSDetailV2(response: AxiosResponse): Promise<TempRecurringSMSDetailResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<TempRecurringSMSDetailResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TempRecurringSMSDetailResponseDtoServiceResponse>(null as any);
    }
}

export class TestConsumerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return OK
     */
    testpaymentapproveconsumer( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/TestConsumer/testpaymentapproveconsumer";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTestpaymentapproveconsumer(_response);
        });
    }

    protected processTestpaymentapproveconsumer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VerifyClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return OK
     */
    countBillPaid(period: dayjs.Dayjs, cancelToken?: CancelToken | undefined): Promise<CountBillPaidResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/verify/countbillpaid?";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined and cannot be null.");
        else
            url_ += "Period=" + encodeURIComponent(period ? "" + period.format('YYYY-MM-DDTHH:mm:ss') : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCountBillPaid(_response);
        });
    }

    protected processCountBillPaid(response: AxiosResponse): Promise<CountBillPaidResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<CountBillPaidResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CountBillPaidResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    verifyBillPaid(body?: GetDebtHeaderVerifyRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<VerifyBillPaidResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/verify/billpaid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyBillPaid(_response);
        });
    }

    protected processVerifyBillPaid(response: AxiosResponse): Promise<VerifyBillPaidResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<VerifyBillPaidResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VerifyBillPaidResponseDtoServiceResponse>(null as any);
    }

    /**
     * @return OK
     */
    verifyProcessCompletion(requestId: string, cancelToken?: CancelToken | undefined): Promise<VerifyProcessCompletionResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/verify/processcompletion?";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined and cannot be null.");
        else
            url_ += "RequestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyProcessCompletion(_response);
        });
    }

    protected processVerifyProcessCompletion(response: AxiosResponse): Promise<VerifyProcessCompletionResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<VerifyProcessCompletionResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VerifyProcessCompletionResponseDtoServiceResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @param sortColumn (optional) 
     * @param ordering (optional) 
     * @return OK
     */
    getVerifyNotPaidFilter(requestId: string, page?: number | undefined, recordsPerPage?: number | undefined, sortColumn?: string | undefined, ordering?: string | undefined, cancelToken?: CancelToken | undefined): Promise<TempVerifyNotPaidSelectResultDtoListServiceResponseWithPagination> {
        let url_ = this.baseUrl + "/verify/notpaid/filter?";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined and cannot be null.");
        else
            url_ += "RequestId=" + encodeURIComponent("" + requestId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null)
            throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined)
            url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVerifyNotPaidFilter(_response);
        });
    }

    protected processGetVerifyNotPaidFilter(response: AxiosResponse): Promise<TempVerifyNotPaidSelectResultDtoListServiceResponseWithPagination> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200;
            return Promise.resolve<TempVerifyNotPaidSelectResultDtoListServiceResponseWithPagination>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TempVerifyNotPaidSelectResultDtoListServiceResponseWithPagination>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    downdloadReportVerifyNotPaid(body?: GetTempVerifyBillPaidRequestDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/verify/report/notpaid/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDowndloadReportVerifyNotPaid(_response);
        });
    }

    protected processDowndloadReportVerifyNotPaid(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
           // return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface Account {
    accountId?: string;
    accountCode?: string | undefined;
    referenceTypeId?: number | undefined;
    referenceCode?: string | undefined;
    referenceDetail?: string | undefined;
    refIN?: string | undefined;
    remainBalance?: number | undefined;
    searchDetail?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    /** ต้องการ Update ReferenceCode กรณีลงเป็น IN */
    isUpdateRefCode?: boolean | undefined;
    referenceType?: ReferenceType;
    accountTransaction?: AccountTransaction[] | undefined;
}

export interface AccountTransaction {
    accountTransactionId?: string;
    accountTransactionCode?: string | undefined;
    accountId?: string | undefined;
    accountTransactionSubTypeId?: number | undefined;
    amount?: number;
    detail?: string | undefined;
    reference1?: string | undefined;
    reference2?: string | undefined;
    reference3?: string | undefined;
    in?: string | undefined;
    paymentChannelId?: number | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    /** IN guid */
    debtDetailId?: string | undefined;
    /** group new */
    summaryDetailId?: string | undefined;
    account?: Account;
    paymentChannel?: PaymentChannel;
}

export interface Bank {
    bankId?: number;
    bankName?: string | undefined;
    bankShortName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    bankCode?: string | undefined;
    debtHeader?: DebtHeader[] | undefined;
    summaryDetail?: SummaryDetail[] | undefined;
    summaryHeader?: SummaryHeader[] | undefined;
}

export interface BillPaymentResponseDto {
    debtHeaderId?: string | undefined;
    bill?: string | undefined;
    applicationCode?: string | undefined;
    payerName?: string | undefined;
    productName?: string | undefined;
    premiumDebt?: number | undefined;
    fullAddress?: string | undefined;
    purchaserCount?: string | undefined;
    contactName?: string | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    ref3?: string | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    orderPaymentStatusId?: number | undefined;
    orderPaymentStatusName?: string | undefined;
    paymentChannelName?: string | undefined;
    phoneNo?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    summaryDetailId?: string | undefined;
    summaryDetailCode?: string | undefined;
    taxNo?: string | undefined;
    sourceTypeId?: number | undefined;
    sourceTypeName?: string | undefined;
}

export interface BillPaymentResponseDtoServiceResponse {
    data?: BillPaymentResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface CheckProcessSummaryFileNoRequestDto {
    summaryFileNoIds: string[];
}

export interface CheckProcessSummaryFileNoResponseDto {
    summaryFileNoId?: string | undefined;
    summaryFileNoName?: string | undefined;
    isKafkaPaymentSvcToPremium?: boolean | undefined;
    isUploadResults?: boolean | undefined;
}

export interface CheckProcessSummaryFileNoResponseDtoListServiceResponse {
    data?: CheckProcessSummaryFileNoResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface CountBillPaidResponseDto {
    billCount?: number | undefined;
}

export interface CountBillPaidResponseDtoServiceResponse {
    data?: CountBillPaidResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface CreateDirectDebitScheduleRequestDto {
    directDebitScheduleGroupId?: string | undefined;
}

export interface CreateRecurringSMSResponseDto {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface CreateRecurringSMSResponseDtoServiceResponse {
    data?: CreateRecurringSMSResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface CreateTempDirectDebitScheduleResponseDto {
    directDebitScheduleGroupId?: string;
}

export interface CreateTempDirectDebitScheduleResponseDtoServiceResponse {
    data?: CreateTempDirectDebitScheduleResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DebitingHistoriesDto_Response {
    summaryDetailId?: string;
    summaryDetailCode?: string | undefined;
    summaryHeaderCode?: string | undefined;
    bankName?: string | undefined;
    bankAccountNo?: string | undefined;
    bankAccountName?: string | undefined;
    phoneNo?: string | undefined;
    premiumDebt?: number | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    isSucceed?: boolean | undefined;
    description?: string | undefined;
}

export interface DebitingHistoriesDto_ResponseListServiceResponseWithPagination {
    data?: DebitingHistoriesDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface DebitingHistoriesHeaderDto_Response {
    summaryDetailId?: string;
    phoneNo?: string | undefined;
    bankId?: number | undefined;
    bankName?: string | undefined;
    bankAccountNo?: string | undefined;
    bankAccountName?: string | undefined;
}

export interface DebitingHistoriesHeaderDto_ResponseServiceResponse {
    data?: DebitingHistoriesHeaderDto_Response;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DebitingHistoryDetailsDto_Response {
    in?: string | undefined;
    applicationCode?: string | undefined;
    payerWorkPlaceProvince?: string | undefined;
    customerName?: string | undefined;
    productName?: string | undefined;
    totalAmount?: number | undefined;
    saleEmployee?: string | undefined;
}

export interface DebitingHistoryDetailsDto_ResponseListServiceResponseWithPagination {
    data?: DebitingHistoryDetailsDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface DebtDetail {
    debtDetailId?: string;
    debtHeaderId?: string | undefined;
    in?: string | undefined;
    applicationCode?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    periodTypeId?: number | undefined;
    periodFrom?: dayjs.Dayjs | undefined;
    periodTo?: dayjs.Dayjs | undefined;
    premiumSum?: number | undefined;
    discount?: number | undefined;
    totalAmount?: number | undefined;
    custName?: string | undefined;
    insuranceId?: number | undefined;
    receiveTypeId?: number | undefined;
    detail1?: string | undefined;
    detail2?: string | undefined;
    detail3?: string | undefined;
    remark?: string | undefined;
    isActive?: boolean | undefined;
    productId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    debtHeader?: DebtHeader;
    insurance?: Insurance;
    periodType?: PeriodType;
    receiveType?: ReceiveType;
    summaryDetailXRefDebt?: SummaryDetailXRefDebt[] | undefined;
}

export interface DebtDetailFeeResponseDto {
    in?: string | undefined;
    custName?: string | undefined;
}

export interface DebtDetailFeeResponseDtoListServiceResponse {
    data?: DebtDetailFeeResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DebtDetail_GetDebt {
    debtDetailId?: string;
    in?: string | undefined;
    applicationCode?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number;
    periodType?: GetDebtDetail_PeriodType;
    periodFrom?: dayjs.Dayjs | undefined;
    periodTo?: dayjs.Dayjs | undefined;
    premiumSum?: number;
    discount?: number;
    totalAmount?: number;
    custName?: string | undefined;
    detail1?: string | undefined;
    detail2?: string | undefined;
    detail3?: string | undefined;
    insurance?: GetDebtDetail_Insurance;
    receiveType?: GetDebtDetail_ReceiveType;
    remark?: string | undefined;
    debtGroup?: DebtGroup_GetDebt;
    summaryHeaders?: SummaryHeader_GetDebt[] | undefined;
}

export interface DebtDetail_GetPaySlip {
    debtDetailId?: string | undefined;
    in?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premiumSum?: number | undefined;
    discount?: number | undefined;
    totalAmount?: number | undefined;
    custName?: string | undefined;
    remark?: string | undefined;
    detail1?: string | undefined;
    detail2?: string | undefined;
    detail3?: string | undefined;
    periodType?: GetDebtDetail_PeriodType;
    insurance?: GetDebtDetail_Insurance;
}

export interface DebtGroup {
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    sourceTypeId?: number | undefined;
    paymentMethodTypeId?: number | undefined;
    itemCount?: number | undefined;
    totalAmount?: number | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    isSendSMSPaySlip?: boolean | undefined;
    isSendSMSBilling?: boolean | undefined;
    debtGroupStatusId?: number | undefined;
    debtGroupReferTypeId?: number | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    debtGroupReferType?: DebtGroupReferType;
    debtGroupStatus?: DebtGroupStatus;
    paymentMethodType?: PaymentMethodType;
    sourceType?: SourceType;
    debtHeader?: DebtHeader[] | undefined;
    summaryHeader?: SummaryHeader[] | undefined;
}

export interface DebtGroupReferType {
    debtGroupReferTypeId?: number;
    debtGroupReferTypeName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    remark?: string | undefined;
    debtGroup?: DebtGroup[] | undefined;
}

export interface DebtGroupReferTypeDto_Response {
    debtGroupReferTypeId?: number;
    debtGroupReferTypeName?: string | undefined;
}

export interface DebtGroupReferTypeDto_ResponseListServiceResponse {
    data?: DebtGroupReferTypeDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DebtGroupStatus {
    debtGroupStatusId?: number;
    debtGroupStatusName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    remark?: string | undefined;
    debtGroup?: DebtGroup[] | undefined;
}

export interface DebtGroupStatus_GetDebts {
    debtGroupStatusId?: number;
    debtGroupStatusName?: string | undefined;
}

export interface DebtGroup_GetDebt {
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    sourceTypeId?: number | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    debtGroupReferTypeId?: number | undefined;
    paymentMethodType?: PaymentMethodType_GetDebt;
}

export interface DebtGroup_GetDebtDetails {
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
}

export interface DebtGroup_GetDebts {
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    paymentMethodType?: PaymentMethodType_GetDebt;
    debtGroupStatus?: DebtGroupStatus_GetDebts;
}

export interface DebtHeader {
    debtHeaderId?: string;
    debtGroupId?: string | undefined;
    b?: string | undefined;
    payerName?: string | undefined;
    phoneNo?: string | undefined;
    premiumDebt?: number | undefined;
    bankId?: number | undefined;
    bankAccountName?: string | undefined;
    bankAccountNo?: string | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    ref3?: string | undefined;
    paymentStatusId?: number | undefined;
    paymentChannelId?: number | undefined;
    /** รหัสอ้างอิงกับ SummaryDetailId กรณี หักได้ */
    refSummaryDetailId?: string | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    itemCount?: number | undefined;
    isActive?: boolean | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    bank?: Bank;
    debtGroup?: DebtGroup;
    paymentChannel?: PaymentChannel;
    paymentStatus?: PaymentStatus;
    debtDetail?: DebtDetail[] | undefined;
}

export interface DebtHeaderByRefAndBillsDto_Response {
    debtHeaderId?: string;
    b?: string | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    payerName?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    phoneNo?: string | undefined;
    premiumDebt?: number | undefined;
    paymentStatusName?: string | undefined;
    debtGroupReferTypeId?: number | undefined;
}

export interface DebtHeaderByRefAndBillsDto_ResponseListServiceResponseWithPagination {
    data?: DebtHeaderByRefAndBillsDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface DebtHeaderFeesResponseDto {
    debtHeaderId?: string | undefined;
    b?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    paymentChannelName?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    paymentStatusName?: string | undefined;
}

export interface DebtHeaderFeesResponseDtoListServiceResponseWithPagination {
    data?: DebtHeaderFeesResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface DebtHeader_GetDebtDetails {
    debtHeaderId?: string;
    b?: string | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    ref3?: string | undefined;
}

export interface DebtHeader_GetPaySlip {
    debtHeaderId?: string | undefined;
    b?: string | undefined;
    payerName?: string | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    ref3?: string | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    premiumDebt?: number | undefined;
    sourceTypeId?: number;
    refDebtDetail?: DebtDetail_GetPaySlip[] | undefined;
}

export interface DebtHeadersResponseDto {
    b?: string | undefined;
    createDate?: dayjs.Dayjs | undefined;
    paymentStatusName?: string | undefined;
    paymentChannelName?: string | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    premiumDebt?: number | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    ref3?: string | undefined;
}

export interface DebtHeadersResponseDtoListServiceResponseWithPagination {
    data?: DebtHeadersResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Detail {
    debtDetailId?: string;
    in?: string | undefined;
    applicationCode?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    periodTypeName?: string | undefined;
    premiumSum?: number | undefined;
    discount?: number | undefined;
    totalAmount?: number | undefined;
    custName?: string | undefined;
    detail1?: string | undefined;
    detail2?: string | undefined;
    detail3?: string | undefined;
}

export interface DisableAccountRequestDto {
    period: dayjs.Dayjs;
    bankAccountNo: string;
    bankId: number;
    remark: string;
    debtGroupReferTypeId: number;
}

export interface DisableAccountResponseDto {
    isSuccess?: boolean | undefined;
    message?: string | undefined;
}

export interface DisableAccountResponseDtoServiceResponse {
    data?: DisableAccountResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DownloadTemplateExcelRequestDto {
    startDate: dayjs.Dayjs;
    endDate: dayjs.Dayjs;
    period: dayjs.Dayjs;
}

export interface ExcelFileUploadResponseDto {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
    tempCode?: string | undefined;
}

export interface ExcelFileUploadResponseDtoServiceResponse {
    data?: ExcelFileUploadResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetAccountBillDetailResponseDto {
    debtGroupReferTypeName?: string | undefined;
    in?: string | undefined;
    applicationCode?: string | undefined;
    totalAmount?: number | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
}

export interface GetAccountBillDetailResponseDtoListServiceResponse {
    data?: GetAccountBillDetailResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetAccountBillResponseDto {
    bankAccountNo?: string | undefined;
    bankAccountName?: string | undefined;
    bankId?: number | undefined;
    bankShortName?: string | undefined;
    isDisable?: boolean | undefined;
}

export interface GetAccountBillResponseDtoListServiceResponseWithPagination {
    data?: GetAccountBillResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetAccountDisableHistoryResponseDto {
    detail?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByEmpCode?: string | undefined;
    createdByEmpName?: string | undefined;
}

export interface GetAccountDisableHistoryResponseDtoListServiceResponse {
    data?: GetAccountDisableHistoryResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetAllBatchFilesDto_Response {
    summaryFileNoId?: string | undefined;
    summaryFileNoCode?: string | undefined;
    summaryFileName?: string | undefined;
    summaryHeaderId?: string | undefined;
    itemCount?: number | undefined;
    isSucessed?: number | undefined;
    isFailed?: number | undefined;
    totalAmount?: number | undefined;
    isReceiveFile?: boolean | undefined;
    transferAmount?: number | undefined;
    unTransferAmount?: number | undefined;
    transferDateTime?: dayjs.Dayjs | undefined;
    employeeCode?: string | undefined;
    title?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    employeePosition?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    updatedByEmployeeCode?: string | undefined;
    updatedByName?: string | undefined;
}

export interface GetAllBatchFilesDto_ResponseListServiceResponseWithPagination {
    data?: GetAllBatchFilesDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetBankDto_Response {
    bankId?: number;
    bankName?: string | undefined;
    bankShortName?: string | undefined;
}

export interface GetBankDto_ResponseListServiceResponse {
    data?: GetBankDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetBatchDetailsDto_Response {
    summaryDetailId?: string | undefined;
    summaryDetailCode?: string | undefined;
    bankAccountNo?: string | undefined;
    bankAccountName?: string | undefined;
    itemCount?: number | undefined;
    isSucceed?: boolean | undefined;
    description?: string | undefined;
    premiumDebt?: number | undefined;
}

export interface GetBatchDetailsDto_ResponseListServiceResponseWithPagination {
    data?: GetBatchDetailsDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetBatchsDto_Response {
    summaryHeaderId?: string | undefined;
    summaryHeaderCode?: string | undefined;
    totalAmount?: number | undefined;
    itemCount?: number | undefined;
    tranferAmount?: number | undefined;
    payableDate?: dayjs.Dayjs | undefined;
    sendServiceDate?: dayjs.Dayjs | undefined;
    bank?: GetBatchs_Bank;
    summaryHeaderStatus?: GetBatchs_SummaryHeaderStatus;
    debtGroup?: GetBatchs_DebtGroup;
    fileCount?: number | undefined;
    fileCountSucceed?: number | undefined;
}

export interface GetBatchsDto_ResponseListServiceResponseWithPagination {
    data?: GetBatchsDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetBatchs_Bank {
    bankId?: number | undefined;
    bankShortName?: string | undefined;
}

export interface GetBatchs_DebtGroup {
    debtGroupId?: string | undefined;
    debtGroupCode?: string | undefined;
    totalAmount?: number | undefined;
}

export interface GetBatchs_SummaryHeaderStatus {
    summaryHeaderStatusId?: number | undefined;
    summaryHeaderStatus?: string | undefined;
}

export interface GetBillDetailDto {
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    debtHeaderId?: string | undefined;
    b?: string | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    payerName?: string | undefined;
    premiumDebt?: number | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    debtGroupReferTypeId?: number | undefined;
}

export interface GetBillDetailDtoListServiceResponse {
    data?: GetBillDetailDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetBillDetailDtoServiceResponse {
    data?: GetBillDetailDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetBillPaymentDto_Response {
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    sourceTypeId?: number;
    itemCount?: number | undefined;
    debtHeader?: Header;
    debtDetail?: Detail[] | undefined;
    summaryHeaders?: SummaryHeader_BillPayment[] | undefined;
}

export interface GetBillPaymentDto_ResponseServiceResponse {
    data?: GetBillPaymentDto_Response;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetDebtDetailDto_Response {
    debtDetailId?: string;
    debtHeaderId?: string;
    in?: string | undefined;
    applicationCode?: string | undefined;
    saleEmployee?: string | undefined;
    productGruopName?: string | undefined;
    productName?: string | undefined;
    premium?: number;
    periodFrom?: dayjs.Dayjs | undefined;
    periodTo?: dayjs.Dayjs | undefined;
    premiumSum?: number;
    discount?: number;
    totalAmount?: number;
    custName?: string | undefined;
    detail1?: string | undefined;
    detail2?: string | undefined;
    detail3?: string | undefined;
    remark?: string | undefined;
    insurance?: GetDebtDetail_Insurance;
    periodType?: GetDebtDetail_PeriodType;
    receiveType?: GetDebtDetail_ReceiveType;
}

export interface GetDebtDetailDto_ResponseListServiceResponse {
    data?: GetDebtDetailDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetDebtDetail_Insurance {
    insuranceId?: number | undefined;
    insuranceName?: string | undefined;
}

export interface GetDebtDetail_PeriodType {
    periodTypeId?: number | undefined;
    periodTypeName?: string | undefined;
}

export interface GetDebtDetail_ReceiveType {
    receiveTypeId?: number | undefined;
    receiveTypeName?: string | undefined;
}

export interface GetDebtDetailsDto_Response {
    debtDetailId?: string;
    in?: string | undefined;
    applicationCode?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    periodFrom?: dayjs.Dayjs | undefined;
    periodTo?: dayjs.Dayjs | undefined;
    periodCount?: number | undefined;
    premium?: number | undefined;
    premiumSum?: number | undefined;
    discount?: number | undefined;
    totalAmount?: number | undefined;
    custName?: string | undefined;
    productId?: number | undefined;
    employeeCode?: string | undefined;
    employeeName?: string | undefined;
    periodType?: GetDebtDetail_PeriodType;
    debtHeader?: DebtHeader_GetDebtDetails;
    debtGroup?: DebtGroup_GetDebtDetails;
}

export interface GetDebtDetailsDto_ResponseListServiceResponseWithPagination {
    data?: GetDebtDetailsDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetDebtDto_Response {
    billNo?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number;
    premiumDebt?: number;
    paymentChannel?: PaymentChannel_GetDebt;
    paymentStatus?: PaymentStatus_GetDebt;
    debtDetails?: DebtDetail_GetDebt[] | undefined;
}

export interface GetDebtDto_ResponseListServiceResponse {
    data?: GetDebtDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetDebtEventsHistoryDto_Response {
    debtEventLogId?: string;
    debtHeaderId?: string;
    debtDetailId?: string | undefined;
    eventTypeId?: number | undefined;
    eventTypeName?: string | undefined;
    detail?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    employeeCode?: string | undefined;
    createdByUser?: string | undefined;
}

export interface GetDebtEventsHistoryDto_ResponseListServiceResponseWithPagination {
    data?: GetDebtEventsHistoryDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetDebtGroupStatusDto_Response {
    debtGroupStatusId?: number;
    debtGroupStatusName?: string | undefined;
}

export interface GetDebtGroupStatusDto_ResponseListServiceResponse {
    data?: GetDebtGroupStatusDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetDebtHeaderVerifyRequestDto {
    period: dayjs.Dayjs;
}

export interface GetDebtHistoryDto_Response {
    b?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    paymentMethodTypeId?: number | undefined;
    paymentMethodTypeName?: string | undefined;
}

export interface GetDebtHistoryDto_ResponseServiceResponse {
    data?: GetDebtHistoryDto_Response;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetDebtNewAppReportDtoV2_Response {
    billingCode?: string | undefined;
    debtGroupCode?: string | undefined;
    referenceCode?: string | undefined;
    debtGroupReferType?: string | undefined;
    paymentStatusName?: string | undefined;
    cancelCause?: string | undefined;
    bankName?: string | undefined;
    payerName?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrictName?: string | undefined;
    payerWorkPlaceDistrictName?: string | undefined;
    payerWorkPlaceProvinceName?: string | undefined;
    payerBranchName?: string | undefined;
    payerBranchStudyArea?: string | undefined;
    customerName?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    applicationCode?: string | undefined;
    insuranceName?: string | undefined;
    carRegister?: string | undefined;
    periodTypeName?: string | undefined;
    totalAmount?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    startCoverDate?: dayjs.Dayjs | undefined;
    paymentMethodTypeNameMaster?: string | undefined;
    paymentType?: string | undefined;
    paymentMethodTypeName?: string | undefined;
    createdDate?: string | undefined;
    createdTime?: string | undefined;
    payablePeriodToDate?: string | undefined;
    payablePeriodToTime?: string | undefined;
    receivedDate?: string | undefined;
    receivedTime?: string | undefined;
    saleEmployee?: string | undefined;
    saleEmployeePhoneNo?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
    saleEmployeeTeamName?: string | undefined;
    zebraCarNo?: string | undefined;
    zebraCarOwnerEmployeeCode?: string | undefined;
    totalCount?: number | undefined;
}

export interface GetDebtNewAppReportDtoV2_ResponseListServiceResponseWithPagination {
    data?: GetDebtNewAppReportDtoV2_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetDebtNewAppReportDto_Response {
    billingCode?: string | undefined;
    debtGroupCode?: string | undefined;
    referenceCode?: string | undefined;
    debtGroupReferType?: string | undefined;
    paymentStatusName?: string | undefined;
    cancelCause?: string | undefined;
    bankName?: string | undefined;
    bankAccountNo?: string | undefined;
    payerIDCardNo?: string | undefined;
    payerName?: string | undefined;
    payerPhoneNo?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrictName?: string | undefined;
    payerWorkPlaceDistrictName?: string | undefined;
    payerWorkPlaceProvinceName?: string | undefined;
    payerBranchName?: string | undefined;
    payerBranchStudyArea?: string | undefined;
    customerName?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: string | undefined;
    applicationCode?: string | undefined;
    insuranceName?: string | undefined;
    periodTypeName?: string | undefined;
    totalAmount?: string | undefined;
    premuimPerYear?: string | undefined;
    period?: string | undefined;
    startCoverDate?: string | undefined;
    paymentMethodTypeNameMaster?: string | undefined;
    paymentType?: string | undefined;
    paymentMethodTypeName?: string | undefined;
    createdDate?: string | undefined;
    payablePeriodToDate?: string | undefined;
    receivedDate?: string | undefined;
    saleEmployee?: string | undefined;
    saleEmployeePhoneNo?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
    saleEmployeeTeamName?: string | undefined;
    zebraCarNo?: string | undefined;
    zebraCarOwnerEmployeeCode?: string | undefined;
}

export interface GetDebtNewAppReportDto_ResponseListServiceResponseWithPagination {
    data?: GetDebtNewAppReportDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetDebtReportCollectSaleDto_Response {
    employeeCode?: string | undefined;
    employeeName?: string | undefined;
    pH_cAll?: number;
    pH_c1?: number;
    pH_c0?: number;
    pA30_cAll?: number;
    pA30_c1?: number;
    pA30_c0?: number;
    pL_cAll?: number;
    pL_c1?: number;
    pL_c0?: number;
    house_cAll?: number;
    house_c1?: number;
    house_c0?: number;
    cI_cAll?: number;
    cI_c1?: number;
    cI_c0?: number;
    motor_cAll?: number;
    motor_c1?: number;
    motor_c0?: number;
    other_cAll?: number;
    other_c1?: number;
    other_c0?: number;
}

export interface GetDebtReportCollectSaleDto_ResponseListServiceResponseWithPagination {
    data?: GetDebtReportCollectSaleDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetDebtsDto_Response {
    debtHeaderId?: string;
    b?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    paymentStatus?: PaymentStatus_GetDebt;
    paymentChannel?: PaymentChannel_GetDebt;
    debtGroup?: DebtGroup_GetDebts;
}

export interface GetDebtsDto_ResponseListServiceResponseWithPagination {
    data?: GetDebtsDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetInsuranceDto_Response {
    insuranceId?: number;
    insuranceName?: string | undefined;
}

export interface GetInsuranceDto_ResponseListServiceResponse {
    data?: GetInsuranceDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetPaySlipDto_Response {
    summaryDetailId?: string | undefined;
    phoneNo?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    totalAmount?: number | undefined;
    refDebHeader?: DebtHeader_GetPaySlip;
    summaryHeaders?: SummaryHeader_PaySlip;
}

export interface GetPaySlipDto_ResponseListServiceResponse {
    data?: GetPaySlipDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetPaygateFeeHeaderRequestDto {
    reportFromDate: dayjs.Dayjs;
    reportToDate: dayjs.Dayjs;
}

export interface GetPaygateFeeHeaderTotalResponseDto {
    totalRecord?: number | undefined;
    totalAmount?: number | undefined;
    totalDiscountAmount?: number | undefined;
    totalVatAmount?: number | undefined;
    readonly totalFeeAmount?: number | undefined;
    totalMerchantAmount?: number | undefined;
}

export interface GetPaygateFeeHeaderTotalResponseDtoServiceResponse {
    data?: GetPaygateFeeHeaderTotalResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetPaygateFeeHeadersResponseDto {
    reportDate?: dayjs.Dayjs | undefined;
    totalAmount?: number | undefined;
    discountAmount?: number | undefined;
    vat?: number | undefined;
    feeAmount?: number | undefined;
    merchantAmount?: number | undefined;
}

export interface GetPaygateFeeHeadersResponseDtoListServiceResponseWithPagination {
    data?: GetPaygateFeeHeadersResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetPaymentChannelDto_Response {
    paymentChannelId?: number;
    paymentChannelCode?: string | undefined;
    paymentChannelName?: string | undefined;
}

export interface GetPaymentChannelDto_ResponseListServiceResponse {
    data?: GetPaymentChannelDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetPaymentMethodTypeDto_Response {
    paymentMethodTypeId?: number;
    paymentMethodTypeCode?: string | undefined;
    paymentMethodTypeName?: string | undefined;
}

export interface GetPaymentMethodTypeDto_ResponseListServiceResponse {
    data?: GetPaymentMethodTypeDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetPaymentStatusDto_Response {
    paymentStatusId?: number;
    paymentStatusName?: string | undefined;
}

export interface GetPaymentStatusDto_ResponseListServiceResponse {
    data?: GetPaymentStatusDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetPeriodTypeDto_Response {
    periodTypeId?: number;
    periodTypeName?: string | undefined;
}

export interface GetPeriodTypeDto_ResponseListServiceResponse {
    data?: GetPeriodTypeDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetReceiveTypeDto_Response {
    receiveTypeId?: number;
    receiveTypeCode?: string | undefined;
    receiveTypeName?: string | undefined;
}

export interface GetReceiveTypeDto_ResponseListServiceResponse {
    data?: GetReceiveTypeDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetRecurringSMSResponseDto {
    recurringSMSHeaderId?: number | undefined;
    period?: dayjs.Dayjs | undefined;
    countData?: number | undefined;
    sumPremiumDebt?: number | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUser?: string | undefined;
    recurringSMSHeaderStatusId?: number | undefined;
    recurringSMSHeaderStatusName?: string | undefined;
}

export interface GetRecurringSMSResponseDtoListServiceResponseWithPagination {
    data?: GetRecurringSMSResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetRefundCauseDto_Response {
    refundCauseId?: number;
    refundCauseName?: string | undefined;
}

export interface GetRefundCauseDto_ResponseListServiceResponse {
    data?: GetRefundCauseDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetReportBankAccountNotRecurringDto_Response {
    debtGroupReferTypeName?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    applicationCode?: string | undefined;
    bankAccountNo?: string | undefined;
    bankAccountName?: string | undefined;
    bankName?: string | undefined;
    premiumDebt?: number | undefined;
    description?: string | undefined;
}

export interface GetReportBankAccountNotRecurringDto_ResponseListServiceResponseWithPagination {
    data?: GetReportBankAccountNotRecurringDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportBankAccountUnSuccessRecurringDto_Response {
    summaryHeaderId?: string;
    transactionDate?: dayjs.Dayjs | undefined;
    summaryHeaderCode?: string | undefined;
    debtGroupReferTypeName?: string | undefined;
    bankName?: string | undefined;
    bankAccountUnSuccessCount?: number | undefined;
    sumPremiumUnSuccess?: number;
    recurringDate?: dayjs.Dayjs | undefined;
}

export interface GetReportBankAccountUnSuccessRecurringDto_ResponseListServiceResponseWithPagination {
    data?: GetReportBankAccountUnSuccessRecurringDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportDebtBranchDebtGroupReferTypeDto_Response {
    debtPeriod?: dayjs.Dayjs | undefined;
    branchDetail?: string | undefined;
    totalApplicationDebtCount?: number;
    totalPremiumDebt?: number;
    rfT5ApplicationDebtCount?: number;
    rfT5PremiumDebt?: number;
    rfT6ApplicationDebtCount?: number;
    rfT6PremiumDebt?: number;
    rfT7ApplicationDebtCount?: number;
    rfT7PremiumDebt?: number;
}

export interface GetReportDebtBranchDebtGroupReferTypeDto_ResponseListServiceResponseWithPagination {
    data?: GetReportDebtBranchDebtGroupReferTypeDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportDebtBranchProductGroupDto_Response {
    debtPeriod?: dayjs.Dayjs | undefined;
    branchDetail?: string | undefined;
    debtGroupReferTypeName?: string | undefined;
    phApplicationDebtCount?: number;
    phPremiumDebt?: number;
    pA30ApplicationDebtCount?: number;
    pA30PremiumDebt?: number;
    plApplicationDebtCount?: number;
    plPremiumDebt?: number;
    houseApplicationDebtCount?: number;
    housePremiumDebt?: number;
    criticalillnessApplicationDebtCount?: number;
    criticalillnessPremiumDebt?: number;
}

export interface GetReportDebtBranchProductGroupDto_ResponseListServiceResponseWithPagination {
    data?: GetReportDebtBranchProductGroupDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportDebtCollectDto_Response {
    applicationCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    startCoverDate?: dayjs.Dayjs | undefined;
    debtGroupReferTypeName?: string | undefined;
    paymentStatusName?: string | undefined;
    customerName?: string | undefined;
    payerName?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrictName?: string | undefined;
    payerWorkPlaceDistrictName?: string | undefined;
    payerWorkPlaceProvinceName?: string | undefined;
    payerBranchName?: string | undefined;
    insuranceName?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    periodTypeName?: string | undefined;
    paymentChannelName?: string | undefined;
    receivedDate?: string | undefined;
    receivedTime?: string | undefined;
    totalAmount?: number | undefined;
    saleEmployee?: string | undefined;
    saleEmployeePhoneNo?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
    saleEmployeeTeamName?: string | undefined;
    zebraCarNo?: string | undefined;
    zebraCarOwnerEmployeeCode?: string | undefined;
}

export interface GetReportDebtCollectDto_ResponseListServiceResponseWithPagination {
    data?: GetReportDebtCollectDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportDebtCollectMotorResponseDto {
    applicationCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    startCoverDate?: dayjs.Dayjs | undefined;
    endCoverDate?: dayjs.Dayjs | undefined;
    debtGroupReferTypeName?: string | undefined;
    paymentStatusName?: string | undefined;
    customerName?: string | undefined;
    payerName?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrictName?: string | undefined;
    payerWorkPlaceDistrictName?: string | undefined;
    payerWorkPlaceProvinceName?: string | undefined;
    payerBranchName?: string | undefined;
    insuranceName?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    periodTypeName?: string | undefined;
    paymentChannelName?: string | undefined;
    receivedDate?: string | undefined;
    receivedTime?: string | undefined;
    totalAmount?: number | undefined;
    saleEmployee?: string | undefined;
    saleEmployeePhoneNo?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
    saleEmployeeTeamName?: string | undefined;
    zebraCarNo?: string | undefined;
    zebraCarOwnerEmployeeCode?: string | undefined;
    totalCount?: number | undefined;
}

export interface GetReportDebtCollectMotorResponseDtoListServiceResponseWithPagination {
    data?: GetReportDebtCollectMotorResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportDebtMonthlyReNewDto_Response {
    billingCode?: string | undefined;
    referenceCode?: string | undefined;
    applicationCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    startCoverDate?: dayjs.Dayjs | undefined;
    debtGroupReferTypeName?: string | undefined;
    paymentStatusName?: string | undefined;
    customerName?: string | undefined;
    payerName?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrictName?: string | undefined;
    payerWorkPlaceDistrictName?: string | undefined;
    payerWorkPlaceProvinceName?: string | undefined;
    payerBranchName?: string | undefined;
    payerBranchStudyArea?: string | undefined;
    insuranceName?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    periodTypeName?: string | undefined;
    paymentMethodTypeName?: string | undefined;
    paymentType?: string | undefined;
    paymentChannelName?: string | undefined;
    createdDate?: string | undefined;
    createdTime?: string | undefined;
    payablePeriodToDate?: string | undefined;
    payablePeriodToTime?: string | undefined;
    receivedDate?: string | undefined;
    receivedTime?: string | undefined;
    bankName?: string | undefined;
    totalAmount?: string | undefined;
    saleEmployee?: string | undefined;
    saleEmployeePhoneNo?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
    saleEmployeeTeamName?: string | undefined;
    zebraCarNo?: string | undefined;
    zebraCarOwnerEmployeeCode?: string | undefined;
}

export interface GetReportDebtMonthlyReNewDto_ResponseListServiceResponseWithPagination {
    data?: GetReportDebtMonthlyReNewDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportDebtOverdueDate_Reponse {
    appid?: string | undefined;
    custName?: string | undefined;
    productGroup?: string | undefined;
    product?: string | undefined;
    premium?: number | undefined;
    ff?: string | undefined;
    totalCount?: number | undefined;
}

export interface GetReportDebtOverdueDate_ReponseListServiceResponseWithPagination {
    data?: GetReportDebtOverdueDate_Reponse[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportDebtReNewPeriodRequestDto {
    period: dayjs.Dayjs;
    productGroupId?: number | undefined;
    saleEmployeeCode?: string | undefined;
    branchId?: string | undefined;
}

export interface GetReportDebtRecoverDto_Response {
    billingCode?: string | undefined;
    referenceCode?: string | undefined;
    debtGroupReferType?: string | undefined;
    paymentStatusName?: string | undefined;
    payerName?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrictName?: string | undefined;
    payerWorkPlaceDistrictName?: string | undefined;
    payerWorkPlaceProvinceName?: string | undefined;
    payerBranchName?: string | undefined;
    payerBranchStudyArea?: string | undefined;
    customerName?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    applicationCode?: string | undefined;
    insuranceName?: string | undefined;
    periodFrom?: dayjs.Dayjs | undefined;
    periodTo?: dayjs.Dayjs | undefined;
    periodCount?: number | undefined;
    totalAmount?: number | undefined;
    periodTypeName?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    startCoverDate?: dayjs.Dayjs | undefined;
    paymentMethodTypeNameMaster?: string | undefined;
    paymentMethodTypeName?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    payablePeriodToDate?: dayjs.Dayjs | undefined;
    receivedDate?: dayjs.Dayjs | undefined;
    saleEmployee?: string | undefined;
    saleEmployeePhoneNo?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
    saleEmployeeTeamName?: string | undefined;
}

export interface GetReportDebtRecoverDto_ResponseListServiceResponseWithPagination {
    data?: GetReportDebtRecoverDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportNewAppPremiumDto_Response {
    applicationCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    startCoverDate?: dayjs.Dayjs | undefined;
    customerName?: string | undefined;
    payerName?: string | undefined;
    payerBranchName?: string | undefined;
    payerBranchStudyArea?: string | undefined;
    insuranceName?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    periodTypeName?: string | undefined;
    paymentMethodTypeName?: string | undefined;
    paymentType?: string | undefined;
    paymentChannelName?: string | undefined;
    receivedDate?: string | undefined;
    receivedTime?: string | undefined;
    bankName?: string | undefined;
    totalAmount?: string | undefined;
    matchHeaderCode?: string | undefined;
    transferBankName?: string | undefined;
    transferBankAccountNo?: string | undefined;
    transferAmount?: number | undefined;
    saleEmployee?: string | undefined;
    saleEmployeePhoneNo?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
    saleEmployeeTeamName?: string | undefined;
}

export interface GetReportNewAppPremiumDto_ResponseListServiceResponseWithPagination {
    data?: GetReportNewAppPremiumDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportRecurringBankDto_Response {
    debtPeriod?: dayjs.Dayjs | undefined;
    debtGroupCode?: string | undefined;
    summaryHeaderCode?: string | undefined;
    debtGroupReferTypeName?: string | undefined;
    bankName?: string | undefined;
    payableDate?: dayjs.Dayjs | undefined;
    payableTime?: string | undefined;
    totalAmount?: number;
    accountAll?: number;
    premiumSuccess?: number;
    accountSuccess?: number;
    ph?: number;
    pA30?: number;
    pl?: number;
    house?: number;
    ci?: number;
    premiumUnSuccess?: number;
    accountUnSuccess?: number;
}

export interface GetReportRecurringBankDto_ResponseListServiceResponseWithPagination {
    data?: GetReportRecurringBankDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportRecurringBranchDto_Response {
    payerBranchId?: number;
    payerBranchName?: string | undefined;
    debtGroupReferTypeId?: number | undefined;
    debtGroupReferTypeName?: string | undefined;
    productTypeId?: number;
    productGroupName?: string | undefined;
    bankId?: number | undefined;
    bankName?: string | undefined;
    itemCount?: number;
    totalAmount?: number;
    itemCountSuccess?: number;
    transferAmount?: number;
    itemCountUnSuccess?: number;
    totalAmountUnSuccess?: number;
}

export interface GetReportRecurringBranchDto_ResponseListServiceResponseWithPagination {
    data?: GetReportRecurringBranchDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportRecurringDetailDto_Response {
    debtGroupCode?: string | undefined;
    summaryHeaderCode?: string | undefined;
    summaryDetailCode?: string | undefined;
    applicationCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    debtGroupReferTypeName?: string | undefined;
    debtGroupStatusName?: string | undefined;
    bankName?: string | undefined;
    bankAccountNo?: string | undefined;
    payerIDCardNo?: string | undefined;
    payerName?: string | undefined;
    payerPhoneNo?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrictName?: string | undefined;
    payerWorkPlaceDistrictName?: string | undefined;
    payerWorkPlaceProvinceName?: string | undefined;
    payerBranchName?: string | undefined;
    payerBranchStudyArea?: string | undefined;
    insuranceName?: string | undefined;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premiumDebt?: number | undefined;
    createdDate?: string | undefined;
    createdTime?: string | undefined;
    transactionDate?: string | undefined;
    transactionTime?: string | undefined;
    createByUser?: string | undefined;
    recurringResult?: string | undefined;
    description?: string | undefined;
    saleEmployee?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
    saleEmployeePhoneNo?: string | undefined;
}

export interface GetReportRecurringDetailDto_ResponseListServiceResponseWithPagination {
    data?: GetReportRecurringDetailDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportRefundDetailDto_Response {
    refundGroupCode?: string | undefined;
    refundHeaderCode?: string | undefined;
    refundDetailCode?: string | undefined;
    payerIdentityCard?: string | undefined;
    payerName?: string | undefined;
    payerPrimaryPhone?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrict?: string | undefined;
    payerWorkPlaceDistrict?: string | undefined;
    payerWorkPlaceProvince?: string | undefined;
    payerBranch?: string | undefined;
    payerStudyArea?: string | undefined;
    applicationCode?: string | undefined;
    productDetail?: string | undefined;
    productTypeDetail?: string | undefined;
    insuranceName?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    inCode?: string | undefined;
    bankTransactionDatetime?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
    refundCauseName?: string | undefined;
    bankAccountName?: string | undefined;
    bankAccount?: string | undefined;
    bankName?: string | undefined;
    refundTypeName?: string | undefined;
    refundHeaderStatusName?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    transferDate?: dayjs.Dayjs | undefined;
    employeeName?: string | undefined;
    employeeBranch?: string | undefined;
    employeePhoneNo?: string | undefined;
}

export interface GetReportRefundDetailDto_ResponseListServiceResponseWithPagination {
    data?: GetReportRefundDetailDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetReportRefundHeaderDto_Response {
    refundHeaderCode?: string | undefined;
    payerIdentityCard?: string | undefined;
    payerName?: string | undefined;
    payerPrimaryPhone?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrict?: string | undefined;
    payerWorkPlaceDistrict?: string | undefined;
    payerWorkPlaceProvince?: string | undefined;
    payerBranch?: string | undefined;
    payerStudyArea?: string | undefined;
    applicationCode?: string | undefined;
    productDetail?: string | undefined;
    productTypeDetail?: string | undefined;
    premiumPeriodFrom?: dayjs.Dayjs | undefined;
    premiumPeriodTo?: dayjs.Dayjs | undefined;
    periodCount?: number | undefined;
    premiumSum?: number | undefined;
    refundCauseName?: string | undefined;
    bankAccountName?: string | undefined;
    bankAccount?: string | undefined;
    bankName?: string | undefined;
    refundTypeName?: string | undefined;
    refundHeaderStatusName?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    transferDate?: dayjs.Dayjs | undefined;
}

export interface GetReportRefundHeaderDto_ResponseListServiceResponseWithPagination {
    data?: GetReportRefundHeaderDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetSettlementChillPayDetailResponseDto {
    transactionId?: number | undefined;
    convertPaymentDate?: dayjs.Dayjs | undefined;
    customer?: string | undefined;
    orderNo?: string | undefined;
    paymentChannel?: string | undefined;
    convertNetAmount?: number | undefined;
    convertFee?: number | undefined;
    convertServiceAmount?: number | undefined;
    convertServiceVAT?: number | undefined;
    convertServiceWHT?: number | undefined;
    convertSettleAmount?: number | undefined;
}

export interface GetSettlementChillPayDetailResponseDtoListServiceResponseWithPagination {
    data?: GetSettlementChillPayDetailResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetSettlementChillPayHeaderRequestDto {
    settleFromDate: dayjs.Dayjs;
    settleToDate: dayjs.Dayjs;
}

export interface GetSettlementChillPayHeaderResponseDto {
    ssSettledDate?: dayjs.Dayjs | undefined;
    totalRecord?: number | undefined;
    convertNetAmount?: number | undefined;
    convertServiceAmount?: number | undefined;
    convertServiceVAT?: number | undefined;
    convertServiceWHT?: number | undefined;
    convertSettleAmount?: number | undefined;
    readonly bankTransferFee?: number | undefined;
    readonly totalFee?: number | undefined;
}

export interface GetSettlementChillPayHeaderResponseDtoListServiceResponseWithPagination {
    data?: GetSettlementChillPayHeaderResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetSettlementChillPayHeaderResponseDtoServiceResponse {
    data?: GetSettlementChillPayHeaderResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetSettlementChillPayHeaderTotalResponseDto {
    totalRecord?: number | undefined;
    convertNetAmount?: number | undefined;
    convertServiceAmount?: number | undefined;
    convertServiceVAT?: number | undefined;
    convertServiceWHT?: number | undefined;
    convertSettleAmount?: number | undefined;
    bankTransferFee?: number | undefined;
    readonly totalFee?: number | undefined;
}

export interface GetSettlementChillPayHeaderTotalResponseDtoServiceResponse {
    data?: GetSettlementChillPayHeaderTotalResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetSourceTypeDto_Response {
    sourceTypeId?: number;
    sourceTypeName?: string | undefined;
}

export interface GetSourceTypeDto_ResponseListServiceResponse {
    data?: GetSourceTypeDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetSummaryFileNoBySummaryHeaderIdResponseDto {
    summaryFileNoId?: string | undefined;
    summaryFileName?: string | undefined;
}

export interface GetSummaryFileNoBySummaryHeaderIdResponseDtoListServiceResponse {
    data?: GetSummaryFileNoBySummaryHeaderIdResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetSummaryHeaderRecurringBankDto_Response {
    summaryHeaderId?: string;
    summaryHeaderCode?: string | undefined;
    inCode?: string | undefined;
    payableDate?: dayjs.Dayjs | undefined;
    bankId?: number | undefined;
    bankName?: string | undefined;
    itemCount?: number | undefined;
    totalAmount?: number | undefined;
    debtGroupReferTypeId?: number | undefined;
    debtGroupReferTypeName?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    saleEmployeeCode?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
}

export interface GetSummaryHeaderRecurringBankDto_ResponseListServiceResponseWithPagination {
    data?: GetSummaryHeaderRecurringBankDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface GetSummaryHeaderStatusDto_Response {
    summaryHeaderStatusId?: number;
    summaryHeaderStatusName?: string | undefined;
}

export interface GetSummaryHeaderStatusDto_ResponseListServiceResponse {
    data?: GetSummaryHeaderStatusDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetTempVerifyBillPaidRequestDto {
    requestId: string;
}

export interface Header {
    debtHeaderId?: string;
    billNo?: string | undefined;
    taxNo?: string | undefined;
    premiumDebt?: number | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    payerName?: string | undefined;
}

export interface Insurance {
    insuranceId?: number;
    insuranceName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    debtDetail?: DebtDetail[] | undefined;
}

export interface MatchHeader {
    matchHeaderId?: string;
    matchHeaderCode?: string | undefined;
    matchHeaderTypeId?: number | undefined;
    bankId?: number | undefined;
    bankAccountNo?: string | undefined;
    amoumt?: number | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    statement?: Statement[] | undefined;
    transferHeader?: TransferHeader[] | undefined;
}

export interface PaySlipResponseDto {
    bill?: string | undefined;
    applicationCode?: string | undefined;
    fullAddress?: string | undefined;
    payerName?: string | undefined;
    contactName?: string | undefined;
    purcheaserCount?: string | undefined;
    premiumDebt?: number | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    ref3?: string | undefined;
    productName?: string | undefined;
    payMentStatusId?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    debtHeaderId?: string | undefined;
    taxNo?: string | undefined;
}

export interface PaySlipResponseDtoServiceResponse {
    data?: PaySlipResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface PaymentChannel {
    paymentChannelId?: number;
    paymentChannelCode?: string | undefined;
    paymentChannelName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    accountTransaction?: AccountTransaction[] | undefined;
    debtHeader?: DebtHeader[] | undefined;
    transferHeader?: TransferHeader[] | undefined;
}

export interface PaymentChannel_GetDebt {
    paymentChannelId?: number;
    paymentChannelName?: string | undefined;
}

export interface PaymentHistoryReponseDto {
    bill?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    premiumDebt?: number | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    ref3?: string | undefined;
}

export interface PaymentHistoryReponseDtoListServiceResponseWithPagination {
    data?: PaymentHistoryReponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface PaymentMethodType {
    paymentMethodTypeId?: number;
    paymentMethodTypeCode?: string | undefined;
    paymentMethodTypeName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    debtGroup?: DebtGroup[] | undefined;
}

export interface PaymentMethodType_GetDebt {
    paymentMethodTypeId?: number;
    paymentMethodTypeName?: string | undefined;
}

export interface PaymentStatus {
    paymentStatusId?: number;
    paymentStatusName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    debtHeader?: DebtHeader[] | undefined;
}

export interface PaymentStatus_GetDebt {
    paymentStatusId?: number;
    paymentStatusName?: string | undefined;
}

export interface PeriodType {
    periodTypeId?: number;
    periodTypeName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    debtDetail?: DebtDetail[] | undefined;
}

export interface ReceiveDetail {
    receiveDetailId?: string;
    receiveDetailCode?: string | undefined;
    receiveHeaderId?: string | undefined;
    receiveTypeId?: number | undefined;
    applicationCode?: string | undefined;
    paymentCode?: string | undefined;
    custTitle?: string | undefined;
    custFirstName?: string | undefined;
    custLastName?: string | undefined;
    payerTitle?: string | undefined;
    payerFirstName?: string | undefined;
    payerLastName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    periodTypeId?: number | undefined;
    periodFrom?: dayjs.Dayjs | undefined;
    periodTo?: dayjs.Dayjs | undefined;
    periodCount?: number | undefined;
    premiumSum?: number | undefined;
    premiumDiscount?: number | undefined;
    premiumNet?: number | undefined;
    in?: string | undefined;
    remark?: string | undefined;
    insuranceCompanyId?: number | undefined;
    isCheque?: boolean | undefined;
    chequeNo?: string | undefined;
    chequeDate?: dayjs.Dayjs | undefined;
    transferHeaderId?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    summaryDetailId?: string | undefined;
    receiveHeader?: ReceiveHeader;
    receiveType?: ReceiveType;
    transferHeader?: TransferHeader;
}

export interface ReceiveHeader {
    receiveHeaderId?: string;
    receiveHeaderCode?: string | undefined;
    receiptTypeId?: number | undefined;
    amount?: number | undefined;
    itemCount?: number | undefined;
    remark?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    receiveDetail?: ReceiveDetail[] | undefined;
}

export interface ReceiveType {
    receiveTypeId?: number;
    /** mappingCode กับระบบเดิม */
    receiveTypeCode?: string | undefined;
    receiveTypeName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    debtDetail?: DebtDetail[] | undefined;
    receiveDetail?: ReceiveDetail[] | undefined;
}

export interface RecurringCheckResponseDto {
    isRecurringSMS?: boolean | undefined;
}

export interface RecurringCheckResponseDtoServiceResponse {
    data?: RecurringCheckResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface ReferenceType {
    referenceTypeId?: number;
    referenceTypeName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    account?: Account[] | undefined;
}

export interface RefundDetailsDto_Response {
    refundDetailCode?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    bankTransactionDatetime?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
}

export interface RefundDetailsDto_ResponseListServiceResponseWithPagination {
    data?: RefundDetailsDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface RefundHeaderStatusDto_Response {
    refundHeaderStatusId?: number | undefined;
    refundHeaderStatusName?: string | undefined;
}

export interface RefundHeaderStatusDto_ResponseListServiceResponse {
    data?: RefundHeaderStatusDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface RefundHeadersDto_Response {
    refundHeaderId?: string | undefined;
    refundHeaderCode?: string | undefined;
    appCode?: string | undefined;
    payerName?: string | undefined;
    payerIdentityCard?: string | undefined;
    bankShortName?: string | undefined;
    bankAccount?: string | undefined;
    premiumSum?: number | undefined;
    refundTypeName?: string | undefined;
    refundHeaderStatusName?: string | undefined;
    transferDate?: dayjs.Dayjs | undefined;
}

export interface RefundHeadersDto_ResponseListServiceResponseWithPagination {
    data?: RefundHeadersDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface ReportDebtCollectMotorRequestDto {
    expireFrom: dayjs.Dayjs;
    expireTo: dayjs.Dayjs;
    searchText?: string | undefined;
    searchIndex?: string | undefined;
    saleEmployeeCode?: string | undefined;
    paymentStatusId?: string | undefined;
    productGroupId?: string | undefined;
    paymentChannelId?: string | undefined;
    branchId?: string | undefined;
}

export interface ReportNewAppPAPaymentDateRequestDto {
    schoolYear: number;
    paymentDate: dayjs.Dayjs;
    branchId?: number | undefined;
    paymentMethodTypeId?: number | undefined;
}

export interface ReportTempDirectDebitScheduleRequestDto {
    directDebitScheduleGroupId: string;
}

export interface SMSCreateRequestDto {
    summaryHeaderId?: string | undefined;
    summaryDetailId?: string | undefined;
    phoneNo?: string | undefined;
    smsTypeId?: number | undefined;
}

export interface SMSDetailLogDto_Response {
    id?: number;
    smsDetailId?: string | undefined;
    phoneNo?: string | undefined;
    sendDate?: dayjs.Dayjs | undefined;
    createdDate?: dayjs.Dayjs | undefined;
}

export interface SMSDetailLogDto_ResponseListServiceResponse {
    data?: SMSDetailLogDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface SMSDetailStatusDto_Response {
    smsDetailStatusId?: number | undefined;
    smsDetailStatusName?: string | undefined;
}

export interface SMSDetailStatusDto_ResponseListServiceResponse {
    data?: SMSDetailStatusDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface SMSTypeDto_Response {
    smsTypeId?: number;
    smsTypeName?: string | undefined;
}

export interface SMSTypeDto_ResponseListServiceResponse {
    data?: SMSTypeDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface SendSmsV2Response {
    status?: string | undefined;
    detail?: string | undefined;
    language?: string | undefined;
    usedCredit?: string | undefined;
    sumPhone?: string | undefined;
    referenceId?: string | undefined;
}

export interface SendSmsV2ResponseServiceResponse {
    data?: SendSmsV2Response;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface SourceType {
    sourceTypeId?: number;
    sourceTypeName?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    debtGroup?: DebtGroup[] | undefined;
}

export interface Statement {
    statementId?: string;
    statementCode?: string | undefined;
    statementHeaderId?: string;
    transactionDateTime?: dayjs.Dayjs | undefined;
    tellerID?: string | undefined;
    transactionCode?: string | undefined;
    description?: string | undefined;
    chequeNo?: string | undefined;
    amount?: number | undefined;
    balance?: number | undefined;
    initBR?: string | undefined;
    matchHeaderId?: string | undefined;
    isClearCheck?: boolean | undefined;
    ckclR_TrCode?: string | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    ref?: string | undefined;
    matchHeader?: MatchHeader;
}

export interface StringServiceResponse {
    data?: string | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface SummaryDetail {
    summaryDetailId?: string;
    summaryDetailCode?: string | undefined;
    summaryFileNoId?: string | undefined;
    summaryHeaderId?: string | undefined;
    premiumDebt?: number | undefined;
    payerName?: string | undefined;
    phoneNo?: string | undefined;
    bankId?: number | undefined;
    bankAccountNo?: string | undefined;
    bankAccountName?: string | undefined;
    itemCount?: number | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    ref3?: string | undefined;
    /** รายละเอียด ผลการหัก */
    description?: string | undefined;
    isSucceed?: boolean | undefined;
    paymentChannelId?: number | undefined;
    transactionRef?: string | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    isActive?: boolean | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    isReconcile?: boolean | undefined;
    reconcileDate?: dayjs.Dayjs | undefined;
    isCancelDeduct?: boolean | undefined;
    bank?: Bank;
    summaryFileNo?: SummaryFileNo;
    summaryHeader?: SummaryHeader;
    summaryDetailXRefDebt?: SummaryDetailXRefDebt[] | undefined;
}

export interface SummaryDetailDto_Response {
    summaryDetailId?: string;
    summaryDetailCode?: string | undefined;
    summaryFileNoId?: string | undefined;
    summaryHeaderId?: string | undefined;
    premiumDebt?: number | undefined;
    payerName?: string | undefined;
    phoneNo?: string | undefined;
    bankId?: number | undefined;
    bankAccountNo?: string | undefined;
    bankAccountName?: string | undefined;
    itemCount?: number | undefined;
    ref1?: string | undefined;
    ref2?: string | undefined;
    ref3?: string | undefined;
    /** รายละเอียด ผลการหัก */
    description?: string | undefined;
    isSucceed?: boolean | undefined;
    paymentChannelId?: number | undefined;
    transactionRef?: string | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    isActive?: boolean | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    isReconcile?: boolean | undefined;
    reconcileDate?: dayjs.Dayjs | undefined;
    isCancelDeduct?: boolean | undefined;
    bank?: Bank;
    summaryFileNo?: SummaryFileNo;
    summaryHeader?: SummaryHeader;
    summaryDetailXRefDebt?: SummaryDetailXRefDebt[] | undefined;
}

export interface SummaryDetailDto_ResponseListServiceResponse {
    data?: SummaryDetailDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface SummaryDetailResponseDto {
    summaryDetailId?: string | undefined;
    summaryDetailCode?: string | undefined;
}

export interface SummaryDetailResponseDtoServiceResponse {
    data?: SummaryDetailResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface SummaryDetailXRefDebt {
    summaryDetailXRefDebtId?: number;
    summaryDetailId?: string | undefined;
    refDebHeaderId?: string | undefined;
    b?: string | undefined;
    bankAccountNo?: string | undefined;
    refDebtDetailId?: string | undefined;
    in?: string | undefined;
    applicationCode?: string | undefined;
    totalAmount?: number | undefined;
    refDebtDetail?: DebtDetail;
    summaryDetail?: SummaryDetail;
}

export interface SummaryDetailXRefDebtsDto_Response {
    in?: string | undefined;
    applicationCode?: string | undefined;
    totalAmount?: number | undefined;
    payerName?: string | undefined;
}

export interface SummaryDetailXRefDebtsDto_ResponseListServiceResponseWithPagination {
    data?: SummaryDetailXRefDebtsDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface SummaryFileNo {
    summaryFileNoId?: string;
    summaryFileNoCode?: string | undefined;
    summaryFileName?: string | undefined;
    summaryHeaderId?: string | undefined;
    itemCount?: number | undefined;
    totalAmount?: number | undefined;
    isReceiveFile?: boolean | undefined;
    transferAmount?: number | undefined;
    transferDateTime?: dayjs.Dayjs | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    summaryHeader?: SummaryHeader;
    summaryDetail?: SummaryDetail[] | undefined;
}

export interface SummaryFileNoWaitReceiveFileDto_Response {
    summaryFileNoId?: string | undefined;
    summaryFileNoCode?: string | undefined;
    summaryFileName?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
}

export interface SummaryFileNoWaitReceiveFileDto_ResponseListServiceResponse {
    data?: SummaryFileNoWaitReceiveFileDto_Response[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface SummaryHeader {
    summaryHeaderId?: string;
    summaryHeaderCode?: string | undefined;
    paymentMethodTypeId?: number | undefined;
    bankId?: number | undefined;
    /** วันที่หักเบี้ย */
    payableDate?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    summaryHeaderStatusId?: number | undefined;
    itemCount?: number | undefined;
    totalAmount?: number | undefined;
    itemCountSucceed?: number | undefined;
    transferAmount?: number | undefined;
    /** โอนเข้าบัญชี */
    transferBankAccountNo?: string | undefined;
    isActive?: boolean | undefined;
    sendServiceDate?: dayjs.Dayjs | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    debtGroupId?: string | undefined;
    displayPayablePeriodTo?: dayjs.Dayjs | undefined;
    bank?: Bank;
    debtGroup?: DebtGroup;
    summaryHeaderStatus?: SummaryHeaderStatus;
    summaryDetail?: SummaryDetail[] | undefined;
    summaryFileNo?: SummaryFileNo[] | undefined;
}

export interface SummaryHeaderStatus {
    summaryHeaderStatusId?: number;
    summaryHeaderStatusName?: string | undefined;
    isActive?: boolean | undefined;
    remark?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    summaryHeader?: SummaryHeader[] | undefined;
}

export interface SummaryHeader_BillPayment {
    summaryHeaderId?: string;
    summaryHeaderCode?: string | undefined;
    paymentMethodTypeId?: number | undefined;
    /** วันที่หักเบี้ย */
    payableDate?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    summaryHeaderStatusId?: number | undefined;
    displayPayablePeriodTo?: dayjs.Dayjs | undefined;
}

export interface SummaryHeader_GetDebt {
    summaryHeaderId?: string;
    summaryHeaderCode?: string | undefined;
    paymentMethodTypeId?: number | undefined;
    /** วันที่หักเบี้ย */
    payableDate?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    summaryHeaderStatusId?: number | undefined;
    displayPayablePeriodTo?: dayjs.Dayjs | undefined;
}

export interface SummaryHeader_PaySlip {
    summaryHeaderId?: string;
    summaryHeaderCode?: string | undefined;
    paymentMethodTypeId?: number | undefined;
    /** วันที่หักเบี้ย */
    payableDate?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    summaryHeaderStatusId?: number | undefined;
    displayPayablePeriodTo?: dayjs.Dayjs | undefined;
}

export interface SummaryInsertDto {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface SummaryInsertDtoServiceResponse {
    data?: SummaryInsertDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface SummaryInsertDto_Request {
    debtGroupId: string;
    bankId: number;
}

export interface TempRecurringSMSDetailResponseDto {
    period?: dayjs.Dayjs | undefined;
    totalTempRecurringSMS?: number | undefined;
    totalPremiumDebt?: number | undefined;
}

export interface TempRecurringSMSDetailResponseDtoServiceResponse {
    data?: TempRecurringSMSDetailResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface TempResultForBankManualDto_Response {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface TempResultForBankManualDto_ResponseServiceResponse {
    data?: TempResultForBankManualDto_Response;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface TempResultRefundDto_Response {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
    refundTotalCount?: number | undefined;
    refundTotalAmount?: number | undefined;
    refundCountSuccess?: number | undefined;
    refundSuccessTotalAmount?: number | undefined;
}

export interface TempResultRefundDto_ResponseServiceResponse {
    data?: TempResultRefundDto_Response;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface TempVerifyNotPaidSelectResultDto {
    period?: dayjs.Dayjs | undefined;
    bill?: string | undefined;
    applicationCode?: string | undefined;
    debtGroupReferTypeName?: string | undefined;
    premiumDebt?: number | undefined;
}

export interface TempVerifyNotPaidSelectResultDtoListServiceResponseWithPagination {
    data?: TempVerifyNotPaidSelectResultDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface TransferHeader {
    transferHeaderId?: string;
    transferHeaderCode?: string | undefined;
    transferTypeId?: number | undefined;
    transferDateTime?: dayjs.Dayjs | undefined;
    transferRemark?: string | undefined;
    bankId?: number | undefined;
    bankAccountNo?: string | undefined;
    compCode?: string | undefined;
    itemCount?: number | undefined;
    premiumAmount?: number | undefined;
    paymentChannelId?: number | undefined;
    matchHeaderId?: string | undefined;
    isActive?: boolean | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
    updatedByUserId?: number | undefined;
    isFee?: boolean | undefined;
    matchHeader?: MatchHeader;
    paymentChannel?: PaymentChannel;
    receiveDetail?: ReceiveDetail[] | undefined;
}

export interface UpdateStatusBillAndRepairRequestDto {
    debtHeaderId: string;
}

export interface VerifyBillPaidResponseDto {
    tempGroupId?: string | undefined;
}

export interface VerifyBillPaidResponseDtoServiceResponse {
    data?: VerifyBillPaidResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface VerifyProcessCompletionResponseDto {
    isCompletion?: boolean;
}

export interface VerifyProcessCompletionResponseDtoServiceResponse {
    data?: VerifyProcessCompletionResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_Application_SelectResult {
    applicationCode?: string | undefined;
    productId?: number | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    startCoverDate?: dayjs.Dayjs | undefined;
    cancelDate?: dayjs.Dayjs | undefined;
    applicationStatus?: string | undefined;
    custTitle?: string | undefined;
    custFirstName?: string | undefined;
    custLastName?: string | undefined;
    custBirthDate?: dayjs.Dayjs | undefined;
    payerIdentityCard?: string | undefined;
    payerTitle?: string | undefined;
    payerFirstName?: string | undefined;
    payerLastName?: string | undefined;
    payerPrimaryPhone?: string | undefined;
    payerWorkPlaceId?: number | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrictId?: number | undefined;
    payerWorkPlaceSubDistrict?: string | undefined;
    payerWorkPlaceDistrictId?: number | undefined;
    payerWorkPlaceDistrict?: string | undefined;
    payerWorkPlaceProvince?: string | undefined;
    saleEmployeeId?: number | undefined;
    saleEmployeeCode?: string | undefined;
    zebraCarId?: number | undefined;
    zebraCarCode?: string | undefined;
    zebraCarNo?: string | undefined;
    zebraCarOwnerEmployeeId?: number | undefined;
    zebraCarOwnerEmployeeCode?: string | undefined;
    applicationCreatedDate?: dayjs.Dayjs | undefined;
    applicationUpdatedDate?: dayjs.Dayjs | undefined;
    refIN?: string | undefined;
    projectId?: number | undefined;
    extUpdatedDate?: dayjs.Dayjs | undefined;
    payerBranch?: string | undefined;
    phoneNoBranch?: string | undefined;
    employeeCode?: string | undefined;
    title?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    nickName?: string | undefined;
    employeePosition?: string | undefined;
    employeeDepartment?: string | undefined;
    employeeBranch?: string | undefined;
    employeeStatus?: string | undefined;
    employeePhoneNo?: string | undefined;
}

export interface Usp_Application_SelectResultListServiceResponse {
    data?: Usp_Application_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_BankAccountNoForTransferManual_SelectResult {
    bankId?: number | undefined;
    bankName?: string | undefined;
    bankAccountNo?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_BankAccountNoForTransferManual_SelectResultListServiceResponse {
    data?: Usp_BankAccountNoForTransferManual_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_BankForTransferManual_SelectResult {
    bankId?: number | undefined;
    bankName?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_BankForTransferManual_SelectResultListServiceResponse {
    data?: Usp_BankForTransferManual_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_DebtDetailConfirmToSummary_SelectResult {
    bankId?: number | undefined;
    bankName?: string | undefined;
    bankShortName?: string | undefined;
    accountCount?: number | undefined;
    succeed?: number | undefined;
    notSend?: number | undefined;
    remain?: number | undefined;
    debtGroupId?: string | undefined;
    debtGroupStatusId?: number | undefined;
    isGenerate?: number | undefined;
    totalCount?: number | undefined;
}

export interface Usp_DebtDetailConfirmToSummary_SelectResultListServiceResponseWithPagination {
    data?: Usp_DebtDetailConfirmToSummary_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_DebtGroupConfirmToSummary_SelectResult {
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    accountCount?: number | undefined;
    totalAmount?: number | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    debtGroupStatusId?: number;
    debtGroupStatusName?: string | undefined;
    debtGroupReferTypeId?: number | undefined;
    debtGroupReferTypeName?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    createdEmployeeCode?: string | undefined;
    createdTitle?: string | undefined;
    createdFirstName?: string | undefined;
    createdLastName?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_DebtGroupConfirmToSummary_SelectResultListServiceResponseWithPagination {
    data?: Usp_DebtGroupConfirmToSummary_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_DebtHeaderAccountWrongCancel_UpdateResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_DebtHeaderAccountWrongCancel_UpdateResultListServiceResponse {
    data?: Usp_DebtHeaderAccountWrongCancel_UpdateResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_DebtHeaderforSMSDetail_SelectResult {
    smsTypeId?: number | undefined;
    smsType?: string | undefined;
    smsDetailStatusId?: number | undefined;
    smsDetailStatusName?: string | undefined;
    phoneNo?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    personName?: string | undefined;
}

export interface Usp_DebtHeaderforSMSDetail_SelectResultListServiceResponse {
    data?: Usp_DebtHeaderforSMSDetail_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_DebtHeaderforSMS_SelectResult {
    b?: string | undefined;
    payerName?: string | undefined;
    phoneNo?: string | undefined;
    debtGroupReferTypeName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    debtHeaderId?: string;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    debtGroupReferTypeId?: number | undefined;
    totalCount?: number | undefined;
}

export interface Usp_DebtHeaderforSMS_SelectResultListServiceResponseWithPagination {
    data?: Usp_DebtHeaderforSMS_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_DebtHeaderforSendSMS_SelectResult {
    smsTypeId?: number | undefined;
    smsType?: string | undefined;
    summaryDetailId?: string | undefined;
    summaryHeaderId?: string | undefined;
}

export interface Usp_DebtHeaderforSendSMS_SelectResultListServiceResponse {
    data?: Usp_DebtHeaderforSendSMS_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_DebtHeaderforSplitBillByDebtHeaderId_SelectResult {
    b?: string | undefined;
    payerName?: string | undefined;
    payerIdentityCard?: string | undefined;
    payerPassport?: string | undefined;
    phoneNo?: string | undefined;
    paymentMethodTypeId?: number | undefined;
    paymentMethodTypeName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    period?: dayjs.Dayjs | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    debtGroupId?: string;
    debtHeaderId?: string;
}

export interface Usp_DebtHeaderforSplitBillByDebtHeaderId_SelectResultListServiceResponse {
    data?: Usp_DebtHeaderforSplitBillByDebtHeaderId_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_DebtHeaderforSplitBills_SelectResult {
    debtHeaderId?: string;
    b?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    paymentMethodTypeId?: number | undefined;
    paymentMethodTypeName?: string | undefined;
    paymentChannelId?: number | undefined;
    paymentChannelName?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    splitBillHour_Expire?: number | undefined;
    totalCount?: number | undefined;
}

export interface Usp_DebtHeaderforSplitBills_SelectResultListServiceResponseWithPagination {
    data?: Usp_DebtHeaderforSplitBills_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_DebtMotorPeriods_SelectResult {
    debtHeaderId?: string;
    b?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    paymentChannelName?: string | undefined;
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    paymentMethodTypeId?: number | undefined;
    paymentMethodTypeName?: string | undefined;
    debtGroupStatusId?: number | undefined;
    debtGroupStatusName?: string | undefined;
    summaryHeaderStatusId?: number | undefined;
    totalCount?: number | undefined;
}

export interface Usp_DebtMotorPeriods_SelectResultListServiceResponseWithPagination {
    data?: Usp_DebtMotorPeriods_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_DebtPeriodsNew_SelectResult {
    debtHeaderId?: string;
    b?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    paymentChannelName?: string | undefined;
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    paymentMethodTypeId?: number | undefined;
    paymentMethodTypeName?: string | undefined;
    debtGroupStatusId?: number | undefined;
    debtGroupStatusName?: string | undefined;
    summaryHeaderStatusId?: number | undefined;
    totalCount?: number | undefined;
}

export interface Usp_DebtPeriodsNew_SelectResultListServiceResponseWithPagination {
    data?: Usp_DebtPeriodsNew_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_DebtPeriods_SelectResult {
    debtHeaderId?: string;
    b?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    paymentChannelName?: string | undefined;
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    paymentMethodTypeId?: number | undefined;
    paymentMethodTypeName?: string | undefined;
    debtGroupStatusId?: number | undefined;
    debtGroupStatusName?: string | undefined;
    summaryHeaderStatusId?: number | undefined;
    totalCount?: number | undefined;
}

export interface Usp_DebtPeriods_SelectResultListServiceResponseWithPagination {
    data?: Usp_DebtPeriods_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_Debts_SelectResult {
    debtHeaderId?: string;
    b?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    paymentChannelName?: string | undefined;
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    paymentMethodTypeId?: number | undefined;
    paymentMethodTypeName?: string | undefined;
    debtGroupStatusId?: number | undefined;
    debtGroupStatusName?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_Debts_SelectResultListServiceResponseWithPagination {
    data?: Usp_Debts_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_Debts_Select_v4Result {
    debtHeaderId?: string;
    b?: string | undefined;
    payerName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    paymentChannelName?: string | undefined;
    debtGroupId?: string;
    debtGroupCode?: string | undefined;
    payablePeriodFrom?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    paymentMethodTypeId?: number | undefined;
    paymentMethodTypeName?: string | undefined;
    debtGroupStatusId?: number | undefined;
    debtGroupStatusName?: string | undefined;
    summaryHeaderStatusId?: number | undefined;
    totalCount?: number | undefined;
}

export interface Usp_Debts_Select_v4ResultListServiceResponseWithPagination {
    data?: Usp_Debts_Select_v4Result[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_DirectDebitSchedule_InsertResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_DirectDebitSchedule_InsertResultServiceResponse {
    data?: Usp_DirectDebitSchedule_InsertResult;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_DirectDebitSchedule_SelectResult {
    directDebitScheduleId?: string | undefined;
    debtGroupReferTypeName?: string | undefined;
    bankId?: number | undefined;
    bankShortName?: string | undefined;
    directDebitScheduleTypeId?: number | undefined;
    scheduleDateTime?: dayjs.Dayjs | undefined;
    directDebitScheduleStatusId?: number | undefined;
    directDebitScheduleStatusDetail?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    remark?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_DirectDebitSchedule_SelectResultListServiceResponse {
    data?: Usp_DirectDebitSchedule_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_GenBillingAndPaySlip_TestResult {
    b?: string | undefined;
    urlType?: string | undefined;
    url?: string | undefined;
}

export interface Usp_GenBillingAndPaySlip_TestResultListServiceResponse {
    data?: Usp_GenBillingAndPaySlip_TestResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_GetDebtPeriodResult {
    debtPeriod?: dayjs.Dayjs | undefined;
}

export interface Usp_GetDebtPeriodResultListServiceResponse {
    data?: Usp_GetDebtPeriodResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_PaymentHistoryDetail_SelectResult {
    in?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrict?: string | undefined;
    payerWorkPlaceDistrict?: string | undefined;
    payerWorkPlaceProvince?: string | undefined;
    payerBranchDetail?: string | undefined;
    bankName?: string | undefined;
    bankAccountNo?: string | undefined;
    saleEmployee?: string | undefined;
    saleEmployeeBranchName?: string | undefined;
}

export interface Usp_PaymentHistoryDetail_SelectResultListServiceResponse {
    data?: Usp_PaymentHistoryDetail_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_PaymentHistoryHeader_SelectResult {
    applicationCode?: string | undefined;
    payerName?: string | undefined;
    payerIdentityCard?: string | undefined;
    payerPrimaryPhone?: string | undefined;
    customerName?: string | undefined;
    productTypeDetail?: string | undefined;
    productDetail?: string | undefined;
}

export interface Usp_PaymentHistoryHeader_SelectResultListServiceResponse {
    data?: Usp_PaymentHistoryHeader_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_PaymentHistoryList_SelectResult {
    in?: string | undefined;
    period?: dayjs.Dayjs | undefined;
    debtGroupReferTypeName?: string | undefined;
    totalAmount?: number | undefined;
    paymentMethodTypeName?: string | undefined;
    transactionDateTime?: dayjs.Dayjs | undefined;
    paymentStatusName?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_PaymentHistoryList_SelectResultListServiceResponseWithPagination {
    data?: Usp_PaymentHistoryList_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_ReceiveTypeForGenerateFeeBill_SelectResult {
    receiveTypeId?: number;
    receiveTypeName?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_ReceiveTypeForGenerateFeeBill_SelectResultListServiceResponse {
    data?: Usp_ReceiveTypeForGenerateFeeBill_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_ReceiveTypeForTransferManual_SelectResult {
    receiveTypeId?: number;
    receiveTypeName?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_ReceiveTypeForTransferManual_SelectResultListServiceResponse {
    data?: Usp_ReceiveTypeForTransferManual_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_ReportNewAppPAPremium_SelectResult {
    billNo?: string | undefined;
    applicationCode?: string | undefined;
    payerWorkPlaceName?: string | undefined;
    payerWorkPlaceSubDistrict?: string | undefined;
    payerWorkPlaceDistrict?: string | undefined;
    payerWorkPlaceProvince?: string | undefined;
    branchDetail?: string | undefined;
    siamSmileAreaName?: string | undefined;
    siamSmileAreaDirector?: string | undefined;
    premiumSum?: number | undefined;
    paymentMethodTypeName?: string | undefined;
    paymentChannelName?: string | undefined;
    paymentStatusName?: string | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    payablePeriodTo?: dayjs.Dayjs | undefined;
    transactionDatetime?: dayjs.Dayjs | undefined;
    employee?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_ReportNewAppPAPremium_SelectResultListServiceResponseWithPagination {
    data?: Usp_ReportNewAppPAPremium_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_SMSDetailMonitorByOrder_SelectResult {
    b?: string | undefined;
    payerName?: string | undefined;
    phoneNo?: string | undefined;
    smsTypeId?: number | undefined;
    smsType?: string | undefined;
    debtGroupReferTypeId?: number | undefined;
    debtGroupReferTypeName?: string | undefined;
    smsDetailStatusId?: number | undefined;
    smsDetailStatusName?: string | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    sendDate?: dayjs.Dayjs | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    refDebHeaderId?: string | undefined;
    smsDetailId?: string | undefined;
    summaryDetailId?: string | undefined;
    summaryHeaderId?: string | undefined;
    sourceTypeName?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_SMSDetailMonitorByOrder_SelectResultListServiceResponseWithPagination {
    data?: Usp_SMSDetailMonitorByOrder_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_SMSDetailMonitor_SelectResult {
    b?: string | undefined;
    payerName?: string | undefined;
    phoneNo?: string | undefined;
    smsTypeId?: number | undefined;
    smsType?: string | undefined;
    debtGroupReferTypeId?: number | undefined;
    debtGroupReferTypeName?: string | undefined;
    smsDetailStatusId?: number | undefined;
    smsDetailStatusName?: string | undefined;
    paymentStatusId?: number | undefined;
    paymentStatusName?: string | undefined;
    itemCount?: number | undefined;
    premiumDebt?: number | undefined;
    sendDate?: dayjs.Dayjs | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    refDebHeaderId?: string | undefined;
    smsDetailId?: string | undefined;
    summaryDetailId?: string | undefined;
    summaryHeaderId?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_SMSDetailMonitor_SelectResultListServiceResponseWithPagination {
    data?: Usp_SMSDetailMonitor_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_SMSDetailSubMonitor_SelectResult {
    debtDetailId?: string;
    productGroupName?: string | undefined;
    productName?: string | undefined;
    premium?: number | undefined;
    premiumSum?: number | undefined;
    discount?: number | undefined;
    totalAmount?: number | undefined;
    custName?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_SMSDetailSubMonitor_SelectResultListServiceResponseWithPagination {
    data?: Usp_SMSDetailSubMonitor_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_SummaryDetailCancel_UpdateResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_SummaryDetailCancel_UpdateResultListServiceResponse {
    data?: Usp_SummaryDetailCancel_UpdateResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_SummaryHeaderStatus_UpdateResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_SummaryHeaderStatus_UpdateResultServiceResponse {
    data?: Usp_SummaryHeaderStatus_UpdateResult;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_Summary_ValidateResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_Summary_ValidateResultListServiceResponse {
    data?: Usp_Summary_ValidateResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_TempDirectDebitSchedule_SelectResult {
    directDebitScheduleId?: string;
    debtGroupReferTypeName?: string | undefined;
    bankId?: number | undefined;
    bankShortName?: string | undefined;
    directDebitScheduleTypeId?: number | undefined;
    scheduleDate?: dayjs.Dayjs | undefined;
    createdDate?: dayjs.Dayjs | undefined;
    isValid?: boolean | undefined;
    validateResult?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_TempDirectDebitSchedule_SelectResultListServiceResponse {
    data?: Usp_TempDirectDebitSchedule_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_TempRecurringSMS_CountResult {
    bankId?: number | undefined;
    bankName?: string | undefined;
    bankShortName?: string | undefined;
    countBank?: number;
    countItem?: number | undefined;
    sumPremiumDebt?: number | undefined;
}

export interface Usp_TempRecurringSMS_CountResultListServiceResponse {
    data?: Usp_TempRecurringSMS_CountResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResultServiceResponse {
    data?: Usp_TempRecurringSMS_FromDebtUnPaid_ValidateResult;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_TempResultForBankManualCount_SelectResult {
    tempId?: string | undefined;
    summaryFileNoId?: string | undefined;
    countDebt?: number | undefined;
    isSucceed?: number | undefined;
    isFailed?: number | undefined;
    premiumDebt?: number | undefined;
    isSucceedPremium?: number | undefined;
    isFailedPremium?: number | undefined;
}

export interface Usp_TempResultForBankManualCount_SelectResultListServiceResponse {
    data?: Usp_TempResultForBankManualCount_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_TempResultForBankManual_PreviewResult {
    id?: number;
    tempId?: string | undefined;
    summaryFileNoId?: string | undefined;
    bankId?: number | undefined;
    bankAccountNo?: string | undefined;
    premiumDebt?: number | undefined;
    transactionDateTime?: dayjs.Dayjs | undefined;
    description?: string | undefined;
    isSucceed?: boolean | undefined;
    isAdd?: boolean | undefined;
    validateResult?: string | undefined;
}

export interface Usp_TempResultForBankManual_PreviewResultListServiceResponse {
    data?: Usp_TempResultForBankManual_PreviewResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_TempResultRefundToRefundHeader_UpdateResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_TempResultRefundToRefundHeader_UpdateResultServiceResponse {
    data?: Usp_TempResultRefundToRefundHeader_UpdateResult;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_TempResultToSummary_ForBankManual_UpdateResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_TempResultToSummary_ForBankManual_UpdateResultListServiceResponse {
    data?: Usp_TempResultToSummary_ForBankManual_UpdateResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_rcc_BankAccountNoForMatch_SelectResult {
    bankId?: number | undefined;
    bankName?: string | undefined;
    bankAccountNo?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_rcc_BankAccountNoForMatch_SelectResultListServiceResponse {
    data?: Usp_rcc_BankAccountNoForMatch_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_rcc_BankForMatch_SelectResult {
    bankId?: number;
    bankName?: string | undefined;
    totalCount?: number | undefined;
}

export interface Usp_rcc_BankForMatch_SelectResultListServiceResponse {
    data?: Usp_rcc_BankForMatch_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_rcc_CreateTransferManual_InsertResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_rcc_CreateTransferManual_InsertResultServiceResponse {
    data?: Usp_rcc_CreateTransferManual_InsertResult;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_rcc_MatchResult {
    isResult?: boolean | undefined;
    result?: string | undefined;
    msg?: string | undefined;
}

export interface Usp_rcc_MatchResultListServiceResponse {
    data?: Usp_rcc_MatchResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface Usp_rcc_Statement_WaitMatch_SelectResult {
    id?: string;
    code?: string | undefined;
    transactionDateTime?: dayjs.Dayjs | undefined;
    description?: string | undefined;
    amount?: number | undefined;
    totalCount?: number | undefined;
}

export interface Usp_rcc_Statement_WaitMatch_SelectResultListServiceResponseWithPagination {
    data?: Usp_rcc_Statement_WaitMatch_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface Usp_rcc_TransferHeader_WaitMatch_SelectResult {
    id?: string;
    code?: string | undefined;
    transactionDateTime?: dayjs.Dayjs | undefined;
    description?: string | undefined;
    amount?: number | undefined;
    totalCount?: number | undefined;
}

export interface Usp_rcc_TransferHeader_WaitMatch_SelectResultListServiceResponseWithPagination {
    data?: Usp_rcc_TransferHeader_WaitMatch_SelectResult[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number;
    totalAmountPages?: number;
    currentPage?: number;
    recordsPerPage?: number;
    pageIndex?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}