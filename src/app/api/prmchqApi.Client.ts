//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { customFormatter } from "../modules/_common/commonFunctions";
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import * as dayjs from 'dayjs';

export class ChequeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * แสดงข้อมูล paginate
     * @param chequeTypeIdList (optional) 
     * @param premiumSourceStatusIdList (optional) 
     * @param isExpireDate (optional) 
     * @param paymentGroupId (optional) 
     * @param sortField (optional) 
     * @param orderType (optional) 
     * @param searchTypeId (optional) 
     * @param searchDetail (optional) 
     * @param page (optional) 
     * @param recordsPerPage (optional) 
     * @return Success
     */
    getpremiumsourcepaginate(chequeTypeIdList?: string | undefined, premiumSourceStatusIdList?: string | undefined, isExpireDate?: boolean | undefined, paymentGroupId?: number | undefined, sortField?: string | undefined, orderType?: string | undefined, searchTypeId?: number | undefined, searchDetail?: string | undefined, page?: number | undefined, recordsPerPage?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Cheque/getpremiumsourcepaginate?";
        if (chequeTypeIdList === null)
            throw new Error("The parameter 'chequeTypeIdList' cannot be null.");
        else if (chequeTypeIdList !== undefined)
            url_ += "ChequeTypeIdList=" + encodeURIComponent("" + chequeTypeIdList) + "&";
        if (premiumSourceStatusIdList === null)
            throw new Error("The parameter 'premiumSourceStatusIdList' cannot be null.");
        else if (premiumSourceStatusIdList !== undefined)
            url_ += "PremiumSourceStatusIdList=" + encodeURIComponent("" + premiumSourceStatusIdList) + "&";
        if (isExpireDate === null)
            throw new Error("The parameter 'isExpireDate' cannot be null.");
        else if (isExpireDate !== undefined)
            url_ += "IsExpireDate=" + encodeURIComponent("" + isExpireDate) + "&";
        if (paymentGroupId === null)
            throw new Error("The parameter 'paymentGroupId' cannot be null.");
        else if (paymentGroupId !== undefined)
            url_ += "PaymentGroupId=" + encodeURIComponent("" + paymentGroupId) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (searchTypeId === null)
            throw new Error("The parameter 'searchTypeId' cannot be null.");
        else if (searchTypeId !== undefined)
            url_ += "SearchTypeId=" + encodeURIComponent("" + searchTypeId) + "&";
        if (searchDetail === null)
            throw new Error("The parameter 'searchDetail' cannot be null.");
        else if (searchDetail !== undefined)
            url_ += "SearchDetail=" + encodeURIComponent("" + searchDetail) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null)
            throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetpremiumsourcepaginate(_response);
        });
    }

    protected processGetpremiumsourcepaginate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * แสดงข้อมูล ผ่าน refCode / ref1
     * @param refCode (optional) 
     * @param ref1 (optional) 
     * @return Success
     */
    getpremiumsource(refCode?: string | undefined, ref1?: string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Cheque/getpremiumsource?";
        if (refCode === null)
            throw new Error("The parameter 'refCode' cannot be null.");
        else if (refCode !== undefined)
            url_ += "RefCode=" + encodeURIComponent("" + refCode) + "&";
        if (ref1 === null)
            throw new Error("The parameter 'ref1' cannot be null.");
        else if (ref1 !== undefined)
            url_ += "Ref1=" + encodeURIComponent("" + ref1) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetpremiumsource(_response);
        });
    }

    protected processGetpremiumsource(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * อัพเดตการชำระเงินผ่านเช็ค
     * @param body (optional) 
     * @return Success
     */
    updatepremiumsorce(refCode: string, body?: RequestUpdatePremiumSourceDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Cheque/updatepremiumsorce/{refCode}";
        if (refCode === undefined || refCode === null)
            throw new Error("The parameter 'refCode' must be defined.");
        url_ = url_.replace("{refCode}", encodeURIComponent("" + refCode));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatepremiumsorce(_response);
        });
    }

    protected processUpdatepremiumsorce(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * ยืนยันการชำระเงิน
     * @param body (optional) 
     * @return Success
     */
    paymentapprove(body?: RequestApprovePaymentDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Cheque/paymentapprove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body, customFormatter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPaymentapprove(_response);
        });
    }

    protected processPaymentapprove(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * ตรวจสอบ cheque no ว่าซ้ำหรือไม่
     * @return Success
     */
    chequedupicate(chequeNo: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Cheque/chequedupicate/{ChequeNo}";
        if (chequeNo === undefined || chequeNo === null)
            throw new Error("The parameter 'chequeNo' must be defined.");
        url_ = url_.replace("{ChequeNo}", encodeURIComponent("" + chequeNo));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChequedupicate(_response);
        });
    }

    protected processChequedupicate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param debtHeaderId (optional) 
     * @param refCode (optional) 
     * @return Success
     */
    getDocument(debtHeaderId?: string | undefined, refCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<GetDocumentResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/Cheque/document?";
        if (debtHeaderId === null)
            throw new Error("The parameter 'debtHeaderId' cannot be null.");
        else if (debtHeaderId !== undefined)
            url_ += "DebtHeaderId=" + encodeURIComponent("" + debtHeaderId) + "&";
        if (refCode === null)
            throw new Error("The parameter 'refCode' cannot be null.");
        else if (refCode !== undefined)
            url_ += "RefCode=" + encodeURIComponent("" + refCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDocument(_response);
        });
    }

    protected processGetDocument(response: AxiosResponse): Promise<GetDocumentResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<GetDocumentResponseDtoListServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDocumentResponseDtoListServiceResponse>(null as any);
    }
}

export class ChequeSlipClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * แสดงใบรับฝากเช็ค
     * @param refCode (optional) 
     * @return Success
     */
    chequeslip(refCode?: string | undefined, cancelToken?: CancelToken | undefined): Promise<ChequeSlipResponseDtoListServiceResponse> {
        // let url_ = this.baseUrl + "/ChequeSlip/chequeslip?";
        let url_ = this.baseUrl + "/cheque/slip?";
        if (refCode === null)
            throw new Error("The parameter 'refCode' cannot be null.");
        else if (refCode !== undefined)
            url_ += "RefCode=" + encodeURIComponent("" + refCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChequeslip(_response);
        });
    }

    protected processChequeslip(response: AxiosResponse): Promise<ChequeSlipResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<ChequeSlipResponseDtoListServiceResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChequeSlipResponseDtoListServiceResponse>(null as any);
    }
}

export class ExampleContollerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    get(cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Example/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            //const _responseText = response.data;
            //return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface ChequeSlipResponseDTO {
    refCode: string;
    applicationCode: string;
    billNo: string;
    payerName: string;
    chequeTypeName: string;
    premiumDebt: number;
    transactionDatetime: dayjs.Dayjs | undefined;
    productPackageDisplayName: string;
    bankName: string;
    bankAccountNo: string;
    chequeNo: string;
    checkPaymentDate: dayjs.Dayjs | undefined;
}

export interface ChequeSlipResponseDtoListServiceResponse {
    data?: ChequeSlipResponseDTO | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface GetDocumentResponseDto {
    debtHeaderId?: string | undefined;
    documentCode?: string | undefined;
    documentId?: string | undefined;
    source?: string | undefined;
}

export interface GetDocumentResponseDtoListServiceResponse {
    data?: GetDocumentResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface RequestApprovePaymentDto {
    ref1: string;
    statementId?: string | undefined;
    statementTransactionDateTime?: dayjs.Dayjs | undefined;
}

export interface RequestUpdatePremiumSourceDto {
    debtHeaderId: string;
    applicationCode: string;
    billNo: string;
    documentCode: string;
    chequeNo: string;
    checkPaymentDate: dayjs.Dayjs;
    chequeTypeId: number;
    productPackageDisplayName: string;
    paymentGroupId: number;
    bankId: number;
    bankName: string;
    bankAccountNo?: string | undefined;
    documentId?: string | undefined;
    policyNo?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}